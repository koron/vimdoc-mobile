---
layout: vimdoc
helpname: 'syntax'
---
<a class="Constant" href="syntax.html" name="syntax.txt">*syntax.txt*</a>&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;<span class="Identifier">Vim バージョン 7.3.</span>&nbsp;&nbsp;Last change: 2012 Feb 11<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VIMリファレンスマニュアル&nbsp;&nbsp;&nbsp;&nbsp;by Bram Moolenaar<br>
<br>
<br>
構文ハイライト&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#syntax" name="syntax">*syntax*</a>&nbsp;<a class="Constant" href="syntax.html#syntax-highlighting" name="syntax-highlighting">*syntax-highlighting*</a>&nbsp;<a class="Constant" href="syntax.html#coloring" name="coloring">*coloring*</a><br>
<br>
Vimは構文ハイライトによってテキストの一部を別のフォントや色で表示することがで<br>
きる。ハイライトするキーワードやテキストは、正規表現パターンによって指定する。<br>
動作を速く保つため、ファイル全体を構文解析するわけではないから、このハイライト<br>
方法には限界が存在する。単語(レキシカル)ハイライトと呼ぶのがより正しいが、皆が<br>
構文ハイライトと呼ぶのでそう呼び続けている。<br>
<br>
Vimは全ての端末で構文ハイライトをサポートしている。しかし、多くの普通の端末に<br>
はごく限られたハイライト手段しか提供されていないので、GUI版のgvimで動作させた<br>
ときに見栄えが最もよくなる。<br>
<br>
ユーザマニュアルにおける記述:<br>
<a class="Identifier" href="usr_06.html">|usr_06.txt|</a>&nbsp;構文ハイライトの紹介。<br>
<a class="Identifier" href="usr_44.html">|usr_44.txt|</a>&nbsp;構文ファイルの記述方法の紹介。<br>
<br>
1.&nbsp;&nbsp;クイックスタート&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-qstart">|:syn-qstart|</a><br>
2.&nbsp;&nbsp;構文ファイル&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-files">|:syn-files|</a><br>
3.&nbsp;&nbsp;構文ファイル読込の手順&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#syntax-loading">|syntax-loading|</a><br>
4.&nbsp;&nbsp;構文ファイルの覚書&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-file-remarks">|:syn-file-remarks|</a><br>
5.&nbsp;&nbsp;構文を定義する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-define">|:syn-define|</a><br>
6.&nbsp;&nbsp;:syntaxの引数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-arguments">|:syn-arguments|</a><br>
7.&nbsp;&nbsp;syntaxのパターン&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-pattern">|:syn-pattern|</a><br>
8.&nbsp;&nbsp;クラスタ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-cluster">|:syn-cluster|</a><br>
9.&nbsp;&nbsp;構文ファイルのインクルード&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-include">|:syn-include|</a><br>
10. 表示のシンクロナイズ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-sync">|:syn-sync|</a><br>
11. 構文アイテムのリストを表示する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syntax">|:syntax|</a><br>
12. ハイライトコマンド&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:highlight">|:highlight|</a><br>
13. グループのリンク&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:highlight-link">|:highlight-link|</a><br>
14. 構文の消去&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-clear">|:syn-clear|</a><br>
15. 関数名などのハイライト&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#tag-highlight">|tag-highlight|</a><br>
16. ウィンドウローカル構文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:ownsyntax">|:ownsyntax|</a><br>
17. カラー対応xterm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#xterm-color">|xterm-color|</a><br>
<br>
{これらのコマンドはViには存在しない}<br>
<br>
コンパイル時に<a class="Identifier" href="various.html#+syntax">|+syntax|</a>機能を無効にした場合には構文ハイライトは利用することは<br>
できない。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
1. クイックスタート&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-qstart" name=":syn-qstart">*:syn-qstart*</a><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-enable" name=":syn-enable">*:syn-enable*</a>&nbsp;<a class="Constant" href="syntax.html#:syntax-enable" name=":syntax-enable">*:syntax-enable*</a><br>
次のコマンドで構文ハイライトが有効になる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syntax enable</span><br>
<br>
このコマンドにより実際には次のコマンドが実行される&nbsp;<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:source $VIMRUNTIME/syntax/syntax.vim</span><br>
<br>
環境変数VIMが設定されていない場合は、Vimは別の方法(<a class="Identifier" href="starting.html#$VIMRUNTIME">|$VIMRUNTIME|</a>参照)でパスの<br>
検索を試みる。通常はこれでうまくいく。うまく動作しない場合は、環境変数VIMにVim<br>
の構成ファイルが置いてあるディレクトリの設定を試みる。例えば、構文ファイルがディ<br>
レクトリ&quot;/usr/vim/vim50/syntax&quot;にあるならば、$VIMRUNTIMEに&quot;/usr/vim/vim50&quot;を設<br>
定する。これはVimを起動する前に、シェルで設定しておかなければならない。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-on" name=":syn-on">*:syn-on*</a>&nbsp;<a class="Constant" href="syntax.html#:syntax-on" name=":syntax-on">*:syntax-on*</a><br>
コマンド&quot;:syntax enable&quot;は現在の色設定を変更しない。そのため、このコマンドを使<br>
用する前後にコマンド&quot;:highlight&quot;で好みの色を設定することができる。現在の設定を<br>
破棄して、デフォルトの色を設定させたい場合は次のコマンドを使用する:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syntax on</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:hi-normal" name=":hi-normal">*:hi-normal*</a>&nbsp;<a class="Constant" href="syntax.html#:highlight-normal" name=":highlight-normal">*:highlight-normal*</a><br>
GUIを使用している場合は、次のコマンドで黒地に白文字を設定できる:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:highlight Normal guibg=Black guifg=White</span><br>
カラー端末については<a class="Identifier" href="syntax.html#:hi-normal-cterm">|:hi-normal-cterm|</a>を参照。<br>
自分自身で色を設定する方法については<a class="Identifier" href="syntax.html#syncolor">|syncolor|</a>を参照。<br>
<br>
<span class="Todo">NOTE</span>: MS-DOSとWindowsの構文ファイルは改行コードが<span class="Special">&lt;CR&gt;&lt;NL&gt;</span>である。UNIXでは<span class="Special">&lt;NL&gt;</span><br>
である。自分のシステムに合った改行コードのファイルを使わなければならない。しか<br>
し、MS-DOSとWindowsではオプション<a class="Type" href="options.html#'fileformats'">'fileformats'</a>が空でなければ正しい形式が自動的<br>
に選択される。<br>
<br>
<span class="Todo">NOTE</span>: 反転表示(&quot;gvim -fg white -bg black&quot;)を使用する場合、<a class="Identifier" href="gui.html#gvimrc">|gvimrc|</a>が読込まれた<br>
後、GUIウィンドウが開かれるまでは<a class="Type" href="options.html#'background'">'background'</a>のデフォルト値が設定されない。そ<br>
のせいで誤ったデフォルトのハイライトが使用されてしまう。ハイライト表示を有効化<br>
する前に<a class="Type" href="options.html#'background'">'background'</a>のデフォルト値を設定するには、<a class="Identifier" href="gui.html#gvimrc">|gvimrc|</a>にコマンド&quot;:gui&quot;を含<br>
めればよい:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :gui&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; ウィンドウを開き、'background'にデフォルト値を設定する</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax on&nbsp;&nbsp; &quot; ハイライトを有効化し、'background'にもとづいて色を設定する</span><br>
<br>
<span class="Todo">NOTE</span>:&nbsp;<a class="Identifier" href="gui.html#.gvimrc">|.gvimrc|</a>の中で&quot;:gui&quot;を使用すると&quot;gvim -f&quot;によりフォアグラウンドで開始す<br>
ることができなくなる。その際は&quot;:gui -f&quot;を使用すること。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#g:syntax_on" name="g:syntax_on">*g:syntax_on*</a><br>
次のコマンドで構文ハイライトの有効・無効を切換えることができる:<br>
<span class="Comment">&nbsp;&nbsp; :if exists(&quot;g:syntax_on&quot;) | syntax off | else | syntax enable | endif</span><br>
<br>
これをキーマップに設定するには、以下のように書く:<br>
<span class="Comment">&nbsp;&nbsp; :map &lt;F7&gt; :if exists(&quot;g:syntax_on&quot;) &lt;Bar&gt;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp; syntax off &lt;Bar&gt;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ else &lt;Bar&gt;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp; syntax enable &lt;Bar&gt;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ endif &lt;CR&gt;</span><br>
[全ての文字をそのまま入力すること]<br>
<br>
詳細<br>
コマンド&quot;:syntax&quot;はファイルをsourceすることで実装されている。その際にsourceさ<br>
れるファイルの中身を見れば、このコマンドがどのように動作しているのか正確に知る<br>
ことができる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">コマンド&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイル</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;:syntax enable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$VIMRUNTIME/syntax/syntax.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;:syntax on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$VIMRUNTIME/syntax/syntax.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;:syntax manual&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$VIMRUNTIME/syntax/manual.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;:syntax off&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $VIMRUNTIME/syntax/nosyntax.vim<br>
<a class="Identifier" href="syntax.html#syntax-loading">|syntax-loading|</a>も参照。<br>
<br>
<span class="Todo">NOTE</span>: 長い行があって表示が遅く、構文ハイライトをオフにしたくなるような場合は、<br>
<a class="Type" href="options.html#'synmaxcol'">'synmaxcol'</a>&nbsp;をもっと小さい値にすることも考えてみること。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
2. 構文ハイライトファイル&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-files" name=":syn-files">*:syn-files*</a><br>
<br>
ある1つの言語用の構文とハイライト色定義コマンドは通常1つのファイル(以下構文ファ<br>
イル)に格納される。名前は&quot;<span class="Special">{name}</span>.vim&quot;と付ける慣習になっている。<span class="Special">{name}</span>はその言<br>
語の名前か短縮名となる(DOSファイルシステムで要求される、8.3文字の形式にあわせ<br>
ることが望ましい)。<br>
例:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.vim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perl.vim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java.vim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;html.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cpp.vim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sh.vim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;csh.vim<br>
<br>
構文ファイルには、vimrcファイルと同様にExコマンドを記述できる。しかし1つのファ<br>
イルには、1つの言語のためのコマンドだけを記述するよう取り決めている。ある言語<br>
が別の言語のスーパーセットである時には、他のファイルを内包していても良く、例え<br>
ば、ファイルcpp.vimはファイルc.vimを取り込むようになっている:<br>
<span class="Comment">&nbsp;&nbsp; :so $VIMRUNTIME/syntax/c.vim</span><br>
<br>
通常これらの構文ファイルはオートコマンドにより読込まれる。例:<br>
<span class="Comment">&nbsp;&nbsp; :au Syntax c&nbsp;&nbsp;&nbsp;&nbsp; source $VIMRUNTIME/syntax/c.vim</span><br>
<span class="Comment">&nbsp;&nbsp; :au Syntax cpp&nbsp;&nbsp; source $VIMRUNTIME/syntax/cpp.vim</span><br>
このようなコマンドはファイル$VIMRUNTIME/syntax/synload.vimに書かれている。<br>
<br>
<br>
<br>
独自構文ファイルの作成&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#mysyntaxfile" name="mysyntaxfile">*mysyntaxfile*</a><br>
<br>
独自の構文ファイルを作成し、&quot;:syntax enable&quot;をしたとき自動的にそのファイルが使<br>
われるようにするには、以下のようにする:<br>
<br>
1. ユーザランタイムディレクトリを作成する。通常はオプション<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>に示さ<br>
&nbsp;&nbsp; れる最初のディレクトリを使用する。UNIXの例では:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkdir ~/.vim</span><br>
<br>
2. &quot;syntax&quot;という名のディレクトリを作成する。UNIXでは:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkdir ~/.vim/syntax</span><br>
<br>
3. Vimの構文ファイルを作成する。もしくはインターネットからダウンロードする。そ<br>
&nbsp;&nbsp; のファイルはディレクトリsyntaxに置く。構文&quot;mine&quot;の例では:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:w ~/.vim/syntax/mine.vim</span><br>
<br>
これで独自構文ファイルを手動で使うことはできるようになっている:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set syntax=mine</span><br>
このコマンドを実行するためにVimを再起動する必要はない。<br>
<br>
このファイルタイプが認識されるようにするには、<a class="Identifier" href="filetype.html#new-filetype">|new-filetype|</a>を参照。<br>
<br>
システム管理者としてユーザ全てに独自構文ファイルを使わせるには、各ユーザに同じ<br>
構文ファイルをインストールさせる必要はなく、全ユーザ共通の<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>ディレ<br>
クトリにインストールすればよい。<br>
<br>
<br>
既存の構文ファイルに設定を追加する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#mysyntaxfile-add" name="mysyntaxfile-add">*mysyntaxfile-add*</a><br>
<br>
既存の構文ファイルでほぼ満足だが、いくつかの設定を追加したりハイライト手法を変<br>
更したい場合には、以下の手順に従う:<br>
<br>
1. 上同様、<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>に示されるユーザディレクトリを作成する。<br>
<br>
2. &quot;after/syntax&quot;というディレクトリを作成する。UNIXの例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkdir ~/.vim/after</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkdir ~/.vim/after/syntax</span><br>
<br>
3. 追加設定を行なうコマンドを含むVimスクリプトファイルを作成する。例として、C<br>
&nbsp;&nbsp; 言語のコメントの色を変更するには:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;highlight cComment ctermfg=Green guifg=Green</span><br>
<br>
4. その設定ファイルをディレクトリ&quot;after/syntax&quot;に置く。名前には構文名に&quot;.vim&quot;<br>
&nbsp;&nbsp; を追加して使用する。Cの構文を拡張するならば:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:w ~/.vim/after/syntax/c.vim</span><br>
<br>
以上。次回Cのファイルを編集する時にはコメントが異なった色で表示される。Vimを再<br>
起動する必要はない。<br>
<br>
構文ファイルが複数になるときは、ファイルタイプの名前のディレクトリに置くとよい。<br>
そのディレクトリの中の全ての &quot;*.vim&quot; ファイルが読み込まれるようになる。例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~/.vim/after/syntax/c/one.vim</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~/.vim/after/syntax/c/two.vim</span><br>
<br>
既存の構文ファイルを置き換える&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#mysyntaxfile-replace" name="mysyntaxfile-replace">*mysyntaxfile-replace*</a><br>
<br>
標準の構文ファイルが気に入らない場合や、新しいバージョンをダウンロードした際に<br>
は、上で述べた<a class="Identifier" href="syntax.html#mysyntaxfile">|mysyntaxfile|</a>に従えば良い。ただ<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>で、前の方に記され<br>
たディレクトリに構文ファイルを置くように気を付ければ良い。Vimは適合する構文ファ<br>
イルのうち最初に見つけた1つだけを読込む。<br>
<br>
<br>
名前付けの慣習&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#group-name" name="group-name">*group-name*</a>&nbsp;<a class="Constant" href="syntax.html#{group-name}" name="{group-name}">*{group-name}*</a>&nbsp;<a class="Constant" href="syntax.html#E669" name="E669">*E669*</a>&nbsp;<a class="Constant" href="syntax.html#W18" name="W18">*W18*</a><br>
<br>
構文グループとは、同じ種類の構文アイテムをグループ化したものである。構文グルー<br>
プから強調グループにリンクされ、強調グループに対して色が設定される。構文グルー<br>
プそれ自体は、色や属性を指定するものではない。<br>
<br>
ハイライトや構文グループの名前はアスキー文字、数字、アンダースコアだけでつけな<br>
ければならない。正規表現では: &quot;[a-zA-Z0-9_]*&quot;<br>
<br>
各ユーザが好みの色セットを使用できるように、多くの言語に共通するハイライトグルー<br>
プには優先名が与えられている。推奨されているグループ名は以下のとおり(構文ハイ<br>
ライトがちゃんと機能していれば、&quot;Ignore&quot;以外はそのグループに設定された色で表示<br>
されるだろう):<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Comment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o コメント</span><br>
<br>
<span class="Constant">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Constant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o 定数</span><br>
<span class="Constant">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o 文字列定数: &quot;これは文字列です&quot;</span><br>
<span class="Constant">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Character&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o 文字定数: 'c', '\n'</span><br>
<span class="Constant">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o 数値定数: 234, 0xff</span><br>
<span class="Constant">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o ブール値の定数: TRUE, false</span><br>
<span class="Constant">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o 不動小数点数の定数: 2.3e10</span><br>
<br>
<span class="Identifier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Identifier&nbsp;&nbsp;&nbsp;&nbsp; o 変数名</span><br>
<span class="Identifier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o 関数名(クラスメソッドを含む)</span><br>
<br>
<span class="Statement">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Statement&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o 命令文</span><br>
<span class="Statement">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Conditional&nbsp;&nbsp;&nbsp;&nbsp;o if, then, else, endif, switch, その他</span><br>
<span class="Statement">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Repeat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o for, do, while, その他</span><br>
<span class="Statement">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o case, default, その他</span><br>
<span class="Statement">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Operator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o &quot;sizeof&quot;, &quot;+&quot;, &quot;*&quot;, その他</span><br>
<span class="Statement">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Keyword&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o その他のキーワード</span><br>
<span class="Statement">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exception&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o try, catch, throw</span><br>
<br>
<span class="PreProc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*PreProc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o 一般的なプリプロセッサ命令</span><br>
<span class="PreProc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Include&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o #include プリプロセッサ</span><br>
<span class="PreProc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o #define プリプロセッサ</span><br>
<span class="PreProc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Macro&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o Defineと同値</span><br>
<span class="PreProc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PreCondit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o プリプロセッサの #if, #else, #endif, その他</span><br>
<br>
<span class="Type">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o int, long, char, その他</span><br>
<span class="Type">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StorageClass&nbsp;&nbsp; o static, register, volatile, その他</span><br>
<span class="Type">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Structure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o struct, union, enum, その他</span><br>
<span class="Type">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Typedef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o typedef宣言</span><br>
<br>
<span class="Special">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Special&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o 特殊なシンボル</span><br>
<span class="Special">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SpecialChar&nbsp;&nbsp;&nbsp;&nbsp;o 特殊な文字定数</span><br>
<span class="Special">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o この上で CTRL-] を使うことができる</span><br>
<span class="Special">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Delimiter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o 注意が必要な文字</span><br>
<span class="Special">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SpecialComment o コメント内の特記事項</span><br>
<span class="Special">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o デバッグ命令</span><br>
<br>
<span class="Underlined">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Underlined&nbsp;&nbsp;&nbsp;&nbsp; o 目立つ文章, HTMLリンク</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Ignore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o (見た目上)空白, 不可視&nbsp;&nbsp;<a class="Identifier" href="syntax.html#hl-Ignore">|hl-Ignore|</a><br>
<br>
<span class="Error">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o エラーなど、なんらかの誤った構造</span><br>
<br>
<span class="Todo">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Todo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o 特別な注意がひつようなもの; 大抵はTODO FIXME XXXなど</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;のキーワード<br>
<br>
マーク(*)されている名前が優先グループ、その他はマイナーグループである。優先グ<br>
ループには、&quot;syntax.vim&quot;によりデフォルトのハイライト手法が定義されている。マイ<br>
ナーグループは優先グループにリンクされ、リンクした先と同じハイライト手法になる。<br>
ファイル&quot;syntax.vim&quot;が読込まれた後でコマンド&quot;:highlight&quot;を使えば、そのデフォル<br>
トを上書することができる。<br>
<br>
ハイライトグループ名には大文字小文字の区別がないことに注意。&quot;String&quot; と<br>
&quot;string&quot;はどちらも同じグループを意味する。<br>
<br>
以下の名前は予約されているのでグループ名として使用することはできない:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NONE&nbsp;&nbsp; ALL&nbsp;&nbsp; ALLBUT&nbsp;&nbsp; contains&nbsp;&nbsp; contained<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Ignore" name="hl-Ignore">*hl-Ignore*</a><br>
Ignore グループを使うときは、conceal 機能も使うと便利かもしれません。<br>
<a class="Identifier" href="syntax.html#conceal">|conceal|</a>&nbsp;参照。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
3. 構文ファイル読込の手順&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#syntax-loading" name="syntax-loading">*syntax-loading*</a><br>
<br>
ここではコマンド&quot;:syntax enable&quot;を実行した時に何が起こるかの詳細を説明する。<br>
Vimは初期化の時に、ランタイムファイルの在り処を自動的に発見する。ここでは変数<br>
<a class="Identifier" href="starting.html#$VIMRUNTIME">|$VIMRUNTIME|</a>にその場所が格納されているとする。<br>
<br>
&quot;:syntax enable&quot; と &quot;:syntax on&quot;では以下のことが起こる:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$VIMRUNTIME/syntax/syntax.vimを読込む<br>
&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;+-&nbsp;&nbsp;$VIMRUNTIME/syntax/nosyntax.vimを読込んで古い構文を削除する<br>
&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;+-&nbsp;&nbsp;<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>からsyntax/synload.vimを読込む<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; +-&nbsp;&nbsp;構文ハイライトの色を設定する。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |&nbsp;&nbsp; カラースキームが定義されている場合は&quot;:colors&nbsp;<span class="Special">{name}</span>&quot;で再度読込む。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |&nbsp;&nbsp; そうでない場合は&quot;:runtime! syntax/syncolor.vim&quot;が使用される。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |&nbsp;&nbsp; &quot;:syntax on&quot;は既存の色設定を上書設定し、&quot;:syntax enable&quot;はまだ設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |&nbsp;&nbsp; されていないグループのみを設定する。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; +-&nbsp;&nbsp;適切な構文ファイルをオプション<a class="Type" href="options.html#'syntax'">'syntax'</a>が設定される時に読込む自動実<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |&nbsp;&nbsp; 行コマンドを設定する。&nbsp;<a class="Constant" href="syntax.html#synload-1" name="synload-1">*synload-1*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; +-&nbsp;&nbsp;ユーザによる追加ファイルを変数<a class="Identifier" href="syntax.html#mysyntaxfile">|mysyntaxfile|</a>から読込む。これは<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vim 5.xとの互換性のためだけに存在する。&nbsp;<a class="Constant" href="syntax.html#synload-2" name="synload-2">*synload-2*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;+-&nbsp;&nbsp;&quot;:filetype on&quot;を実行し&quot;:runtime! filetype.vim&quot;が実行される。これは見つ<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; けることのできる全てのfiletype.vimを読込む。$VIMRUNTIME/filetype.vimは<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; 常に読込まれ、以下のことが実行される。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; +-&nbsp;&nbsp;拡張子に基づいてオプション<a class="Type" href="options.html#'filetype'">'filetype'</a>を設定するオートコマンドをイン<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |&nbsp;&nbsp; ストールする。これにより既知のファイル形式に付いて、ファイル名と<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |&nbsp;&nbsp; 当該形式との関連付けが成される。&nbsp;<a class="Constant" href="syntax.html#synload-3" name="synload-3">*synload-3*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; +-&nbsp;&nbsp;ユーザによる追加ファイルを変数&nbsp;<a class="Constant" href="syntax.html#myfiletypefile" name="myfiletypefile">*myfiletypefile*</a>&nbsp;から読込む。これは<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |&nbsp;&nbsp; Vim 5.xとの互換性のためだけに存在する。&nbsp;<a class="Constant" href="syntax.html#synload-4" name="synload-4">*synload-4*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; +-&nbsp;&nbsp;ファイル形式が検出されなかった時にscripts.vimを読込むための自動実<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |&nbsp;&nbsp; 行コマンドをインストールする。&nbsp;<a class="Constant" href="syntax.html#synload-5" name="synload-5">*synload-5*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; +-&nbsp;&nbsp;構文メニュー設定のため$VIMRUNTIME/menu.vimを読込む。&nbsp;<a class="Identifier" href="gui.html#menu.vim">|menu.vim|</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;+-&nbsp;&nbsp;ファイル形式が検出された時にオプション<a class="Type" href="options.html#'syntax'">'syntax'</a>を設定するためのFileType<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; オートコマンドを設定する。&nbsp;<a class="Constant" href="syntax.html#synload-6" name="synload-6">*synload-6*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;+-&nbsp;&nbsp;既に読込まれているバッファに対して構文ハイライトを行なうために、関連し<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;たオートコマンドを実行する。<br>
<br>
<br>
ファイルを読込む時には、Vimは以下のように関連した構文ファイルを見つける:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;ファイルを読込むとBufReadPostオートコマンドが起動する。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;+-&nbsp;&nbsp;<a class="Identifier" href="syntax.html#synload-3">|synload-3|</a>(既知ファイル形式)か<a class="Identifier" href="syntax.html#synload-4">|synload-4|</a>(ユーザ定義ファイル形式)の自<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; 動実行コマンドがヒットした場合、オプション<a class="Type" href="options.html#'filetype'">'filetype'</a>にそのファイル形式<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; 名が設定される。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;+-&nbsp;&nbsp;<a class="Identifier" href="syntax.html#synload-5">|synload-5|</a>のオートコマンドが実行される。まだファイル形式が決定され<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ていない場合は、<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>からscripts.vimが検索される。これは常に以<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; 下のことを行なう$VIMRUNTIME/scripts.vimを読込む。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; +-&nbsp;&nbsp;ユーザによる追加ファイルを変数&nbsp;<a class="Constant" href="syntax.html#myscriptsfile" name="myscriptsfile">*myscriptsfile*</a>&nbsp;から読込む。これは<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |&nbsp;&nbsp; Vim 5.xとの互換性のためだけに存在する。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; +-&nbsp;&nbsp;未だにファイル形式が決定できない場合、ファイルの内容を検査する。検<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 査は&quot;getline(1) =~ pattern&quot;のように認識できるファイル形式かどうか<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 行なわれ、認識できるならば<a class="Type" href="options.html#'filetype'">'filetype'</a>を設定する。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;+-&nbsp;&nbsp;ファイル形式が決定されて<a class="Type" href="options.html#'filetype'">'filetype'</a>が設定された時に、上記<a class="Identifier" href="syntax.html#synload-6">|synload-6|</a>の<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; FileTypeオートコマンドが実行される。決定したファイル形式名がそれによ<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; り<a class="Type" href="options.html#'syntax'">'syntax'</a>へ設定される。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;+-&nbsp;&nbsp;上記でオプション<a class="Type" href="options.html#'syntax'">'syntax'</a>が設定されると、<a class="Identifier" href="syntax.html#synload-1">|synload-1|</a>(と<a class="Identifier" href="syntax.html#synload-2">|synload-2|</a>)の自<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; 動実行コマンドが実行される。これにより次のコマンドでメインとなる構文<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; ファイルが<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>から読込まれる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runtime! syntax/<span class="Special">&lt;name&gt;</span>.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;+-&nbsp;&nbsp;ユーザがインストールしたその他のFileTypeおよびSyntaxオートコマンドが<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;実行される。これは特定の構文のハイライトを変更するのに使うことができる。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
4. 構文ファイルの覚書&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-file-remarks" name=":syn-file-remarks">*:syn-file-remarks*</a><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#b:current_syntax-variable" name="b:current_syntax-variable">*b:current_syntax-variable*</a><br>
Vimはロードした構文の名前を変数&quot;b:current_syntax&quot;に記憶している。ある構文が有<br>
効な場合だけある設定を行うにはこの変数が利用できる。例:<br>
<span class="Comment">&nbsp;&nbsp; :au BufReadPost * if b:current_syntax == &quot;csh&quot;</span><br>
<span class="Comment">&nbsp;&nbsp; :au BufReadPost *&nbsp;&nbsp; do-some-things</span><br>
<span class="Comment">&nbsp;&nbsp; :au BufReadPost * endif</span><br>
<br>
<br>
2HTML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#2html.vim" name="2html.vim">*2html.vim*</a>&nbsp;<a class="Constant" href="syntax.html#convert-to-HTML" name="convert-to-HTML">*convert-to-HTML*</a><br>
<br>
これは構文ファイルではなくて、現在のウィンドウの内容をHTMLに変換するスクリプト<br>
である。Vimは新しいウィンドウを作成しそこにHTMLファイルを構築する。<br>
<br>
使う際にはオプション<a class="Type" href="options.html#'filetype'">'filetype'</a>や<a class="Type" href="options.html#'syntax'">'syntax'</a>に&quot;2html&quot;を設定してはならない!<br>
現在のファイルをコンバートするためにはこのスクリプトを読込む:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:runtime! syntax/2html.vim</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:TOhtml" name=":TOhtml">*:TOhtml*</a><br>
またはユーザコマンド&quot;:TOhtml&quot;を使ってもよい。これは標準プラグイン中で定義され<br>
ている。&quot;:TOhtml&quot;は範囲指定やビジュアルモードにも対応している:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:10,40TOhtml</span><br>
<br>
警告: 遅いかも!&nbsp;&nbsp;スクリプトはすべての行のすべての文字を処理しなければなりませ<br>
ん。処理に時間が掛かるので、初期設定では、処理経過を表示するためのプログレス<br>
バーがステータスラインに表示されます。プログレスバーを非表示にしたい場合は次の<br>
コマンドでそれを無効化できます。ほんの少しだけ早くなります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:html_no_progress = 1</span><br>
<br>
&quot;:TOhtml&quot; には diff モード用の特別な機能があり、すべての関連するウィンドウの内<br>
容が HTML として生成されます。これは g:html_diff_one_file を設定することで無効<br>
化できます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:html_diff_one_file = 1</span><br>
<br>
出力結果をファイルに保存すれば、好きなブラウザでそれを観ることができる。Vimで<br>
表示されるのと寸分たがわぬ色が再現される。<br>
<br>
変換の範囲を指定するには、<a class="Identifier" href="syntax.html#:TOhtml">|:TOhtml|</a>&nbsp;コマンドに範囲を指定するか、<br>
&quot;g:html_start_line&quot; と &quot;g:html_end_line&quot; に変換したい範囲の最初と最後の行を設<br>
定します。例えば、最後に選択された範囲だけを変換するには:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:html_start_line = line(&quot;'&lt;&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:html_end_line = line(&quot;'&gt;&quot;)</span><br>
<br>
オプション<a class="Type" href="options.html#'number'">'number'</a>が設定されている場合には、各行にNumberでハイライトされた行番<br>
号が付加される。&quot;html_number_lines&quot;に非0の値を設定すれば、HTMLの出力へ強制的に<br>
行番号を付加することができる:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_number_lines = 1</span><br>
この変数に0を設定すれば行番号を強制的に省略できる:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_number_lines = 0</span><br>
この変数を削除すれば元通り<a class="Type" href="options.html#'number'">'number'</a>に従うように戻すことができる:<br>
<span class="Comment">&nbsp;&nbsp; :unlet g:html_number_lines</span><br>
<br>
デフォルトでは、カスケーディングスタイルシート (CSS1) を使用した正当 (valid)<br>
な HTML 4.01 の HTML が生成されます。古いブラウザや、CSS をサポートしていない<br>
他のユーザーエージェント向けに HTML を生成したい場合は次のように設定してくださ<br>
い:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_use_css = 0</span><br>
<br>
Conceal されたテキストは HTML には表示されず、<a class="Type" href="options.html#'conceallevel'">'conceallevel'</a>&nbsp;の現在の設定に応<br>
じて&nbsp;<a class="Identifier" href="syntax.html#:syn-cchar">|:syn-cchar|</a>&nbsp;や&nbsp;<a class="Type" href="options.html#'listchars'">'listchars'</a>&nbsp;の文字が代わりに表示されます。すべてのテキス<br>
トを表示したい場合は 2html を呼ぶ前に&nbsp;<a class="Type" href="options.html#'conceallevel'">'conceallevel'</a>&nbsp;をゼロに設定するか、次の<br>
変数を設定してください:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_ignore_conceal = 1</span><br>
<br>
同様に、閉じた折り畳みは、画面表示通りに HTML に出力される。これが好ましくない<br>
なら、2html を呼ぶ前にコマンド&nbsp;<a class="Identifier" href="fold.html#zR">|zR|</a>&nbsp;を使うか、または次のようにする:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_ignore_folding = 1</span><br>
<br>
ブラウザ上でも Vim と同じように折り畳みの開閉を行えるようにしたいことがある<br>
だろう。そんなときは次の設定をすると、動的な折り畳みの HTML が生成される:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_dynamic_folds = 1</span><br>
<br>
html_dynamic_folds を使うと、html_use_css も自動的にセットされる。古いブラウ<br>
ザで動的な折り畳みを実現するのは非常に難しいからである。html_ignore_folding<br>
を設定していると html_dynamic_folds はオフになる。<br>
<br>
html_dynamic_folds を使うと、HTML でも Vim と同じような折畳表示カラム<br>
(foldcolumn) が表示される。これをクリックすると JavaScript によって折り畳み<br>
が開閉される。この折畳表示カラムの幅は&nbsp;<a class="Identifier" href="options.html#'foldcolumn'">|'foldcolumn'|</a>&nbsp;の設定値から始まり、文<br>
書の最大の折り畳みレベルまで増えていく。折畳表示カラムをまったく表示させない<br>
ようにするには次のようにする:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_no_foldcolumn = 1</span><br>
<br>
このオプションをセットすると、HTML の中で折り畳みを開くための折畳表示カラム<br>
がすべてなくなってしまう。そこで、html_hover_unfold というオプションが用意さ<br>
れている。このオプションをセットすると、CSS 2.0 を使い、折り畳みの上にマウス<br>
を持っていくだけで折り畳みを開くことができるようになる。古いブラウザ(特に<br>
Internet Explorer 6)はこの機能に対応していないことに注意。IE6 でも表示できる<br>
ように CSS1 を使った専用のマークアップが入っているが、IE6 では折畳を開くこと<br>
はできない。html_hover_unfold を有効にしているとき、新しいブラウザなら<br>
JavaScript を無効にしていても閉じた折畳の中を見られることに注意。このオプショ<br>
ンを有効にするには次のようにする:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_hover_unfold = 1</span><br>
<br>
html_no_foldcolumn と html_dynamic_folds をセットすると、自動的に<br>
html_hover_unfold もセットされる。そうしないと折畳が閉じたままになってしまう<br>
からである。<br>
<br>
デフォルトでは、テキストの周りに&quot;<span class="Special">&lt;pre&gt;</span>&quot;と&quot;&lt;/pre&gt;&quot;がつけられる。変換されるウィ<br>
ンドウの&nbsp;<a class="Type" href="options.html#'wrap'">'wrap'</a>&nbsp;がオンになっている場合、テキストを折り返し表示するために CSS<br>
2.0 の &quot;white-space:pre-wrap&quot; が使われる。折り返しを明示的に有効化するには次の<br>
ように設定する:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_pre_wrap = 1</span><br>
無効化するには次のように設定する:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_pre_wrap = 0</span><br>
生成される HTML は Vim ウィンドウでの表示に近いものになるが、<a class="Type" href="options.html#'showbreak'">'showbreak'</a>&nbsp;やラ<br>
インブレイクなどは HTML には反映されない。<br>
<br>
HTML で折り返しを有効にするもう一つ方法がある。ただし表示がさらに違うものに<br>
なってしまうかもしれない。次のように設定する:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_no_pre = 1</span><br>
こうすると、各行末に<span class="Special">&lt;br&gt;</span>を使い、連続するスペースに&quot;&amp;nbsp;&quot;を使うようになる。こ<br>
の方法は古いブラウザとの互換性が高い。しかし最近のブラウザは &quot;white-space&quot; を<br>
サポートしている。<br>
<br>
&quot;<span class="Special">&lt;pre&gt;</span>&quot; タグを使う場合、テキスト中の&nbsp;<span class="Special">&lt;Tab&gt;</span>&nbsp;文字は、それがテキストの見た目に影<br>
響せず、ドキュメントの中で故意に使用されているようなら、そのまま出力に含まれま<br>
す。その場合、HTML 出力をブラウザで表示してそれをコピー&amp;ペーストしたときに、元<br>
のドキュメントの実際の空白文字をそのままコピーできます。<br>
<br>
具体的に言うと、<span class="Special">&lt;Tab&gt;</span>&nbsp;文字が含まれるのは、<a class="Type" href="options.html#'tabstop'">'tabstop'</a>&nbsp;オプションが初期設定の 8<br>
に設定されていて、<a class="Type" href="options.html#'expandtab'">'expandtab'</a>&nbsp;がオフになっていて、foldcolumn も 行番号も HTML<br>
出力に含まれないときです (上述のオプション参照)。これらの条件に満たないとき<br>
は、<span class="Special">&lt;Tab&gt;</span>&nbsp;文字は適切な数のスペースに展開されます。<br>
<br>
&quot;<span class="Special">&lt;pre&gt;</span>&quot; が含まれるとき、他の条件に関わらずタブ文字をそのままにしたい場合は次の<br>
ように設定します:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_expand_tabs = 0</span><br>
<span class="Todo">Note</span>: おそらく HTML 内のテキストのインデントや整列が崩れます。<br>
<br>
強制的にタブ文字を展開したい場合は次のように設定します:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_expand_tabs = 1</span><br>
<br>
シングルファイルの diff モード (g:html_diff_one_file 設定) では、4 行以上の詰<br>
め行 (訳注:他方のファイルに行が挿入されていることを示す行) は 3 行で表示され、<br>
何行挿入されているかが真ん中の行に表示されます。横並び表示の diff のように挿入<br>
された行をすべて表示したい場合は次のように設定します:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:let g:html_whole_filler = 1</span><br>
3 行で表示するように戻すには次のように設定します:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:unlet g:html_whole_filler</span><br>
<br>
ほとんどのバッファでは、TOhtml は&nbsp;<a class="Type" href="options.html#'fileencoding'">'fileencoding'</a>&nbsp;が設定されていればその値を、<br>
設定されていなければ&nbsp;<a class="Type" href="options.html#'encoding'">'encoding'</a>&nbsp;の値を使い、HTML ファイルの文字セットと<br>
<a class="Type" href="options.html#'fileencoding'">'fileencoding'</a>&nbsp;を決定します。特定の&nbsp;<a class="Type" href="options.html#'buftype'">'buftype'</a>&nbsp;では常に&nbsp;<a class="Type" href="options.html#'encoding'">'encoding'</a>&nbsp;が使われま<br>
す。<a class="Identifier" href="mbyte.html#encoding-names">|encoding-names|</a>&nbsp;の説明で名前が出てくるようなエンコーディングであればたい<br>
ていは機能しますが、TOhtml で自動的に使用されるのは広くサポートされているエン<br>
コーディングだけです。特定のエンコーディングが初期設定で自動的に認識されない場<br>
合には自分でそれを指定することができます。<br>
<br>
自動的な文字セットの認識を停止するには、g:html_use_encoding に使用したい文字<br>
セットの名前を設定します。TOhtml は文字セットを見て適当な&nbsp;<a class="Type" href="options.html#'fileencoding'">'fileencoding'</a>&nbsp;を設<br>
定しますが、TOhtml がエンコーディングを決定できなかった場合は自分で設定する必<br>
要があります。ウェブサーバーに上げるような場合には、UTF-8 のような広くサポート<br>
されている文字セットを設定することが推奨されます:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_use_encoding = &quot;UTF-8&quot;</span><br>
文字セット指定の行を含めたくない場合は g:html_use_encoding に空文字を設定して<br>
ください:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_use_encoding = &quot;&quot;</span><br>
自動的に判断する設定に戻すには変数 g:html_use_encoding を削除します:<br>
<span class="Comment">&nbsp;&nbsp; :unlet g:html_use_encoding</span><br>
<br>
g:html_use_encoding を設定したときに TOhtml によって適切な&nbsp;<a class="Type" href="options.html#'fileencoding'">'fileencoding'</a>&nbsp;が自<br>
動的に設定されない場合は、g:html_encoding_override を使うことで正しいエンコー<br>
ディングが選択されるように設定できます。<br>
これは文字セット-エンコーディング組の辞書で、TOhtml が使用する組を置き換えたり<br>
追加したりできます。例えば HTML 文字セットの &quot;windows-1252&quot; を &quot;8bit-cp1252&quot;<br>
エンコーディングに対応させるには次のように設定します:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_encoding_override = {'windows-1252': '8bit-cp1252'}</span><br>
<br>
g:html_charset_override も同様です。これは TOhtml が&nbsp;<a class="Type" href="options.html#'fileencoding'">'fileencoding'</a>&nbsp;や<br>
<a class="Type" href="options.html#'encoding'">'encoding'</a>&nbsp;から HTML 文字セットを自動的に決定できない場合に、それをできるよう<br>
にします。既定のエンコーディング-文字セット組を上書きすることもできます。例え<br>
ば、初期設定ではすべての Unicode/UCS エンコーディングに対しては UTF-8 が使用さ<br>
れますが、代わりに UTF-16 や UTF-32 を使うにするには次のように設定します:<br>
<span class="Comment">&nbsp;&nbsp; :let g:html_charset_override = {'ucs-4': 'UTF-32', 'utf-16': 'UTF-16'}</span><br>
<br>
<span class="Todo">Note</span>: UTF-32 か UTF-16 でエンコードされたドキュメントは少なくとも一つのメ<br>
ジャーブラウザで互換性の問題があることが知られています。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#convert-to-XML" name="convert-to-XML">*convert-to-XML*</a>&nbsp;<a class="Constant" href="syntax.html#convert-to-XHTML" name="convert-to-XHTML">*convert-to-XHTML*</a><br>
プレーン HTML が好みでない場合は代わりに XHTML (XML 準拠の HTML) を生成するこ<br>
ともできます。&quot;html_use_xhtml&quot; 変数を設定してください:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:let g:html_use_xhtml = 1</span><br>
<br>
上述の on/off オプションは明示的に希望の値を設定することで有効化または無効化で<br>
きます。<a class="Identifier" href="eval.html#:unlet">|:unlet|</a>&nbsp;を使って変数を削除することで初期設定に戻すことができます。<br>
<br>
覚書き:<br>
- いくつかの本当に古いブラウザでは背景色が表示されないことがある。<br>
- 大半のブラウザでは(なんとカラーで)印刷することができる!<br>
- このバージョンの TOhtml はおそらく古い Vim でも動作しますが、例えば conceal<br>
&nbsp;&nbsp;サポートのようないくつかの機能は動作しません。また、GUI サポート無しでコンパ<br>
&nbsp;&nbsp;イルされた古い Vim では色がおかしくなるかもしれません。<br>
<br>
ここではUNIXのシェル上で全ての.cと.hをコンバートする方法を例として示す:<br>
<span class="Comment">&nbsp;&nbsp; for f in *.[ch]; do gvim -f +&quot;syn on&quot; +&quot;run! syntax/2html.vim&quot; +&quot;wq&quot; +&quot;q&quot; $f; done</span><br>
<br>
<br>
<span class="Statement">ABEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#abel.vim" name="abel.vim">*abel.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-abel-syntax" name="ft-abel-syntax">*ft-abel-syntax*</a><br>
<br>
ABELのハイライトにはユーザが定義できるオプションが幾つかある。それらを有効化す<br>
るにはそれぞれの変数に何か値を設定すれば良い。例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let abel_obsolete_ok=1</span><br>
無効化するには&quot;:unlet&quot;を使用する。例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unlet abel_obsolete_ok</span><br>
<br>
<span class="PreProc">変数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ハイライト</span><br>
abel_obsolete_ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;古いキーワードをエラーでなく命令文として扱う<br>
abel_cpp_comments_illegal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '//'をインラインコメントリーダとして扱わない<br>
<br>
<br>
ADA<br>
<br>
<a class="Identifier" href="ft_ada.html#ft-ada-syntax">|ft-ada-syntax|</a>を参照。<br>
<br>
<br>
<span class="Statement">ANT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#ant.vim" name="ant.vim">*ant.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-ant-syntax" name="ft-ant-syntax">*ft-ant-syntax*</a><br>
<br>
ANTの構文ファイルにはデフォルトでJavaScriptとPythonの構文ハイライトが含まれて<br>
いる。関数AntSyntaxScript()の第1引数にタグ名を、第2引数にファイル名を指定する<br>
ことでその他のスクリプト言語用構文ハイライトをインストールすることができる。<br>
例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:call AntSyntaxScript('perl', 'perl.vim')</span><br>
<br>
これは次のようなANTのコードにPerlの構文ハイライトをインストールするものである<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script language = 'perl'&gt;&lt;![CDATA[</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# everything inside is highlighted as perl</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]]&gt;&lt;/script&gt;</span><br>
<br>
スクリプト言語を永続的にインストールするには<a class="Identifier" href="syntax.html#mysyntaxfile-add">|mysyntaxfile-add|</a>を参照。<br>
<br>
<br>
<span class="Statement">APACHE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#apache.vim" name="apache.vim">*apache.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-apache-syntax" name="ft-apache-syntax">*ft-apache-syntax*</a><br>
<br>
apacheの構文ファイルはApache HTTPサーバのバージョンに基づいた構文ハイライトを<br>
提供する(デフォルトでは1.3.x)。他のバージョン用の構文ハイライトを利用するには<br>
&quot;apache_version&quot;にApacheのバージョンを文字列としてセットする。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let apache_version = &quot;2.0&quot;</span><br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#asm.vim" name="asm.vim">*asm.vim*</a>&nbsp;<a class="Constant" href="syntax.html#asmh8300.vim" name="asmh8300.vim">*asmh8300.vim*</a>&nbsp;<a class="Constant" href="syntax.html#nasm.vim" name="nasm.vim">*nasm.vim*</a>&nbsp;<a class="Constant" href="syntax.html#masm.vim" name="masm.vim">*masm.vim*</a>&nbsp;<a class="Constant" href="syntax.html#asm68k" name="asm68k">*asm68k*</a><br>
アセンブリ言語&nbsp;&nbsp;<a class="Constant" href="syntax.html#ft-asm-syntax" name="ft-asm-syntax">*ft-asm-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#ft-asmh8300-syntax" name="ft-asmh8300-syntax">*ft-asmh8300-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#ft-nasm-syntax" name="ft-nasm-syntax">*ft-nasm-syntax*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#ft-masm-syntax" name="ft-masm-syntax">*ft-masm-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#ft-asm68k-syntax" name="ft-asm68k-syntax">*ft-asm68k-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#fasm.vim" name="fasm.vim">*fasm.vim*</a><br>
<br>
&quot;*.i&quot;にマッチする名前のファイルのタイプはProgressかアセンブリである。自動検出<br>
が動作しない場合や、Progressを編集しないことが判っている場合には、起動設定ファ<br>
イルvimrcに次のコマンドを書くことができる:<br>
<span class="Comment">&nbsp;&nbsp; :let filetype_i = &quot;asm&quot;</span><br>
&quot;asm&quot;には使用するアセンブリ言語の種類を指定する。<br>
<br>
同じ拡張子を使用しているアセンブリ言語はたくさんある。そのため、ユーザは自分<br>
が使っている種類を選択するか、もしくはアセンブリファイルそのものにVimがそれ<br>
と判断できるような行を追加しなければならない。現在は以下の構文ファイルが利用<br>
可能:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GNUアセンブラ(デフォルト)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asm68k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;モトローラ680x0アセンブラ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asmh8300&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日立H-8300用GNUアセンブラ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ia64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;インテルItanium 64<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fasm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flat アセンブラ (<span class="Constant"><a href="http://flatassembler.net">http://flatassembler.net</a></span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;masm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マイクロソフトアセンブラ(たぶん80x86汎用)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nasm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ネットワイドアセンブラ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tasm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ターボアセンブラ(80x86,Pentium,MMXの命令コードを含む)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PICアセンブラ(現在はPIC16F84用)<br>
<br>
アセンブリファイルに次のような行を書き加えるのが一番柔軟である:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asmsyntax=nasm</span><br>
ここで、&quot;nasm&quot; は実際に使用するアセンブリ構文の名前に置き換えること。この記<br>
述はファイルの先頭 5 行以内に書いてなければならない。この文字列の前後に非空<br>
白文字があってはならない。<br>
<br>
構文の種類はバッファ変数b:asmsyntaxを設定することで常にそちらが優先される:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let b:asmsyntax = &quot;nasm&quot;</span><br>
<br>
自動にしろ手動にしろb:asmsyntaxが設定されていないときには、グローバル変数<br>
asmsyntaxが使用される。これによりデフォルトのアセンブリ言語を設定することがで<br>
きる:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let asmsyntax = &quot;nasm&quot;</span><br>
<br>
最後の手段として、何も設定されていない場合には、&quot;asm&quot;構文が使用される。<br>
<br>
<br>
<span class="PreProc">ネットワイドアセンブラ(nasm.vim)の補助ハイライト</span><br>
<br>
機能を有効化するには:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let&nbsp;&nbsp; {variable}=1|set syntax=nasm</span><br>
無効化するには:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unlet {variable}&nbsp;&nbsp;|set syntax=nasm</span><br>
<br>
<span class="PreProc">変数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ハイライト内容</span><br>
nasm_loose_syntax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 非オフィシャルな拡張構文をエラーとしない<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(パーザ依存; 非推奨)<br>
nasm_ctx_outside_macro&nbsp;&nbsp;マクロ外のコンテキストをエラーとしない<br>
nasm_no_warn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;潜在的に危険な構文をToDoとしてハイライトしない<br>
<br>
<br>
ASPPERL and ASPVBS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#ft-aspperl-syntax" name="ft-aspperl-syntax">*ft-aspperl-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#ft-aspvbs-syntax" name="ft-aspvbs-syntax">*ft-aspvbs-syntax*</a><br>
<br>
*.aspと*.aspという名のファイルはどちらもPerlもしくはVisual Basicのスクリプトた<br>
りえる。Vimにとってこれを判別するのは難しいので、グローバル変数を設定すること<br>
でどちらを使用するのか宣言することができる。どちらでもPerlスクリプトを使用する<br>
なら:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:filetype_asa = &quot;aspperl&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:filetype_asp = &quot;aspperl&quot;</span><br>
Visual Basicを使用するなら次のように設定する:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:filetype_asa = &quot;aspvbs&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:filetype_asp = &quot;aspvbs&quot;</span><br>
<br>
<br>
<span class="Statement">BAAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#baan.vim" name="baan.vim">*baan.vim*</a>&nbsp;<a class="Constant" href="syntax.html#baan-syntax" name="baan-syntax">*baan-syntax*</a><br>
<br>
baan.vim は リリース BaanIV から SSA ERP LN まで、3 GL と 4 GL プログラミング<br>
両方に対応した構文を定義している。たくさんの標準的な定義/定数がサポートされて<br>
いる。<br>
<br>
次を&nbsp;<a class="Identifier" href="starting.html#.vimrc">|.vimrc|</a>&nbsp;に書いておくと、ある種のコーディング標準違反を教えてくれる:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let baan_code_stds=1</span><br>
<br>
<a class="Constant" href="syntax.html#baan-folding" name="baan-folding">*baan-folding*</a><br>
<br>
以下の変数によって、様々なレベルで構文折り畳みを有効にできる (これらはユーザの<br>
<a class="Identifier" href="starting.html#.vimrc">|.vimrc|</a>&nbsp;で設定すること)。ソースブロックと SQL についてより複雑な折り畳みを行<br>
うと CPU に負荷がかかる。<br>
<br>
折り畳みを有効にし、関数レベルで折り畳みをするにはこうする:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let baan_fold=1</span><br>
次の設定を行うと、if, while, for ... のようなソースブロックレベルの折り畳みが<br>
有効になる。キーワード begin/end の前のインデントが等しくなければならない (ス<br>
ペースとタブは異なるとみなされる)。<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let baan_fold_block=1</span><br>
次を設定すると SELECT, SELECTDO, SELECTEMPTY ... のような埋め込み SQL ブロック<br>
の折り畳みが有効になる。キーワード begin/end の前のインデントが等しくなければ<br>
ならない (スペースとタブは異なるとみなされる)。<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let baan_fold_sql=1</span><br>
<span class="Todo">Note</span>: ブロック折り畳みを有効にすると、小さな折り畳みがたくさんできるかもしれな<br>
い。<a class="Identifier" href="starting.html#.vimrc">|.vimrc|</a>&nbsp;でオプション&nbsp;<a class="Type" href="options.html#'foldminlines'">'foldminlines'</a>&nbsp;と&nbsp;<a class="Type" href="options.html#'foldnestmax'">'foldnestmax'</a>&nbsp;を&nbsp;<a class="Identifier" href="options.html#:set">|:set|</a>&nbsp;するか、...<br>
/after/syntax/baan.vim 内で&nbsp;<a class="Identifier" href="options.html#:setlocal">|:setlocal|</a>&nbsp;をする (<a class="Identifier" href="options.html#after-directory">|after-directory|</a>&nbsp;を参照) とよ<br>
いかもしれない。例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set foldminlines=5</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set foldnestmax=6</span><br>
<br>
<br>
<span class="Statement">BASIC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#basic.vim" name="basic.vim">*basic.vim*</a>&nbsp;<a class="Constant" href="syntax.html#vb.vim" name="vb.vim">*vb.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-basic-syntax" name="ft-basic-syntax">*ft-basic-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#ft-vb-syntax" name="ft-vb-syntax">*ft-vb-syntax*</a><br>
<br>
Visual Basicも「通常の」BASICも、どちらも拡張子には&quot;.bas&quot;が使用される。どちら<br>
が使用されているか判別するのに、Vimはファイルの先頭5行以内に&quot;VB_Name&quot;という文<br>
字列が存在するかどうかを検査する。存在しなければ、ファイル形式は&quot;basic&quot;とな<br>
り、そうでなければ&quot;vb&quot;となる。拡張子が&quot;.frm&quot;のファイルは常にVisual Basicとして<br>
扱われる。<br>
<br>
<br>
<span class="Statement">C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#c.vim" name="c.vim">*c.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-c-syntax" name="ft-c-syntax">*ft-c-syntax*</a><br>
<br>
Cには幾つかの補助的なハイライト方法がある。それらを有効化するには対応した変数<br>
に値を設定する。例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let c_comment_strings = 1</span><br>
これを無効化するには&quot;:unlet&quot;を使う。例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unlet c_comment_strings</span><br>
<br>
<span class="PreProc">変数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ハイライト内容</span><br>
c_gnu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GNU gcc固有の要素<br>
c_comment_strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; コメント内の文字列と数値<br>
c_space_errors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行末の空白文字とタブ文字前のスペース文字<br>
c_no_trail_space_error&nbsp;&nbsp; ... 但し行末の空白文字は除外<br>
c_no_tab_space_error&nbsp;&nbsp;&nbsp;&nbsp; ... 但しタブ文字前のスペース文字は除外<br>
c_no_bracket_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[]の中の{}をエラーとして表示しない<br>
c_no_curly_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ と } が第1桁にあるときを除き、[] と () の内側の {}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;をエラーとして表示しない。<br>
c_curly_error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 対応する { がない } をハイライトする。これを有効に<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;すると、ファイルの先頭から同期が始まるため、遅くなる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start of the file, can be slow<br>
c_no_ansi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ANSI標準の型と定数をハイライトしない<br>
c_ansi_typedefs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... 但し標準ANSI型はハイライトする<br>
c_ansi_constants&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... 但し標準ANSI定数はハイライトする<br>
c_no_utf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字列中の\uと\Uをハイライトしない<br>
c_syntax_for_h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイル*.hにC++ではなくCの構文を適用する<br>
c_no_if0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;#if 0&quot;のブロックをコメントとしてハイライトしない<br>
c_no_cformat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字列中の&quot;%&quot;によるフォーマットをハイライトしない<br>
c_no_c99&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C99の標準アイテムをハイライトしない<br>
c_no_c11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c11の標準アイテムをハイライトしない<br>
<br>
<a class="Type" href="options.html#'foldmethod'">'foldmethod'</a>&nbsp;が &quot;syntax&quot; に設定されていると、/* */ のコメントと { } のブロック<br>
が折り畳まれる。コメントを折り畳みたくなければこのようにする:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let c_no_comment_fold = 1</span><br>
&quot;#if 0&quot; のブロックも同様に折り畳まれる。折り畳みたくなければこのようにする:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let c_no_if0_fold = 1</span><br>
<br>
上方向にスクロールしているときにハイライト表示がおかしくなり、それが<span class="Special">&lt;CTRL-L&gt;</span>で<br>
再描画すると直るようなら、内部変数&quot;c_minlines&quot;にもっと大きな値を設定すれば解決<br>
できるかもしれない:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let c_minlines = 100</span><br>
これにより構文判定のシンクロナイズ位置が表示開始行の100行手前に設定される。初<br>
期設定の値は50行(c_no_if0を使用した場合は15行)である。ただしこれには、大きな値<br>
を設定すると再描画が遅くなるという短所がある。<br>
<br>
&quot;#if 0&quot; / &quot;#endif&quot;のブロックをコメントとしてハイライトしている場合には、<br>
&quot;#if 0&quot;がウィンドウのトップから&quot;c_minlines&quot;以内にある時にしか正しく動作しない<br>
ことに注意する。長い&quot;#if 0&quot;のブロックを使用した場合には、それは正しくハイライ<br>
トされない。<br>
<br>
コメント内で追加要素にマッチを行なうには、クラスタcCommentGroupを使用する。<br>
例:<br>
<span class="Comment">&nbsp;&nbsp; :au Syntax c call MyCadd()</span><br>
<span class="Comment">&nbsp;&nbsp; :function MyCadd()</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;syn keyword cMyItem contained Ni</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;syn cluster cCommentGroup add=cMyItem</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;hi link cMyItem Title</span><br>
<span class="Comment">&nbsp;&nbsp; :endfun</span><br>
<br>
ANSIの定数はグループ&quot;cConstant&quot;でハイライトされる。これには&quot;NULL&quot;, &quot;SIG_IGN&quot;や<br>
その他のものが含まれる。しかしANSI標準でないもの、例えば&quot;TRUE&quot;は含まれない。も<br>
しもこれが紛らわしいならば、cConstant用のハイライトを削除する:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:hi link cConstant NONE</span><br>
<br>
文法上エラーではないはずの'{'と'}'がエラーとしてハイライトされてしまう場合には、<br>
cErrInParen及びcErrInBracketのハイライトをリセットする。<br>
<br>
Cファイルで折り畳みをするには、以下の行を<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>中の&quot;after&quot;ディレクトリ<br>
内のファイルに加えるとよい。Unixなら~/.vim/after/syntax/c.vimに加えるとよいだ<br>
ろう:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;syn sync fromstart</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;set foldmethod=syntax</span><br>
<br>
<span class="Statement">CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#ch.vim" name="ch.vim">*ch.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-ch-syntax" name="ft-ch-syntax">*ft-ch-syntax*</a><br>
<br>
C/C++ インタープリタ。Ch は C に似た構文ハイライトを持ち、C の構文ファイルに基<br>
づいている。C で利用できる設定については&nbsp;<a class="Identifier" href="syntax.html#c.vim">|c.vim|</a>&nbsp;を参照。<br>
<br>
変数を設定すれば、*.h ファイルに対して C, C++ でなく Ch の構文を使うようにする<br>
ことができる:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let ch_syntax_for_h = 1</span><br>
<br>
<br>
<span class="Statement">CHILL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#chill.vim" name="chill.vim">*chill.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-chill-syntax" name="ft-chill-syntax">*ft-chill-syntax*</a><br>
<br>
Chillの構文ハイライトはCに似ている。設定に関しては<a class="Identifier" href="syntax.html#c.vim">|c.vim|</a>を参照。それに加えて<br>
次のものがある:<br>
<br>
chill_space_errors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c_space_errors と同様<br>
chill_comment_string&nbsp;&nbsp;&nbsp;&nbsp;c_comment_strings と同様<br>
chill_minlines&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c_minlines と同様<br>
<br>
<br>
<span class="Statement">CHANGELOG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#changelog.vim" name="changelog.vim">*changelog.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-changelog-syntax" name="ft-changelog-syntax">*ft-changelog-syntax*</a><br>
<br>
ChangeLogでは行頭のスペースのハイライトできる。これをオフにしたいなら、次の行を<br>
.vimrcに加える:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:changelog_spacing_errors = 0</span><br>
これは次にchangelogファイルを編集するときから有効になる。バッファごとに設定す<br>
るには&quot;b:changelog_spacing_errors&quot;を使う(構文ファイルを読み込む前に設定するこ<br>
と)。<br>
<br>
例えばスペースをエラーとするかどうかなどのハイライト方法を変えることができる:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:hi link ChangelogError Error</span><br>
ハイライトをやめるには:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:hi link ChangelogError NONE</span><br>
これは即座に有効になる。<br>
<br>
<br>
<span class="Statement">COBOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#cobol.vim" name="cobol.vim">*cobol.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-cobol-syntax" name="ft-cobol-syntax">*ft-cobol-syntax*</a><br>
<br>
既存のCOBOLコードに要求されるハイライト方法と、新規に開発されるコードに要求さ<br>
れるそれには違いがある。この違いはコードのおかれている状況(保守 vs 開発)やその<br>
他の要素によって決定する。既存コードのハイライトを行なうには.vimrcに次の行を加<br>
える:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let cobol_legacy_code=1</span><br>
これを再び無効にするには次のようにする:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unlet cobol_legacy_code</span><br>
<br>
<br>
<span class="Statement">COLD FUSION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#coldfusion.vim" name="coldfusion.vim">*coldfusion.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-coldfusion-syntax" name="ft-coldfusion-syntax">*ft-coldfusion-syntax*</a><br>
<br>
ColdFusionには独自版のHTMLコメントが存在する。ColdFusionのコメントハイライトを<br>
有効化するには、次の行を起動設定ファイルに加える:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let html_wrong_comments=1</span><br>
<br>
ColdFusionの構文ファイルはHTML用構文ファイルに基づいている。<br>
<br>
<br>
<span class="Statement">CSH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#csh.vim" name="csh.vim">*csh.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-csh-syntax" name="ft-csh-syntax">*ft-csh-syntax*</a><br>
<br>
これは&quot;csh&quot;という名前のシェルに対応している。システムによっては実際に使われて<br>
いるのがtcshである場合もあることに注意。<br>
<br>
ファイルがcshかtcshかを判定するのは難しいことがよく知られている。いくつかのシ<br>
ステムでは/bin/cshを/bin/tcshにシンボリックリンクしていることが、この判別をほ<br>
ぼ不可能にしている。Vimが間違った判定をする場合には変数&quot;filetype_csh&quot;を設定す<br>
ることが出来る。cshを使うには:&nbsp;&nbsp;<a class="Constant" href="syntax.html#g:filetype_csh" name="g:filetype_csh">*g:filetype_csh*</a><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:filetype_csh = &quot;csh&quot;</span><br>
<br>
tcshを使うには:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:filetype_csh = &quot;tcsh&quot;</span><br>
<br>
拡張子がtcshであるか標準的なtcshファイル名(.tcshrc, tcsh.tcshrc, tcsh.login)を<br>
持つスクリプトはすべてtcshファイル形式とされる。他のtcsh/cshスクリプトは、<br>
&quot;filetype_csh&quot;変数が存在しない限り、すべてtcshとみなされる。変数&quot;filetype_csh&quot;<br>
が存在するならファイル形式はその値にセットされる。<br>
<br>
<br>
<span class="Statement">CYNLIB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#cynlib.vim" name="cynlib.vim">*cynlib.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-cynlib-syntax" name="ft-cynlib-syntax">*ft-cynlib-syntax*</a><br>
<br>
Cynlibファイルは、ハードウェアのモデリングとシミュレーションを行なうCynlibクラ<br>
スライブラリを使用したC++ファイルである。通常Cynlibのファイルは.ccや.cppという<br>
拡張子を持つので、CynlibではないC++ファイルと区別するのは非常に困難である。だ<br>
から.ccファイルをCynlibでハイライトする際には、ファイル.vimrcに次の行を加える:<br>
<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let cynlib_cyntax_for_cc=1</span><br>
<br>
cppファイルについても同様(この拡張子は通常Windowsだけで使用される)<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let cynlib_cyntax_for_cpp=1</span><br>
<br>
これらを再び無効にするには次のコマンドを使用する:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unlet cynlib_cyntax_for_cc</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unlet cynlib_cyntax_for_cpp</span><br>
<br>
<br>
<span class="Statement">CWEB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#cweb.vim" name="cweb.vim">*cweb.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-cweb-syntax" name="ft-cweb-syntax">*ft-cweb-syntax*</a><br>
<br>
&quot;*.w&quot;にマッチする名前のファイルのタイプはProgressかCWEBである。自動検出が動作<br>
しない場合や、Progressを編集しないことが判っている場合には、起動設定ファイル<br>
vimrcに次のコマンドを書くとよい:<br>
<span class="Comment">&nbsp;&nbsp; :let filetype_w = &quot;cweb&quot;</span><br>
<br>
<br>
<span class="Statement">DESKTOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#desktop.vim" name="desktop.vim">*desktop.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-desktop-syntax" name="ft-desktop-syntax">*ft-desktop-syntax*</a><br>
<br>
この構文ファイルの本来の目的は、freedesktop.org 標準の .desktop と .directory<br>
を構文ハイライトすることである:<br>
<span class="Constant"><a href="http://standards.freedesktop.org/desktop-entry-spec/latest/">http://standards.freedesktop.org/desktop-entry-spec/latest/</a></span><br>
しかし実際にはこの標準を完全に実装したものはほとんどない。なのでこれは全ての<br>
iniファイルをハイライトする。ただし次をvimrcファイルに書くことによって厳格に標<br>
準に準拠したハイライトをさせることもできる:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let enforce_freedesktop_standard = 1</span><br>
<br>
<br>
<span class="Statement">DIRCOLORS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#dircolors.vim" name="dircolors.vim">*dircolors.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-dircolors-syntax" name="ft-dircolors-syntax">*ft-dircolors-syntax*</a><br>
<br>
dircolorsユーティリティ用のハイライト定義には、Slackware GNU/Linuxディストリ<br>
ビューション版のdircolorsに対応するためのオプションがある。このオプションはほ<br>
とんどのバージョンでは無視されるいくつかのキーワードを付け加える。しかし<br>
Slackwareシステムではdircolorsはこれらのキーワードを認め、処理に用いる。<br>
Slackwareキーワードを有効化するには次を起動設定ファイルに付け加えればよい:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let dircolors_is_slackware = 1</span><br>
<br>
<br>
<span class="Statement">DOCBOOK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#docbk.vim" name="docbk.vim">*docbk.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-docbk-syntax" name="ft-docbk-syntax">*ft-docbk-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#docbook" name="docbook">*docbook*</a><br>
<span class="Statement">DOCBOOK XML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#docbkxml.vim" name="docbkxml.vim">*docbkxml.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-docbkxml-syntax" name="ft-docbkxml-syntax">*ft-docbkxml-syntax*</a><br>
<span class="Statement">DOCBOOK SGML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#docbksgml.vim" name="docbksgml.vim">*docbksgml.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-docbksgml-syntax" name="ft-docbksgml-syntax">*ft-docbksgml-syntax*</a><br>
<br>
DocBookファイルには2つの種類: SGMLとXMLがある。どちらのタイプを使用するのかを<br>
指定するには変数&quot;b:docbk_type&quot;をセットする。Vimがそのタイプを認識できた場合に<br>
はこれを自動的に行う。認識できなかった場合にはデフォルトはXMLになる。<br>
これを手動で設定するには:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let docbk_type = &quot;sgml&quot;</span><br>
または:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let docbk_type = &quot;xml&quot;</span><br>
これは構文ファイルを読み込む前に行う必要がある。しかし構文ファイルの読み込みは<br>
込み入っている。より単純な方法はファイル形式を&quot;docbkxml&quot;または&quot;docbksgml&quot;に<br>
セットすることである:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set filetype=docbksgml</span><br>
または:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set filetype=docbkxml</span><br>
<br>
<br>
DOSバッチファイル&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#dosbatch.vim" name="dosbatch.vim">*dosbatch.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-dosbatch-syntax" name="ft-dosbatch-syntax">*ft-dosbatch-syntax*</a><br>
<br>
DOSバッチファイルのハイライトにはオプションが1つある。このオプションにより<br>
Windows 2000で導入されたコマンドインタプリタの新しい拡張機能がサポートされ、変<br>
数dosbatch_cmdextversionによりその有効/無効が制御される。Windows NTでは値1を設<br>
定し、Windows 2000では2を設定するのが良い。次のようにすれば使用するバージョン<br>
を選択できる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;:let dosbatch_cmdextversion = 1</span><br>
<br>
変数が定義されていない際のデフォルトはWindows 2000をサポートする2となる。<br>
<br>
2番目のオプションは、*.btm ファイルを &quot;dosbatch&quot; (MS-DOS バッチファイル) タイ<br>
プか &quot;btm&quot; (4DOS バッチファイル) タイプのどちらと判定するかを指定する。デフォ<br>
ルトでは後者が使われる。前者を使うには、次のようにする:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :let g:dosbatch_syntax_for_btm = 1</span><br>
<br>
この変数が定義されていない、または0であると btm の構文が使われる。<br>
<br>
<span class="Statement">DOXYGEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#doxygen.vim" name="doxygen.vim">*doxygen.vim*</a>&nbsp;<a class="Constant" href="syntax.html#doxygen-syntax" name="doxygen-syntax">*doxygen-syntax*</a><br>
<br>
Doxygen は JavaDoc に似た特殊なフォーマットからコードのドキュメントを生成する。<br>
この構文スクリプトは c, cpp, idl, php のファイルに対して Doxygen のハイライ<br>
トを追加する。また、Java に対しても使える。<br>
<br>
Doxygen のフォーマットを有効にするにはいくつかの方法がある。手動、またはモード<br>
ラインでそのファイルの syntax に '.doxygen' を追加する。例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set syntax=c.doxygen</span><br>
または&nbsp;<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// vim&#0058;syntax=c.doxygen</span><br>
<br>
C, C++, C#, IDL, PHP のファイルに対しては、グローバルまたはバッファローカルな<br>
変数 load_doxygen_syntax を設定すれば自動的にこれが行われる。次の行を .vimrc<br>
に加える。<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:load_doxygen_syntax=1</span><br>
<br>
構文ハイライトに影響を与える変数がいくつかある。また、これらは標準でないハイラ<br>
イトオプションに関係している。<br>
<br>
<span class="PreProc">変数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既定値&nbsp;&nbsp;効果</span><br>
g:doxygen_enhanced_color<br>
g:doxygen_enhanced_colour&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Doxygen コメントに対して標準でないハイ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ライトを行う。<br>
<br>
doxygen_my_rendering&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HTML の太字、斜体、html_my_rendering&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;に対する下線の描画を無効にする。<br>
<br>
doxygen_javadoc_autobrief&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0にすると JavaDoc の autobrief に対す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;るハイライトを無効にする。<br>
<br>
doxygen_end_punctuation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '[.]'&nbsp;&nbsp; brief の終わりを示す句読点にマッチする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正規表現。<br>
<br>
また、次のハイライトグループを設定すると便利である。<br>
<br>
<span class="PreProc">ハイライト&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;効果</span><br>
doxygenErrorComment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code, verbatim, dot セクション中で句読点が抜け<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ている終了コメントの色<br>
doxygenLinkError&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\link セクションで \endlink が抜けているときの<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;終了コメントの色。<br>
<br>
<br>
<span class="Statement">DTD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#dtd.vim" name="dtd.vim">*dtd.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-dtd-syntax" name="ft-dtd-syntax">*ft-dtd-syntax*</a><br>
<br>
初期状態ではDTD構文ハイライトは大/小文字を区別する。区別しないようにするには、<br>
起動設定ファイルに次の行を書き足す:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let dtd_ignore_case=1</span><br>
<br>
DTD構文ファイルでは未知のタグをエラーとしてハイライトする。これが煩わしいなら<br>
ば、構文ファイルdtd.vimが読込まれる前に:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let dtd_no_tag_errors=1</span><br>
<br>
と設定することで無効化することができる。定義部内のパラメータのエンティティ名は<br>
ハイライトグループ'Type'、句読点と'%'は'Comment'を使用してハイライトされる。パ<br>
ラメータエンティティの実体はハイライトグループ'Constant'を、区切り文字の%と;は<br>
ハイライトグループ'Type'を使用してハイライトされる。以下を設定するとこれを無効<br>
化できる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let dtd_no_param_entities=1</span><br>
<br>
XML内の埋め込みDTDをハイライト表示するために、DTDの構文ファイルはxml.vimからも<br>
参照される。<br>
<br>
<br>
<span class="Statement">EIFFEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#eiffel.vim" name="eiffel.vim">*eiffel.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-eiffel-syntax" name="ft-eiffel-syntax">*ft-eiffel-syntax*</a><br>
<br>
Eiffelは大小文字の区別をしないけれども、スタイルガイドラインが示すように、構文<br>
ハイライトではそれらが区別される。これにより大小文字が違えば違うクラス名として<br>
ハイライト表示することが可能になっている。大小文字の違いを無視してハイライトを<br>
行なうならば、起動設定ファイルに次の行を書き足す:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let eiffel_ignore_case=1</span><br>
<br>
これを行なってもコメント内のクラス名とTODOの印には大小文字の区別がなされる。<br>
<br>
逆に、もっと厳密に検査するには、次の行のいずれかを書き足す:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let eiffel_strict=1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let eiffel_pedantic=1</span><br>
<br>
eiffel_strictを設定すると&quot;Current&quot;, &quot;Void&quot;, &quot;Result&quot;, &quot;Precursor&quot;そして&quot;NONE&quot;<br>
の5つの既定単語について、不正な大小文字の使用を捕捉し、機能やクラス名としてそ<br>
れらが使用されれば警告を与えるようになる。<br>
<br>
eiffel_pedanticを設定すると、Eiffelのスタイルガイドラインを相当に厳格に強制す<br>
る。(キーワードを大文字で書く時代遅れの方法と同様に、大小文字を任意にミックス<br>
したようなものが補足される)<br>
<br>
&quot;Current&quot;, &quot;Void&quot;, &quot;Result&quot;そして&quot;Precursor&quot;の小文字版を使用するには、大小文字<br>
を区別するハイライト方法を無効化する代わりに:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let eiffel_lower_case_predef=1</span><br>
<br>
という方法を使うことができる。<br>
<br>
ISEが提案し、実験的に幾つかのコンパイラでは取り扱うことのできる、新しい生成構<br>
文は次のコマンドで使用できるようになる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let eiffel_ise=1</span><br>
<br>
最後に幾つかのベンダは16進数定数値をサポートしている。それを取り扱うには:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let eiffel_hex_constants=1</span><br>
<br>
この行を起動設定ファイルに書き足す。<br>
<br>
<br>
<span class="Statement">ERLANG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#erlang.vim" name="erlang.vim">*erlang.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-erlang-syntax" name="ft-erlang-syntax">*ft-erlang-syntax*</a><br>
<br>
これはErlang(ERicsson LANGuage: エリクソン言語)をサポートする構文ハイライトファ<br>
イルである。Erlangは大小文字を区別しデフォルトの拡張子は&quot;.erl&quot;である。<br>
<br>
キーワードハイライトを無効化するには、これを.vimrcに書き足す:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let erlang_keywords = 1</span><br>
組み込み関数ハイライトを無効化するには、これを.vimrcに書き足す:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let erlang_functions = 1</span><br>
特殊文字のハイライトを無効化するには、これを.vimrcに書き足す:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let erlang_characters = 1</span><br>
<br>
<br>
<span class="Statement">FLEXWIKI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#flexwiki.vim" name="flexwiki.vim">*flexwiki.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-flexwiki-syntax" name="ft-flexwiki-syntax">*ft-flexwiki-syntax*</a><br>
<br>
<br>
FlexWiki は&nbsp;<span class="Constant"><a href="http://www.flexwiki.com">http://www.flexwiki.com</a></span>&nbsp;で入手できる ASP.NET ベースの wiki パッ<br>
ケージである。<br>
<span class="Todo">NOTE</span>: このサイトは現在機能していない。Wikipedia によると 2009 年に開発がストッ<br>
プした。<br>
<br>
FlexWiki の構文のほとんどの一般的な要素に対して構文ハイライトができる。<br>
FlexWiki のtplugin スクリプトはバッファローカルなオプションを設定し、FlexWiki<br>
ページの編集をより便利にする。FlexWiki は改行を新しい段落の開始とみなすので、<br>
このftplugin は&nbsp;<a class="Type" href="options.html#'tw'">'tw'</a>&nbsp;を0に設定し (行の長さを制限しない)、<a class="Type" href="options.html#'wrap'">'wrap'</a>&nbsp;をオンにし (長<br>
い行を水平スクロールさせるのでなく、折り返す)、<a class="Type" href="options.html#'linebreak'">'linebreak'</a>&nbsp;をオンにする (画面<br>
上の最後の文字でなく&nbsp;<a class="Type" href="options.html#'breakat'">'breakat'</a>&nbsp;の文字で折り返す)、などを行う。また、デフォルト<br>
では無効にされているキーマップも含んでいる。<br>
<br>
&quot;j&quot;、&quot;k&quot;、カーソルキーで表示行単位で移動するようにするキーマップを有効にするに<br>
は次を .vimrc に追加する:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let flexwiki_maps = 1</span><br>
<br>
<br>
<span class="Statement">FORM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#form.vim" name="form.vim">*form.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-form-syntax" name="ft-form-syntax">*ft-form-syntax*</a><br>
<br>
FORMファイルの構文要素に使用するカラースキームには、Conditional, Number,<br>
Statement, Comment, PreProc, Type, そしてStringが、次の文献で定義される言語仕<br>
様に沿って行なわれる。<br>
文献: 'Symbolic Manipulation with FORM' by J.A.M. Vermaseren, CAN,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Netherlands, 1991.<br>
<br>
初期設定の色に変更を加えるには、次の構文グループを再定義すれば良い:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;- formConditional<br>
&nbsp;&nbsp;&nbsp;&nbsp;- formNumber<br>
&nbsp;&nbsp;&nbsp;&nbsp;- formStatement<br>
&nbsp;&nbsp;&nbsp;&nbsp;- formHeaderStatement<br>
&nbsp;&nbsp;&nbsp;&nbsp;- formComment<br>
&nbsp;&nbsp;&nbsp;&nbsp;- formPreProc<br>
&nbsp;&nbsp;&nbsp;&nbsp;- formDirective<br>
&nbsp;&nbsp;&nbsp;&nbsp;- formType<br>
&nbsp;&nbsp;&nbsp;&nbsp;- formString<br>
<br>
構文ファイルform.vimではFORMプリプロセッサコマンドとディレクティブをそれぞれ、<br>
デフォルトでは同じ構文グループにしていることに注意。<br>
<br>
FORM用の既定の拡張カラーモードではヘッダ命令とFORMプログラム本体での命令を区別<br>
できるような色設定が利用可能である。拡張カラーモードを使用可能にするには、ファ<br>
イルvimrcに次の設定を書き足す:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let form_enhanced_color=1</span><br>
<br>
拡張モードを使うことは、gvimで暗いディスプレイを使用した場合にも利点がある。命<br>
令文は黄色ではなく明るい黄色で表示され、条件文は視認性のため明るい青で表示され<br>
る。<br>
<br>
<br>
<span class="Statement">FORTRAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#fortran.vim" name="fortran.vim">*fortran.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-fortran-syntax" name="ft-fortran-syntax">*ft-fortran-syntax*</a><br>
<br>
<span class="PreProc">デフォルトのハイライトと方言</span><br>
初期設定では Fortran 2008 に適したハイライトが行われる。Fortran 2008 は以前の<br>
バージョン (Fortran 2003, 95, 90, 77) のほぼ上位互換であるため、この初期設定は<br>
ほとんどのユーザーにとって適しているでしょう。<br>
<br>
<span class="PreProc">Fortranソースコードの形式</span><br>
Fortran のソースコードには固定形式と自由形式が有る。形式が誤って設定されている<br>
と構文ハイライトが正しくされないことに注意。<br>
<br>
新規にFortranのファイルを作成する場合には、構文ファイルは固定形式であると仮定<br>
する。常に自由形式を使う場合には<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:let fortran_free_source=1</span><br>
これを.vimrcでコマンド:syntaxを実行する前に行なう必要がある。常に固定形式を使<br>
うには<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:let fortran_fixed_source=1</span><br>
これも.vimrcでコマンド:syntaxを実行する前に行う必要がある。<br>
<br>
ソースコードの形式がファイル拡張子によって決定できる場合には、ftpluginファイル<br>
の1つでfortran_free_sourceを設定すると便利になる。ftpluginファイルについての詳<br>
細は<a class="Identifier" href="usr_41.html#ftplugin">|ftplugin|</a>を参照のこと。例えば、拡張子.f90を持つファイルについては全て自由<br>
形式として扱い、それ以外のものは固定形式とする場合には、次のコードをftplugin<br>
ファイルに記述すれば良い。<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;let s:extfname = expand(&quot;%:e&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;if s:extfname ==? &quot;f90&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let fortran_free_source=1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlet! fortran_fixed_source</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;else</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let fortran_fixed_source=1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlet! fortran_free_source</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;endif</span><br>
これは.vimrcで&quot;syntax on&quot;より前に&quot;filetype plugin indent on&quot;が書かれていないと<br>
機能しないことに注意。<br>
<br>
既存のFortranファイルを編集する時には、変数fortran_free_sourceが設定されていれ<br>
ば構文ファイルは自由形式のソースであると仮定し、変数fortran_fixed_sourceが設定<br>
されていれば固定形式のソースであると仮定する。どちらも設定されていないときに<br>
は、ファイルの先頭250行の行頭5カラムを調べて、その形式が固定なのか自由なのかを<br>
決定しようと試みる。自由形式コードの兆候が見られない場合には、ファイルは固定形<br>
式コードとして取り扱われる。このアルゴリズムはほとんどのケースにおいて有効に機<br>
能する。しかしいくつかのケース、例えば先頭250行以上が行コメントで占められてい<br>
るようなファイルでは、構文ファイルが固定形式コードであると誤った判断をしてしま<br>
うだろう。そのような場合には、ファイルの先頭250行の行頭5桁のどこかに、コメント<br>
以外の命令文を追加し、ファイルの保存(:w)そして再読込(:e!)を行なえば良い。<br>
<br>
<span class="PreProc">Fortranファイル内のタブ文字</span><br>
標準のFortranではタブ文字は認識されない。固定桁位置での境界を必要とする固定形<br>
式のFortranソースコードでタブ文字を使用するのは良いアイデアではない。従ってタ<br>
ブ文字はエラーとしてハイライトされる。しかしながらプログラマーによってはタブ文<br>
字を使用することを望む場合があるだろう。Fortranファイルにタブ文字が含まれてい<br>
る場合には、変数fortran_have_tabsをコマンド:syntaxが実行される前に<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:let fortran_have_tabs=1</span><br>
このように.vimrcで設定すれば良い。タブ文字を使う場合には残念ながら、構文ファイ<br>
ルによって不正な余白を検出することができなくなる。<br>
<br>
<span class="PreProc">Fortranファイルの構文による折り畳み</span><br>
foldmethod=syntaxを使用したいならば、まず変数fortran_foldを<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:let fortran_fold=1</span><br>
このようなコマンドで設定しなければならない。これにより構文ファイルはプログラム<br>
単位の領域、プログラム命令文で始まるメインプログラム、サブルーチン、関数、サブ<br>
プログラム、ブロックデータサブプログラム、そしてモジュールといったプログラム単<br>
位の領域で折り畳みを定義する。同時に変数fortran_fold_conditionalsを<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:let fortran_fold_conditionals=1</span><br>
このように設定すると、doループ、ifブロック、そしてselect-case構造の領域が折り<br>
畳まれる。さらに変数fortran_fold_multilinecommentsも<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:let fortran_fold_multilinecomments=1</span><br>
このように設定すれば、3行以上にわたって続くコメントの領域が折り畳まれる。大き<br>
なファイルに対してこのように構文による折り畳みを使用すると、非常に遅くなること<br>
に注意。<br>
<br>
fortran_foldを設定し、fortran_fold_conditionalsか<br>
fortran_fold_multilinecomments(どちらか片方でも両方でも)を設定した場合には、<br>
foldmethod=syntaxを設定してある時に、Vimはファイルを折り畳む。2つのプログラム単<br>
位の間にあるコメントや空行は折り畳まれない。なぜならそれらは構文によって定義され<br>
るプログラム単位に属していないからである。<br>
<br>
<span class="PreProc">より正確なFortranの構文</span><br>
変数fortran_more_preciseを<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:let fortran_more_precise=1</span><br>
このようなコマンドで設定した場合には、構文ハイライトがより正確になるが動作は遅<br>
くなる。とりわけ、do、goto、そして算術if命令文に使用される命令ラベルが、do、if、<br>
selectもしくはforall構造の終端で使用される名前として認識されるようになる。<br>
<br>
<span class="PreProc">非標準のFortran方言</span><br>
構文ファイルは 2 つの Fortran 方言 (f08 と F) をサポートしている。ほとんどの人<br>
はデフォルトのハイライト (f08) で用が足りるでしょう。2008 標準で削除または廃止<br>
予定となったいくつかの古い構造は todo アイテムとしてハイライトされる。<br>
<br>
F を使うなら、方言を適切に設定することで、F から除外された他の古い機能は todo<br>
アイテムとしてハイライトされ、そして自由形式のソースコードが仮定される。<br>
<br>
方言を設定する方法はいくつかある。もしあなたの fortran ファイルがすべて同じ方<br>
言なら、グローバル変数の fortran_dialect を .vimrc の syntax on より前で設定す<br>
ればよい。値は大文字と小文字が区別される。fortran_dialect に設定できる値は<br>
&quot;f08&quot; か &quot;F&quot; である。fortran_dialect に無効な値を設定した場合は無視される。<br>
<br>
方言がファイルの拡張子に依存して決定される場合には、ftplugin ファイル内でバッ<br>
ファローカル変数を設定するのが最良の手段である。ftplugin ファイル付いての詳細<br>
な情報は&nbsp;<a class="Identifier" href="usr_41.html#ftplugin">|ftplugin|</a>を参照。例えば、.f90 という拡張子のすべてのファイルが F サ<br>
ブセットで書かれているなら、ftplugin ファイルには次のようなコードが含まれるで<br>
しょう<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp; let s:extfname = expand(&quot;%:e&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp; if s:extfname ==? &quot;f90&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let b:fortran_dialect=&quot;F&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp; else</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlet! b:fortran_dialect</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp; endif</span><br>
これは.vimrcで&quot;syntax on&quot;より前に&quot;filetype plugin indent on&quot;が書かれていないと<br>
機能しないことに注意。<br>
<br>
拡張子によって方言を一意に決定できない場合にはもっと良い制御方法が必要になる。<br>
各ファイルの先頭 3 行以内にコメントで &quot;fortran_dialect=xx&quot; (xx は F or f8) と<br>
いう命令を書けば方言の設定を上書することができる。<br>
例えば、古い .f ファイルは古い方言で書かれているが、新しい .f ファイルは F<br>
コードで書きたいような場合、後者を F ファイルとして認識させるには、そのファイ<br>
ルの先頭 3 行以内に Fortran のコメントとして次のように書く<br>
<span class="Comment">&nbsp;&nbsp;! fortran_dialect=F</span><br>
<br>
この構文ファイルの以前のバージョンでは fortran_dialect の値として &quot;f77&quot;,<br>
&quot;f90&quot;, &quot;f95&quot;, &quot;elf&quot; が設定できました。これらの値が設定されているときは &quot;f08&quot;<br>
として扱われます。&quot;elf&quot; を設定していた人は &quot;F&quot; を試してみるといいかもしれませ<br>
ん。<br>
<br>
syntax/fortran.vim スクリプトにはヒントとなるコメントが含まれています。行をコ<br>
メントアウトしたりコメントを外したりすることで、(a) 非標準またはベンダー固有構<br>
文の認識を有効化したり、(b) 2008 標準で削除または廃止予定となった機能を todo<br>
アイテムとしてハイライトしないようにしたり、できます。<br>
<br>
<span class="PreProc">制限事項</span><br>
丸カッコチェックは、閉じカッコの不足については捕捉できない。ホレリス定数は認識<br>
されない。幾つかのキーワードはFortran90の予約語ではないので誤ってハイライトさ<br>
れる。<br>
<br>
Fortranに関するその他の情報は<a class="Identifier" href="indent.html#ft-fortran-indent">|ft-fortran-indent|</a>や<a class="Identifier" href="filetype.html#ft-fortran-plugin">|ft-fortran-plugin|</a>を参照。<br>
<br>
<span class="Statement">FVWM CONFIGURATION FILES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#fvwm.vim" name="fvwm.vim">*fvwm.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-fvwm-syntax" name="ft-fvwm-syntax">*ft-fvwm-syntax*</a><br>
<br>
*fvwmrc*または*fvwm2rc*というパターンにマッチしないFvwm設定ファイルを認識させ<br>
るには、ファイルmyfiletypefile.vimであなたのシステムに合ったパターンを設定しな<br>
ければならない。具体的には、変数&quot;b:fvwm_version&quot;にFvwmのメジャーバージョンを指<br>
定し、オプション<a class="Type" href="options.html#'filetype'">'filetype'</a>にfvwmを設定する。<br>
<br>
例えば、/etc/X11/fvwm2/配下の全てのファイルをFvwm2の設定ファイルと認識させるに<br>
は次のようにする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;:au! BufNewFile,BufRead /etc/X11/fvwm2/*&nbsp;&nbsp;let b:fvwm_version = 2 |</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ set filetype=fvwm</span><br>
<br>
全ての有効な色の名前をVimにハイライトさせるには、システムの色データベース<br>
(rgb.txt)の位置を知らせる必要がある。これには変数&quot;rgb_file&quot;にその場所を設定す<br>
る。色データベースが/usr/X11/lib/X11/にあるとすれば:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let rgb_file = &quot;/usr/X11/lib/X11/rgb.txt&quot;</span><br>
<br>
このような内容をファイル.vimrcに追加する。<br>
<br>
<br>
<span class="Statement">GSP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#gsp.vim" name="gsp.vim">*gsp.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-gsp-syntax" name="ft-gsp-syntax">*ft-gsp-syntax*</a><br>
<br>
GSPページのデフォルトカラーは<a class="Identifier" href="syntax.html#html.vim">|html.vim|</a>にて定義され、Javaコード(Javaタグ内部や<br>
インラインのバッククォート内)のカラーは<a class="Identifier" href="syntax.html#java.vim">|java.vim|</a>にて定義される。インライン<br>
Javaコードをハイライトするために、<a class="Identifier" href="syntax.html#html.vim">|html.vim|</a>で定義される以下のHTMLグループは、<br>
再定義されている:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;htmlString<br>
&nbsp;&nbsp;&nbsp;&nbsp;htmlValue<br>
&nbsp;&nbsp;&nbsp;&nbsp;htmlEndTag<br>
&nbsp;&nbsp;&nbsp;&nbsp;htmlTag<br>
&nbsp;&nbsp;&nbsp;&nbsp;htmlTagN<br>
<br>
書かれた大抵の場所のインラインJavaコードは適切にハイライトされるが、幾つかの特<br>
殊なケースではそうはならない。他のHTMLグループ内にインラインJavaコードを書いて<br>
それが正しくハイライトされない場合には、必要な行を<a class="Identifier" href="syntax.html#html.vim">|html.vim|</a>からコピーして<br>
gspJavaをconstains節に加えれば、正しくハイライトされるようになる。<br>
<br>
インラインJavaを示すバッククォートは、目立ちやすくするためにhtmlErrorグループ<br>
でハイライトされる。<br>
<br>
<br>
<span class="Statement">GROFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#groff.vim" name="groff.vim">*groff.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-groff-syntax" name="ft-groff-syntax">*ft-groff-syntax*</a><br>
<br>
groff構文ファイルは<a class="Identifier" href="syntax.html#nroff.vim">|nroff.vim|</a>のラッパーであり、使用例と設定例についてはそこの<br>
下に書かれている注意を参照。このラッパーの目的は、モードラインか個人用のファイ<br>
ル定義ファイル(<a class="Identifier" href="filetype.html">|filetype.txt|</a>参照)からファイル形式をセットすることにより、<br>
groff構文拡張を設定することである。<br>
<br>
<br>
<span class="Statement">HASKELL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#haskell.vim" name="haskell.vim">*haskell.vim*</a>&nbsp;<a class="Constant" href="syntax.html#lhaskell.vim" name="lhaskell.vim">*lhaskell.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-haskell-syntax" name="ft-haskell-syntax">*ft-haskell-syntax*</a><br>
<br>
Haskell構文ファイルは、プレーンHaskellコードとliterate Haskellコード両方を<br>
サポートしている。後者はBirdスタイルとTeXスタイル両方に対応している。Haskell用<br>
の構文ハイライトはCプリプロセッサ命令もハイライトできる。<br>
<br>
区切り文字もハイライトさせるには(明るい背景色を使っているなら便利)、次を.vimrc<br>
に書き足す:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let hs_highlight_delimiters = 1</span><br>
TrueとFalseを通常の識別子と区別してキーワードとして扱うにはこれを書き足す:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let hs_highlight_boolean = 1</span><br>
プリミティブ型の名前をキーワードして扱うには:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let hs_highlight_types = 1</span><br>
比較的一般的な型の名前をキーワードとして扱うには:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let hs_highlight_more_types = 1</span><br>
デバッグ関数の名前をハイライトさせるには、これを.vimrcに書き足す:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let hs_highlight_debug = 1</span><br>
<br>
Haskell用の構文ハイライトはCプリプロセッサ命令もハイライトし、#で始まるが命令<br>
として有効でない行をエラーとして警告する。Haskellの演算子の構文は#で始まること<br>
もあるため、これらが干渉する。これらをエラーでなく演算子としてハイライトしたい<br>
なら、次を.vimrcに書く:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let hs_allow_hash_operator = 1</span><br>
<br>
literate Haskellコード用の構文ハイライトはファイルがTeXマークアップを含んでい<br>
るかどうか、それに応じてTeX要素をハイライトするかどうかを自動的に推測しようと<br>
する。.vimrcに次のような行を書くと、これをグローバルに上書きすることができる<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let lhs_markup = none</span><br>
と書くとまったくハイライトしなくする。または<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let lhs_markup = tex</span><br>
と書くと常にTeXマークアップをハイライトするように強制する。より柔軟に、この変<br>
数のバッファローカル版を使うことも出来る。例.<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let b:lhs_markup = tex</span><br>
と書くと特定のバッファにTeXハイライトさせるようにする。これはそのバッファに構<br>
文ハイライトを有効化するかファイルを読み込む前に設定しなければならない。<br>
<br>
<br>
<span class="Statement">HTML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#html.vim" name="html.vim">*html.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-html-syntax" name="ft-html-syntax">*ft-html-syntax*</a><br>
<br>
HTMLファイルのタグ用の構文ファイルは以下のように動作する。<br>
<br>
開きタグの&lt;&gt;は、閉じタグの&lt;/&gt;とは異なった色でハイライトされる。これは意図的に<br>
そうしてある!。開きタグにはハイライト'Function'が使用され、閉じタグにはハイラ<br>
イト'Type'が使用される(あなたの環境でこれらがどう定義されているかについては<br>
syntax.vimを参照すること)。<br>
<br>
既知のタグ名はC命令文と同じようにハイライトされる。未知のタグ名は間違いを見分<br>
けやすくするために、&lt;&gt;や&lt;/&gt;と同じようにハイライトされる。<br>
<br>
引数(もしくは属性)名にも同じことが言える。既知の属性名と未知の属性名には異なる<br>
ハイライトがなされる。<br>
<br>
幾つかのHTMLタグは表示する文字種を変更するために使用される。以下のタグは構文<br>
ファイルhtml.vimによって認識され、その内容は通常の文字種とは異なる文字種で表示<br>
される:&nbsp;<span class="Special">&lt;B&gt;</span>&nbsp;<span class="Special">&lt;I&gt;</span>&nbsp;<span class="Special">&lt;U&gt;</span>&nbsp;<span class="Special">&lt;EM&gt;</span>&nbsp;<span class="Special">&lt;STRONG&gt;</span>&nbsp;(<span class="Special">&lt;EM&gt;</span>は<span class="Special">&lt;I&gt;</span>のエイリアスとして使われ、<span class="Special">&lt;STRONG&gt;</span><br>
は<span class="Special">&lt;B&gt;</span>のエイリアス)、<span class="Special">&lt;H1&gt;</span>&nbsp;-&nbsp;<span class="Special">&lt;H6&gt;</span>、<span class="Special">&lt;HEAD&gt;</span>、<span class="Special">&lt;TITLE&gt;</span>そして<span class="Special">&lt;A&gt;</span>、ただしhrefが含まれ<br>
ていてリンクとして使われている(例&lt;A href=&quot;somefile.html&quot;&gt;)場合。<br>
<br>
それらのテキストの文字種を変更するには、以下の構文グループを再定義する必要があ<br>
る:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;- htmlBold<br>
&nbsp;&nbsp;&nbsp;&nbsp;- htmlBoldUnderline<br>
&nbsp;&nbsp;&nbsp;&nbsp;- htmlBoldUnderlineItalic<br>
&nbsp;&nbsp;&nbsp;&nbsp;- htmlUnderline<br>
&nbsp;&nbsp;&nbsp;&nbsp;- htmlUnderlineItalic<br>
&nbsp;&nbsp;&nbsp;&nbsp;- htmlItalic<br>
&nbsp;&nbsp;&nbsp;&nbsp;- htmlTitle for titles<br>
&nbsp;&nbsp;&nbsp;&nbsp;- htmlH1 - htmlH6 for headings<br>
<br>
この再定義が機能するためには最後の2つを除くすべてを再定義しなければならない。<br>
最後の2つ、htmlTitleとhtmlH[1-6]は任意である。そして次の変数をvimrcで設定しな<br>
ければならない(初期化の際に読み込まれるファイルの順序のせい)。<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let html_my_rendering=1</span><br>
<br>
この例については以下からmysyntax.vimをダウンロードすること。<br>
<span class="Constant"><a href="http://www.fleiner.com/vim/download.html">http://www.fleiner.com/vim/download.html</a></span><br>
<br>
次の行をvimrcに加えればこの描画を無効にできる:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let html_no_rendering=1</span><br>
<br>
HTMLコメントはむしろ特別で(詳細はHTMLリファレンスドキュメントを参照)、すべての<br>
エラーをハイライトする。しかしその間違ったスタイル(&lt;!--で始まり--!&gt;で終わる)を<br>
使いたいならこれを定義する<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let html_wrong_comments=1</span><br>
<br>
HTMLドキュメント中に埋め込まれたJavaScriptやVisual Basicについては、文は<br>
'Special'でハイライトされ、コメントや文字列などは標準のプログラミング言語と同<br>
じように色づけされる。現在のところサポートされているのはJapaScriptとVisual<br>
Basicだけであり、他のスクリプト言語はまだ加えられていない。<br>
<br>
カスケードスタイルシート(CSS)の埋め込みとインラインもハイライトされる。<br>
<br>
htmlプロセッサ言語は複数ある。html.vimはインクルードしやすいように簡素に書かれ<br>
ている。html.vimをインクルードするには以下の2行をその言語用の構文ファイルに書<br>
き足すこと(この例はasp.vimからとった):&nbsp;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;runtime! syntax/html.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;syn cluster htmlPreproc add=asp<br>
<br>
そしてプリプロセッサ言語を含むすべての領域をクラスタhtmlPreprocに加えればよい。<br>
<br>
<br>
HTML/OS (by Aestiva)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#htmlos.vim" name="htmlos.vim">*htmlos.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-htmlos-syntax" name="ft-htmlos-syntax">*ft-htmlos-syntax*</a><br>
<br>
HTML/OS用のカラースキームは以下のように機能する:<br>
<br>
デフォルトでは関数名と変数名は同じである。これは、Vimは関数と識別子に異なる色<br>
を指定しないためである。これを変えるには(関数名を違う色にしたいならこうすると<br>
よい)次の行を~/.vimrcに書き加える:<br>
<span class="Comment">&nbsp;&nbsp;:hi Function term=underline cterm=bold ctermfg=LightGray</span><br>
<br>
もちろん好みに応じてctermfgは違う色にしてよい。<br>
<br>
HTML/OSに関するもう1つの問題は、ファイルがHTML/OSコーディングであることを示す<br>
特別なファイル形式が存在しないことである。そのため、ファイルを開いた後に次のよ<br>
うにしてHTML/OS構文をオンにしなければならない:<br>
<span class="Comment">&nbsp;&nbsp;:set syntax=htmlos</span><br>
<br>
HTML/OSコードのブロックの開始と終了を示す文字は、それぞれ&lt;&lt;または[[,<br>
&gt;&gt;または]]のどちらであってもよい。<br>
<br>
<br>
<span class="Statement">IA64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#ia64.vim" name="ia64.vim">*ia64.vim*</a>&nbsp;<a class="Constant" href="syntax.html#intel-itanium" name="intel-itanium">*intel-itanium*</a>&nbsp;<a class="Constant" href="syntax.html#ft-ia64-syntax" name="ft-ia64-syntax">*ft-ia64-syntax*</a><br>
<br>
Intel Itanium 64アセンブリ言語用のハイライト。このファイル形式を認識させる方法<br>
については<a class="Identifier" href="syntax.html#asm.vim">|asm.vim|</a>を参照。<br>
<br>
*.incファイルをIA64と認識させるには次を.vimrcに書き足す:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:filetype_inc = &quot;ia64&quot;</span><br>
<br>
<br>
<span class="Statement">INFORM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#inform.vim" name="inform.vim">*inform.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-inform-syntax" name="ft-inform-syntax">*ft-inform-syntax*</a><br>
<br>
Inform構文ハイライトはInform Libraryによって提供されるシンボルを含んでいる。ほ<br>
とんどのプログラムがそれを利用しているためである。Libraryのシンボルをハイライ<br>
トさせたくないなら、次をvim初期化ファイルに加える:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let inform_highlight_simple=1</span><br>
<br>
デフォルトではInformプログラムはZ-machineターゲットと仮定され、Z-machineアセン<br>
ブリ言語シンボルが適切にハイライトされる。もしプログラムがGlulx/Glk環境をター<br>
ゲットとしたものなら、次を初期化ファイルに加える:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let inform_highlight_glulx=1</span><br>
<br>
こうすると代わりにGlulxオペコードをハイライトし、glk()をシステム関数としてハイ<br>
ライトする。<br>
<br>
Informコンパイラはある古いキーワードをエラーとみなす。普通、これらのキーワード<br>
はエラーとしてハイライトされる。これをエラーとしてハイライトするのをやめるには、<br>
次を初期化ファイルに加える:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let inform_suppress_obsolete=1</span><br>
<br>
デフォルトではハイライトされる言語機能はコンパイラのバージョン6.30とライブラリ<br>
のバージョン6.11に従う。これより古いInform開発環境を使っているなら、次の行を初<br>
期化ファイルに加えるとよいかもしれない:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let inform_highlight_old=1</span><br>
<br>
<span class="Statement">IDL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#idl.vim" name="idl.vim">*idl.vim*</a>&nbsp;<a class="Constant" href="syntax.html#idl-syntax" name="idl-syntax">*idl-syntax*</a><br>
<br>
IDL (Interface Definition Language) ファイルは RPC 呼び出しを定義するために使<br>
われる。Microsoft の世界では COM インターフェイスと呼び出しの定義にも使われる。<br>
<br>
IDL の構造は単純であるため、ヒューリスティックな方法でなく、完全に文法にのっとっ<br>
たアプローチができる。その結果は巨大でいくぶん冗長であるが、一応は機能するよう<br>
である。<br>
<br>
idl ファイルには Microsoft 拡張がある。それらのうちいくつかは<br>
idl_no_ms_extensions を定義すると無効になる。<br>
<br>
より複雑な拡張は idl_no_extensions を定義すると無効になる。<br>
<br>
<span class="PreProc">変数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;効果</span><br>
<br>
idl_no_ms_extensions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Microsoft 独自の拡張の一部を無効にする<br>
idl_no_extensions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 複雑な拡張を無効にする<br>
idlsyntax_showerror&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDL エラーを表示する (少々うるさいがとても助け<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;になる)<br>
idlsyntax_showerror_soft&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;エラーに対してデフォルトでよりソフトな色を使う<br>
<br>
<br>
<span class="Statement">JAVA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#java.vim" name="java.vim">*java.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-java-syntax" name="ft-java-syntax">*ft-java-syntax*</a><br>
<br>
java.vim構文ハイライトファイルはいくつかのオプションを提供している：<br>
<br>
Java 1.0.2では丸括弧の内側に波括弧が入ることは絶対になかったため、これはエラー<br>
と判断された。Java1.1以降では(無名クラスとともに)これが可能になったため、エ<br>
ラーと判断されなくなった。もし以前のようにしたいなら、vimの初期化ファイルに次<br>
の行を加えること:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let java_mark_braces_in_parens_as_errors=1</span><br>
<br>
java.lang.*中の全ての識別子は常に全てのクラスから見える。これらをハイライトす<br>
るには<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let java_highlight_java_lang_ids=1<br>
とする。<br>
<br>
<span class="Constant"><a href="http://www.fleiner.com/vim/download.html">http://www.fleiner.com/vim/download.html</a></span>&nbsp;にあるスクリプトjavaid.vimをダウンロー<br>
ドすれば、ほとんどのJava標準パッケージの識別子をハイライトすることもできる。<br>
java.ioなど特定のパッケージの識別子だけをハイライトしたいならばこうする:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let java_highlight_java_io=1</span><br>
対応している全パッケージのリストはjavaid.vimを参照のこと。<br>
<br>
関数を認識する方法はJavaコードの書き方に依存するため、関数名はハイライトされな<br>
い。構文ファイルは関数をハイライトする方法を2つ備えている:<br>
<br>
関数宣言が常にタブ、スペース8個、スペース2個のいずれかでインデントされているな<br>
ら<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let java_highlight_functions=&quot;indent&quot;</span><br>
とするとよいかもしれない。<br>
しかし、関数とクラスの命名(大文字・小文字についての)に関するJavaガイドラインに<br>
したがっているなら<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let java_highlight_functions=&quot;style&quot;</span><br>
とすること。<br>
もしどちらのオプションもだめで、それでも関数宣言をハイライトしたいなら、<br>
java.vim中の定義を変更するか、もとのjava.vimに関数をハイライトするコードを加え<br>
て自分用のjava.vimを作るかして独自の定義を作るしかない。<br>
<br>
Java 1.1では、System.out.println()とSystem.err.println()はデバッグのためだけに<br>
使われるものだった。そのためデバッグ用の文を区別してハイライトすることができる。<br>
それには次の定義を初期化ファイルに加える:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let java_highlight_debug=1</span><br>
するとデバッグ用の文が'Special'の文字としてハイライトされるだろう。これらを別<br>
の色でハイライトさせるには、以下のグループに対して新しいハイライトを定義するこ<br>
と:<br>
&nbsp;&nbsp;&nbsp;&nbsp;Debug, DebugSpecial, DebugString, DebugBoolean, DebugType<br>
これらはそれぞれ、文、デバッグ文字列に使われる特別な文字、文字列、ブール型定<br>
数、型(this, super)に使われる。私はこれらの文に異なる背景色をつけることにして<br>
いる。<br>
<br>
JavadocはJavaプログラム中から特別なコメントを抜き出してHTMLページを作成するプ<br>
ログラムである。標準の設定ではこれらのHTMLコードをHTMLファイル(<a class="Identifier" href="syntax.html#html.vim">|html.vim|</a>を参<br>
照)と同様にハイライトする。さらにこのコードの中にjavascriptとCSSを書くこともで<br>
きる(後述)。しかし4つの違いがある:<br>
&nbsp;&nbsp;1. タイトル(その後にホワイトスペースが続く最初の'.'まで、または最初の'@'まで<br>
&nbsp;&nbsp;&nbsp;&nbsp; のすべての文字)は異なる色でハイライトされる(この色を変更するには<br>
&nbsp;&nbsp;&nbsp;&nbsp; CommentTitleを変えること)。<br>
&nbsp;&nbsp;2. テキストは'Comment'としてハイライトされる。<br>
&nbsp;&nbsp;3. HTMLコメントは'Special'としてハイライトされる。<br>
&nbsp;&nbsp;4. 特別なJavadocタグ(@see, @param, ...)はSpecialとして、(@see, @param,<br>
&nbsp;&nbsp;&nbsp;&nbsp; @exceptionなどの)引数はFunctionとしてハイライトされる。<br>
この機能をオフにするには初期化ファイルに次の行を加えること:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let java_ignore_javadoc=1</span><br>
<br>
以上のjavadocコメントを使う場合、javascript、visual basicスクリプト、埋め込み<br>
CSS(スタイルシート)のハイライトをすることもできる。これは実際にjavascriptや埋<br>
め込みCSSを含むjavadocコメントがあるときだけ意味がある。これらを有効化するため<br>
のオプションは次の通り<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let java_javascript=1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let java_css=1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let java_vb=1</span><br>
<br>
ネストした丸括弧に異なる色をつけるには、javaParen、javaParen1、javaParen2に異<br>
なる色を定義する。例えば<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:hi link javaParen Comment</span><br>
あるいは<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:hi javaParen ctermfg=blue guifg=#0000ff</span><br>
<br>
上方向にスクロールしていてハイライトがおかしくなった場合(<span class="Special">CTRL-L</span>で再描画すると<br>
直る)、内部変数&quot;java_minlines&quot;を大きくしてみるとよい:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let java_minlines = 50</span><br>
こうすると表示行の50行前から構文シンクロナイズが始まるようになる。デフォルト値<br>
は10である。大きな値にすることの不利点は、再描画が遅くなることである。<br>
<br>
<br>
<span class="Statement">LACE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#lace.vim" name="lace.vim">*lace.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-lace-syntax" name="ft-lace-syntax">*ft-lace-syntax*</a><br>
<br>
Lace (Language for Assembly of Classes in Eiffel)は大文字・小文字を無視する。<br>
しかしスタイルガイドラインはそうでない。大文字・小文字を区別してハイライトさせ<br>
るには、vim変数'lace_case_insensitive'を初期化ファイル中で定義すればよい:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let lace_case_insensitive=1</span><br>
<br>
<br>
<span class="Statement">LEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#lex.vim" name="lex.vim">*lex.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-lex-syntax" name="ft-lex-syntax">*ft-lex-syntax*</a><br>
<br>
&quot;^%%$&quot;セクションデリミタが、その後にどんなセクションが続くかの手がかりを与えな<br>
いため、Lexはブルートフォースなシンクロナイズを行う。それゆえ(巨大なlexファイ<br>
ルなどで)同期の問題が起こる場合には:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn sync minlines=300</span><br>
の値を変更するとよいかもしれない。<br>
<br>
<br>
<span class="Statement">LIFELINES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#lifelines.vim" name="lifelines.vim">*lifelines.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-lifelines-syntax" name="ft-lifelines-syntax">*ft-lifelines-syntax*</a><br>
<br>
廃止された関数をエラーとしてハイライトしたい場合は .vimrc で次のように設定して<br>
ください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:lifelines_deprecated = 1</span><br>
<br>
<span class="Statement">LISP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#lisp.vim" name="lisp.vim">*lisp.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-lisp-syntax" name="ft-lisp-syntax">*ft-lisp-syntax*</a><br>
<br>
lisp の構文ハイライトには2つのオプションがある:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:lisp_instring : この変数が存在すると &quot;(...)&quot; 形式の文字列が、その中</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;身が lisp であるかのようにハイライトされる。AutoLisp</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用に便利である。</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:lisp_rainbow&nbsp;&nbsp;: この変数が存在し、0以外であると段階の異なる括弧に</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;対して異なるハイライトがつくようになる。</span><br>
<br>
オプション g:lisp_rainbow は括弧とバッククォートされた括弧に対して10段階の異な<br>
る色をつける。色づけ段階の多さのため、rainbow モード自身が ctermfg とguifg を<br>
使ってハイライトを指定する (rainbow モードでない場合はそうではない)。それゆえ、<br>
ハイライトグループを使う普通のカラースキームの影響を受けない。実際にどうハイラ<br>
イトされるかはdark/bright の設定 (<a class="Identifier" href="options.html#'bg'">|'bg'|</a>&nbsp;を参照) による。<br>
<br>
<br>
<span class="Statement">LITE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#lite.vim" name="lite.vim">*lite.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-lite-syntax" name="ft-lite-syntax">*ft-lite-syntax*</a><br>
<br>
lite構文ハイライトには2つのオプションがある。<br>
<br>
文字列中でSQL構文ハイライトを行ってほしいならこうする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let lite_sql_query = 1</span><br>
<br>
シンクロナイズの最小行数はデフォルトで100になっている。他の値に変えたいなら<br>
&quot;lite_minlines&quot;をセットすればよい。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let lite_minlines = 200</span><br>
<br>
<br>
<span class="Statement">LPC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#lpc.vim" name="lpc.vim">*lpc.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-lpc-syntax" name="ft-lpc-syntax">*ft-lpc-syntax*</a><br>
<br>
LPCはシンプルでメモリ効率的な言語、Lars Pensj| Cの略である。LPCのファイル名は<br>
通常*.cである。これらのファイルをLPCと認識するとCプログラムのみを書くユーザの<br>
迷惑になる。LPC構文を使用したいなら、.vimrcでこの変数をセットすること:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let lpc_syntax_for_c = 1</span><br>
<br>
これでも適切に動作しないCまたはLPCのファイルに対してはモードラインを使うこと。<br>
LPCファイルには:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// vim&#0058;set ft=lpc:<br>
<br>
LPCと認識されてしまうCファイルには:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// vim&#0058;set ft=c:<br>
<br>
変数をセットしたくないなら全てのLPCファイルでモードラインを使うこと。<br>
<br>
LPCには複数の実装がある。我々はもっとも広く使われているものをサポートしたいと<br>
思っている。デフォルトのLPC文法はMudOSシリーズ用である。MudOS v22以前を使って<br>
いるなら、次をセットすることによりsensible モディファイヤをオフにし、v22以降の<br>
新しいefunを無効にするとよい。MudOSの最新版を使っているときはこの変数をセット<br>
しないこと:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let lpc_pre_v22 = 1</span><br>
<br>
LPCのLpMud 3.2シリーズには:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let lpc_compat_32 = 1</span><br>
<br>
LPCのLPC4シリーズには:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let lpc_use_lpc4_syntax = 1</span><br>
<br>
LPCのuLPCシリーズには:<br>
uLPCはPike用に開発されている。なのでPike構文を代わりに使い、ソースファイルの名<br>
前を.pikeとすること。<br>
<br>
<br>
<span class="Statement">LUA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#lua.vim" name="lua.vim">*lua.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-lua-syntax" name="ft-lua-syntax">*ft-lua-syntax*</a><br>
<br>
Lua 構文ファイルはバージョン 4.0, 5.0, 5.1, 5.2 に対して使える (5.2 がデフォル<br>
ト) グローバル変数 lua_version と lua_subversion を設定することでバージョンを<br>
指定することができる。例えば、Lua 5.1 の構文ハイライトを有効にするには次のよう<br>
に変数を設定する:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let lua_version = 5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let lua_subversion = 1<br>
<br>
<br>
<span class="Statement">MAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#mail.vim" name="mail.vim">*mail.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-mail.vim" name="ft-mail.vim">*ft-mail.vim*</a><br>
<br>
Vimはemailの標準的な要素(ヘッダ、シグネチャ、引用文、URL / emailアドレス)の全<br>
てをハイライトする。標準的な慣習に従い、シグネチャは、&quot;--&quot;とそれに続く任意個の<br>
空白、そして改行のみからなる行で始まる。<br>
<br>
Vimは']', '}', '|', '&gt;'で始まる行または'&gt;'が続く単語を引用文とみなす。引用文中<br>
のヘッダとシグネチャについては、テキストが'&gt;'(1個のスペースが続いてもよい)で引<br>
用された場合のみハイライトする。<br>
<br>
デフォルトではmail.vimは先頭表示行の100行前までの構文をシンクロナイズさせる。<br>
遅いマシンを使っていて、一般的に短いヘッダのemailを扱っているなら、これをより<br>
小さい値に変えることが出来る:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:let mail_minlines = 30</span><br>
<br>
<br>
<span class="Statement">MAKE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#make.vim" name="make.vim">*make.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-make-syntax" name="ft-make-syntax">*ft-make-syntax*</a><br>
<br>
Makefileではエラーを見つけやすくするためにコマンドがハイライトされる。しかし、<br>
これは色が多すぎるかもしれない。この機能をオフにするにはこうする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let make_no_commands = 1</span><br>
<br>
<br>
<span class="Statement">MAPLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#maple.vim" name="maple.vim">*maple.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-maple-syntax" name="ft-maple-syntax">*ft-maple-syntax*</a><br>
<br>
Waterloo Maple IncによるMaple Vは記号代数をサポートしている。その言語はユーザ<br>
によって選択的にロードされる関数のパッケージをたくさんサポートしている。Maple<br>
V release 4で供給される標準的なパッケージセットの関数がユーザの判断によって強<br>
調される。ユーザは.vimrcに以下を書くと、全てのパッケージ関数がハイライトされる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let mvpkg_all= 1</span><br>
<br>
あるいは以下の表から任意のサブセット変数／パッケージを選んで.vimrcファイル中で<br>
その変数を1にセットしてもよい($VIMRUNTIME/syntax/syntax.vimを読み込む前に行う<br>
必要がある)。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maple V パッケージ関数選択肢の表<br>
<span class="Comment">&nbsp;&nbsp;mv_DEtools&nbsp;&nbsp;&nbsp;&nbsp; mv_genfunc&nbsp;&nbsp;&nbsp;&nbsp; mv_networks&nbsp;&nbsp;&nbsp;&nbsp; mv_process</span><br>
<span class="Comment">&nbsp;&nbsp;mv_Galois&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mv_geometry&nbsp;&nbsp;&nbsp;&nbsp;mv_numapprox&nbsp;&nbsp;&nbsp;&nbsp;mv_simplex</span><br>
<span class="Comment">&nbsp;&nbsp;mv_GaussInt&nbsp;&nbsp;&nbsp;&nbsp;mv_grobner&nbsp;&nbsp;&nbsp;&nbsp; mv_numtheory&nbsp;&nbsp;&nbsp;&nbsp;mv_stats</span><br>
<span class="Comment">&nbsp;&nbsp;mv_LREtools&nbsp;&nbsp;&nbsp;&nbsp;mv_group&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mv_orthopoly&nbsp;&nbsp;&nbsp;&nbsp;mv_student</span><br>
<span class="Comment">&nbsp;&nbsp;mv_combinat&nbsp;&nbsp;&nbsp;&nbsp;mv_inttrans&nbsp;&nbsp;&nbsp;&nbsp;mv_padic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mv_sumtools</span><br>
<span class="Comment">&nbsp;&nbsp;mv_combstruct mv_liesymm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mv_plots&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mv_tensor</span><br>
<span class="Comment">&nbsp;&nbsp;mv_difforms&nbsp;&nbsp;&nbsp;&nbsp;mv_linalg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mv_plottools&nbsp;&nbsp;&nbsp;&nbsp;mv_totorder</span><br>
<span class="Comment">&nbsp;&nbsp;mv_finance&nbsp;&nbsp;&nbsp;&nbsp; mv_logic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mv_powseries</span><br>
<br>
<br>
<span class="Statement">MATHEMATICA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#mma.vim" name="mma.vim">*mma.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-mma-syntax" name="ft-mma-syntax">*ft-mma-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#ft-mathematica-syntax" name="ft-mathematica-syntax">*ft-mathematica-syntax*</a><br>
<br>
次を .vimrc に書いておかないかぎり、空の *.m ファイルは自動的に Matlab のファ<br>
イルであるとみなされる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let filetype_m = &quot;mma&quot;</span><br>
<br>
<br>
<span class="Statement">MOO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#moo.vim" name="moo.vim">*moo.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-moo-syntax" name="ft-moo-syntax">*ft-moo-syntax*</a><br>
<br>
式の中でCスタイルのコメントを使っていて、それがハイライトを乱している場合は、C<br>
スタイル用の拡張マッチ(これは遅い!)を使うことが出来る:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let moo_extended_cstyle_comments = 1</span><br>
<br>
文字列中の代名詞置換パターンのハイライトを無効化させるには:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let moo_no_pronoun_sub = 1</span><br>
<br>
正規表現演算子'%l'のハイライトと文字列中の'%('と'%)'のマッチを無効化させるには:<br>
<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let moo_no_regexp = 1</span><br>
<br>
対応していないダブルクォートを認識してエラーとしてハイライトすることが出来る:<br>
<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let moo_unmatched_quotes = 1</span><br>
<br>
組み込みプロパティ(.name, .location, .programmerなど)をハイライトするには :<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let moo_builtin_properties = 1</span><br>
<br>
未知の組み込み関数を認識してエラーとしてハイライトすることが出来る。このオプショ<br>
ンを使うなら、mooKnownBuiltinFunctionグループに自分自身の拡張を加えること。こ<br>
のオプションを有効化するには:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let moo_unknown_builtin_functions = 1</span><br>
<br>
既知の組み込み関数のリストにsprintf()を加える例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn keyword mooKnownBuiltinFunction sprintf contained</span><br>
<br>
<br>
<span class="Statement">MSQL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#msql.vim" name="msql.vim">*msql.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-msql-syntax" name="ft-msql-syntax">*ft-msql-syntax*</a><br>
<br>
msql構文ハイライトには2つのオプションがある。<br>
<br>
文字列中でSQL構文ハイライトをさせるにはこうする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let msql_sql_query = 1</span><br>
<br>
シンクロナイズは、minlinesはデフォルトで100になっている。この値を変えるには、<br>
&quot;msql_minlines&quot;の望む値にすればよい。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let msql_minlines = 200</span><br>
<br>
<br>
<span class="Statement">NCF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#ncf.vim" name="ncf.vim">*ncf.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-ncf-syntax" name="ft-ncf-syntax">*ft-ncf-syntax*</a><br>
<br>
NCF構文ハイライトには1つのオプションがある。<br>
<br>
ncf.vimによって認識されない文をエラーとしてハイライトさせるにはこうする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let ncf_highlight_unknowns = 1</span><br>
<br>
これらをエラーとしてハイライトさせたくない場合は、この変数をセットしないでおく。<br>
<br>
<br>
<span class="Statement">NROFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#nroff.vim" name="nroff.vim">*nroff.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-nroff-syntax" name="ft-nroff-syntax">*ft-nroff-syntax*</a><br>
<br>
nroff構文ファイルはそのままでAT&amp;T n/troffに対応している。構文ファイルに含まれ<br>
ているGNU groff拡張機能を使うには、それを有効化する必要がある。<br>
<br>
例えば、LinuxとBSDディストリビューションは、デフォルトではテキスト処理パッケー<br>
ジとしてgroffを使う。groff用の拡張構文ハイライト機能を有効化するには、次のオプ<br>
ションを初期化ファイルに加える:<br>
<br>
<span class="Comment">&nbsp;&nbsp;:let b:nroff_is_groff = 1</span><br>
<br>
groffは、Solarisでまだ使われているかもしれない古いAT&amp;T n/troffとは異なる。<br>
groffのマクロとリクエスト名は2文字以上の長さであってもよく、言語プリミティブに<br>
拡張がされている。例えば、AT&amp;T troffではリクエスト\(yrを使い、2桁の数で年にア<br>
クセスする。groffでは互換性のために同じリクエストを使うことも出来るし、または<br>
groffネイティブの構文,\[yr]を使うことも出来る。さらに、\[year]として4桁の年を<br>
直接使うことも出来る。マクロリクエストは2文字以上の長さであってもよい。例え<br>
ば、GNU mmはverbatim環境を作るのに&quot;.VERBON&quot;と&quot;.VERBOFF&quot;というリクエストを受け<br>
つける。<br>
<br>
g/troffによって得られる最良の整形された出力を得るには、スペースと句読点に関す<br>
るいくつかの単純なルールに従うべきである。<br>
<br>
1. 行の末尾に空のスペースを置かないこと<br>
<br>
2. 文末のピリオド、エクスクラメーションマークなどの後にはちょうど1個のスペース<br>
&nbsp;&nbsp; を置くこと。<br>
<br>
3. 後述の理由により、全てのピリオドの後に改行(carriage return)を置くとよい。<br>
<br>
これらの妙なtipsの理由は、g/n/troffが改行に、これらのルールに従わないとすぐに<br>
混乱してしまうアルゴリズムを使っているためである。<br>
<br>
<br>
troffはTeXと違い、段落ごとでなく行ごとにテキストを書き込む。さらに、glueや<br>
stretchの概念を持たず、入力に水平、垂直の空白があると全てそのまま出力される。<br>
<br>
それゆえ、最終的なドキュメントで意図する以上の空白を文と文の間にはさまないよう<br>
に注意すること。この理由のため、全ての句読点記号の後すぐに改行を入れるという習<br>
慣がある。最終的に処理された出力が「一様な」テキストになってほしければ、入力の<br>
テキストで正しくスペースを置いておく必要がある。行末の空白と句読点の後の2個以<br>
上の空白をエラーとしてハイライトしたいならこうする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;:let nroff_space_errors = 1</span><br>
<br>
正しい活字組みと干渉するかもしれないが、余分な空白や他のエラーを検出するもう1<br>
つの方法は、設定ファイル中で構文グループ&quot;nroffDefinition&quot;と&quot;nroffDefSpecial&quot;に<br>
目立つハイライト定義を定義することである。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;hi def nroffDefinition term=italic cterm=italic gui=reverse</span><br>
<span class="Comment">&nbsp;&nbsp;hi def nroffDefSpecial term=italic,bold cterm=italic,bold</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ gui=reverse,bold</span><br>
<br>
ソースファイル中のプリプロセッサのエントリをセクションマーカーと同じくらい容易<br>
に表示させたいなら、.vimrc中で次のオプションを有効化する:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let b:preprocs_as_sections = 1</span><br>
<br>
同様に、構文ファイルはmsパッケージ中の拡張段落マクロ(.XP)用の余分な段落マーカー<br>
も含んでいる。<br>
<br>
最後に、構文ファイル<a class="Identifier" href="syntax.html#groff.vim">|groff.vim|</a>が存在する。これはデフォルトでfile basisとグ<br>
ローバルの両方でgroff構文ハイライトすることができる。<br>
<br>
<br>
<span class="Statement">OCAML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#ocaml.vim" name="ocaml.vim">*ocaml.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-ocaml-syntax" name="ft-ocaml-syntax">*ft-ocaml-syntax*</a><br>
<br>
OCaml構文ファイルは以下の拡張子を持つファイルに対応している: .ml, .mli, .mll<br>
.mly。以下の変数をセットすると、標準的OCaml構文からcamlp4プリプロセッサでサ<br>
ポートされている修正構文に切り替えることが出来る:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let ocaml_revised = 1</span><br>
<br>
以下の変数をセットすると&quot;end&quot;をエラーとしてハイライトするのをやめることが出来<br>
る。これはVimがシンクロナイズできないほど長い構造を含むソースのとき便利である:<br>
<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let ocaml_noend_error = 1</span><br>
<br>
<br>
<span class="Statement">PAPP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#papp.vim" name="papp.vim">*papp.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-papp-syntax" name="ft-papp-syntax">*ft-papp-syntax*</a><br>
<br>
PApp構文ファイルは.pappファイルと、その小さな拡張、トップレベルのファイル<br>
フォーマットとしてxmlを用いたperl/xml/html/その他の混合である.pxml, .pxslファ<br>
イルを扱う。デフォルトでは、phtmlやpxmlセクションの内側の全ては埋め込みプリプ<br>
ロセッサコマンドつきの文字列として扱われる。次の変数を初期化ファイルで設定する<br>
とphtmlセクションの内側のhtmlコードを構文ハイライトしようとする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let papp_include_html=1</span><br>
<br>
しかしこれは比較的遅く、実用的に編集するにはカラフルすぎる。<br>
<br>
構文ファイルpapp.vimの最新版は、通常以下で得られる。<br>
<span class="Constant"><a href="http://papp.plan9.de">http://papp.plan9.de</a></span><br>
<br>
<br>
<span class="Statement">PASCAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#pascal.vim" name="pascal.vim">*pascal.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-pascal-syntax" name="ft-pascal-syntax">*ft-pascal-syntax*</a><br>
<br>
&quot;*.p&quot;にマッチするファイルのタイプはProgressかPascalである。自動判別が機能しな<br>
いなら、またはProgressファイルを一切編集しないとわかっているなら、これをvimrc<br>
ファイルに書くといい:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :let filetype_p = &quot;pascal&quot;</span><br>
<br>
Pascal構文ファイルはTurbo Pascal, Free Pascal CompilerとGNU Pascal Compiler<br>
で提供される拡張に対応するための拡張が施されてきた。Delphiのキーワードもサポー<br>
トされている。デフォルトではTurbo Pascal 7.0の機能が有効化されている。標準的な<br>
Pascalのキーワードだけを使いたいなら、次の行を初期化ファイルに加えること:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :let pascal_traditional=1</span><br>
<br>
Delphi固有の構文(1行コメント、キーワード等)を有効化したいなら:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :let pascal_delphi=1</span><br>
<br>
<br>
オプションpascal_symbol_operatorは、+, *などのような演算子記号をOperatorの色を<br>
使って表示するどうかを制御する。演算子記号を色づけするには、次の行を初期化ファ<br>
イルに加えること:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :let pascal_symbol_operator=1</span><br>
<br>
いくつかの関数はデフォルトでハイライトされる。これをオフにするには:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :let pascal_no_functions=1</span><br>
<br>
さらに、いくつかのコンパイラ用に個別の変数がある。pascal_delphi,<br>
pascal_gpc, pascal_fpcがある。デフォルトの拡張はTurbo Pascalに合うようになって<br>
いる。<br>
<br>
<span class="Comment">&nbsp;&nbsp; :let pascal_gpc=1</span><br>
<br>
または<br>
<br>
<span class="Comment">&nbsp;&nbsp; :let pascal_fpc=1</span><br>
<br>
文字列が1行で定義されるものとするなら、変数pascal_one_line_string variableを定<br>
義するとよい。<br>
<br>
<span class="Comment">&nbsp;&nbsp; :let pascal_one_line_string=1</span><br>
<br>
タブ文字が好きでないなら、変数pascal_no_tabsをセットするとよい。するとタブがエ<br>
ラーとしてハイライトされる。<br>
<br>
<span class="Comment">&nbsp;&nbsp; :let pascal_no_tabs=1</span><br>
<br>
<br>
<span class="Statement">PERL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#perl.vim" name="perl.vim">*perl.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-perl-syntax" name="ft-perl-syntax">*ft-perl-syntax*</a><br>
<br>
perl用の構文ハイライトにはたくさんのオプションがある。<br>
<br>
PODファイルやPODセグメントを使っているなら、こうするとよいかもしれない:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let perl_include_pod = 1</span><br>
<br>
パースの複雑さを軽減するために (そしてパフォーマンスを上げるために) 、変数名と<br>
内容のパースにおける2つの要素をオフにすることができる。<br>
<br>
変数名と関数名中のパッケージ参照('$PkgName::VarName'中の'PkgName::'のような)を<br>
他の名前と区別しないようにするには次のようにする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let perl_no_scope_in_variables = 1</span><br>
<br>
(Vim 6.x では違う方法だった: &quot;perl_want_scope_in_variables&quot; を設定するとこの機<br>
能が有効になった)<br>
<br>
'@{$<span class="Special">{&quot;foo&quot;}</span>}'のように複雑なものをパースさせたくないなら次のようにする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let perl_no_extended_vars = 1</span><br>
<br>
(Vim 6.x では違う方法だった: &quot;perl_extended_vars&quot; を設定するとこの機能が有効に<br>
なった)<br>
<br>
文字列の色づけは変更できる。デフォルトでは文字列とqq friendsは第1行と同じよう<br>
にハイライトされる。変数perl_string_as_statementをセットすると第2行のようにハ<br>
イライトされる。<br>
<br>
&nbsp;&nbsp; &quot;hello world!&quot;; qq|hello world|;<br>
&nbsp;&nbsp; ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^<span class="Special">N</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unlet perl_string_as_statement)<br>
&nbsp;&nbsp; S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^SN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let perl_string_as_statement)<br>
<br>
(^ = perlString, S = perlStatement,&nbsp;<span class="Special">N</span>&nbsp;= None at all)<br>
<br>
シンクロナイズには3つのオプションがある。最初の2つは、シンクロナイズのトリガー<br>
の一部をオフにするもので、ハイライトが適切に機能しないときのみ必要になる。スク<br>
ロール中に突然スクリーン全体の色がすっかり変わってしまったらこれらのうち1つを<br>
オフにしてみること。その誤りを引き起こした行を特定できるなら、それを知らせてく<br>
ださい。<br>
<br>
1つのトリガーは&quot;^\s*sub\s*&quot;に関するもので、もう1つはほぼ&quot;^[$@%]&quot;に関するもので<br>
ある。<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let perl_no_sync_on_sub</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let perl_no_sync_on_global_var</span><br>
<br>
以下のようにして、どこから構文ハイライトを始めるかの最大距離を設定できる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let perl_sync_dist = 100</span><br>
<br>
perlで折りたたみを使いたいならperl_foldをセットすること:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :let perl_fold = 1</span><br>
<br>
if 文などでも同様にブロックを折り畳みたければ、次のように設定する:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let perl_fold_blocks = 1</span><br>
<br>
perl の折り畳みが有効になっているとき、package や sub を折り畳みたくなければ、<br>
対応する変数を設定する:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unlet perl_nofold_packages</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unlet perl_nofold_subs</span><br>
<br>
<br>
<br>
PHP3 and PHP4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#php.vim" name="php.vim">*php.vim*</a>&nbsp;<a class="Constant" href="syntax.html#php3.vim" name="php3.vim">*php3.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-php-syntax" name="ft-php-syntax">*ft-php-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#ft-php3-syntax" name="ft-php3-syntax">*ft-php3-syntax*</a><br>
<br>
[注意: これは以前は&quot;php3&quot;と呼ばれていた。しかし現在はphp4もサポートしているの<br>
で&quot;php&quot;と名前が変更された]<br>
<br>
php用の構文ハイライトには以下のオプションがある。<br>
<br>
文字列中でSQL構文ハイライトを行いたいなら:<br>
<br>
<span class="Comment">&nbsp;&nbsp;let php_sql_query = 1</span><br>
<br>
Baselibメソッドのハイライトを行いたいなら:<br>
<br>
<span class="Comment">&nbsp;&nbsp;let php_baselib = 1</span><br>
<br>
文字列中でHTML構文ハイライトを行いたいなら:<br>
<br>
<span class="Comment">&nbsp;&nbsp;let php_htmlInStrings = 1</span><br>
<br>
古いカラースタイルを使いたいなら:<br>
<br>
<span class="Comment">&nbsp;&nbsp;let php_oldStyle = 1</span><br>
<br>
ASPスタイルのショートタグを有効化したいなら:<br>
<br>
<span class="Comment">&nbsp;&nbsp;let php_asp_tags = 1</span><br>
<br>
ショートタグを無効化したいなら:<br>
<br>
<span class="Comment">&nbsp;&nbsp;let php_noShortTags = 1</span><br>
<br>
] や ) の対応エラーをハイライトしたいなら:<br>
<br>
<span class="Comment">&nbsp;&nbsp;let php_parent_error_close = 1</span><br>
<br>
対応する閉じ括弧がない開き括弧( や [が存在する場合、php終了タグをスキップさせ<br>
たいなら:<br>
<br>
<span class="Comment">&nbsp;&nbsp;let php_parent_error_open = 1</span><br>
<br>
クラスや関数の折り畳みを有効化するには:<br>
<br>
<span class="Comment">&nbsp;&nbsp;let php_folding = 1</span><br>
<br>
シンクロナイズ方法を選ぶには:<br>
<br>
<span class="Comment">&nbsp;&nbsp;let php_sync_method = x</span><br>
<br>
x = -1 で検索によるシンクロナイズ(デフォルト)<br>
x &gt; 0 少なくともx行上までシンクロナイズ<br>
x = 0 最初からシンクロナイズ<br>
<br>
<br>
<span class="Statement">PLAINTEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#plaintex.vim" name="plaintex.vim">*plaintex.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-plaintex-syntax" name="ft-plaintex-syntax">*ft-plaintex-syntax*</a><br>
<br>
TeX とは組版言語であり、plaintex は「素の」TeX に対して使われるファイルタイプ<br>
である。*.tex ファイルを決して素の TeX と認識してほしくないならば<br>
<a class="Identifier" href="filetype.html#ft-tex-plugin">|ft-tex-plugin|</a>&nbsp;を参照。<br>
<br>
この構文ファイルは次のオプションを持つ<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:plaintex_delimiters = 1</span><br>
<br>
角括弧 &quot;[]&quot; と波括弧 &quot;{}&quot; をハイライトさせるには上の変数を設定する。<br>
<br>
<span class="Statement">PPWIZARD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#ppwiz.vim" name="ppwiz.vim">*ppwiz.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-ppwiz-syntax" name="ft-ppwiz-syntax">*ft-ppwiz-syntax*</a><br>
<br>
PPWizardはHTMLとOS/2 INFファイル用のプリプロセッサである。<br>
<br>
構文ファイルは以下のオプションを持つ:<br>
<br>
- ppwiz_highlight_defs : PPWizardの定義についてのハイライトモードを決める。<br>
&nbsp;&nbsp;とりうる値は<br>
<br>
&nbsp;&nbsp;ppwiz_highlight_defs = 1 : #define 文においてその内容の色を保つ(例. PPWizard<br>
&nbsp;&nbsp;マクロと変数)<br>
<br>
&nbsp;&nbsp;ppwiz_highlight_defs = 2 : 行継続記号を除き、#defineと#evaluate文が単一の色<br>
&nbsp;&nbsp;で表示される。<br>
<br>
&nbsp;&nbsp;ppwiz_highlight_defsのデフォルトは1である。<br>
<br>
- ppwiz_with_html : この値が1(デフォルト)なら、HTMLコードをハイライトする。0なら<br>
&nbsp;&nbsp;HTMLコードを通常のテキストのように扱う。<br>
<br>
<br>
<span class="Statement">PHTML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#phtml.vim" name="phtml.vim">*phtml.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-phtml-syntax" name="ft-phtml-syntax">*ft-phtml-syntax*</a><br>
<br>
phtml用の構文ハイライトには2つのオプションがある。<br>
<br>
文字列中でSQL構文ハイライトをさせたいならこうする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let phtml_sql_query = 1</span><br>
<br>
シンクロナイズについては、minlinesのデフォルトは100になっている。他の値にした<br>
いなら&quot;phtml_minlines&quot;を望む値にセットすればよい。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let phtml_minlines = 200</span><br>
<br>
<br>
<span class="Statement">POSTSCRIPT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#postscr.vim" name="postscr.vim">*postscr.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-postscr-syntax" name="ft-postscr-syntax">*ft-postscr-syntax*</a><br>
<br>
PostScript用の構文ハイライトにはいくつかのオプションがある。<br>
<br>
まず、どのバージョンのPostScript言語をハイライトするかである。現在のところ、言<br>
語の3つのバージョン、あるいはレベルが定義されている。レベル1はオリジナルの基本<br>
バージョンで、レベル2のリリース以前のすべての拡張を含んでいる。レベル2はもっと<br>
も一般的なバージョンで、レベル3リリース以前のすべての拡張を含んでいる。レベル3<br>
は現在のところサポートされている中でもっともレベルが高い。次のように変数<br>
postscr_levelを定義することによって、PostScript言語のどのレベルをハイライトす<br>
るか選ぶことができる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let postscr_level=2</span><br>
<br>
この変数が定義されていないときはデフォルトの2(レベル2)になる。これが現在のとこ<br>
ろもっとも普及しているためである。<br>
<br>
すべてのPSインタープリタがその言語レベルのすべての言語機能をサポートしているわ<br>
けではないことに注意。とくに、PSファイルの先頭の%!PS-Adobe-3.0は現在の<br>
PostScriptがレベル3であることを示すわけではない!<br>
<br>
以下のように変数postscr_displayを定義すると、Display PostScriptの言語機能もハ<br>
イライトさせることができる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let postscr_display=1</span><br>
<br>
以下のように変数postscr_ghostscriptを定義すると、Ghostscript固有の言語機能もハ<br>
イライトさせることができる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let postscr_ghostscript=1</span><br>
<br>
PostScriptはたくさんの定義済み要素を持つ巨大な言語である。これらの要素すべてを<br>
ハイライトすると便利であるが、そうすると遅いマシンではVimの動作が遅くなってし<br>
まう。マシンフレンドリーにするために、デフォルトではフォント名と文字エンコーディ<br>
ングはハイライトされない、これらをハイライトさせるには、以下の変数のどちらか<br>
または両方をセットすること:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let postscr_fonts=1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let postscr_encodings=1</span><br>
<br>
and、or、notのハイライトについて、スタイル上のオプションが存在する。PostScript<br>
では、これらの演算子の機能はオペランドの型に依存する。オペランドが両方ブール型<br>
なら論理演算子となり、両方整数型なら2項演算子となる。2項演算子と論理演算子を区<br>
別してハイライトすることができるので、どちらにしてもこれらはハイライトされなけ<br>
ればならない。デフォルトではどちらも論理演算子としてハイライトされる。変数<br>
postscr_andornot_binaryを定義すると、どちらも2項演算子としてハイライトされる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let postscr_andornot_binary=1</span><br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#ptcap.vim" name="ptcap.vim">*ptcap.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-printcap-syntax" name="ft-printcap-syntax">*ft-printcap-syntax*</a><br>
PRINTCAP + TERMCAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#ft-ptcap-syntax" name="ft-ptcap-syntax">*ft-ptcap-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#ft-termcap-syntax" name="ft-termcap-syntax">*ft-termcap-syntax*</a><br>
<br>
この構文ファイルはprintcapとtermcapデータベースに適用される。<br>
<br>
*printcap*または*termcap*というパターンにマッチしないprintcap/termcapファイル<br>
を認識させるためには、ファイル<a class="Identifier" href="syntax.html#myfiletypefile">|myfiletypefile|</a>において、あなたのシステムに合っ<br>
たパターンを追加しなければならない。これらのパターンには、変数&quot;b:ptcap_type&quot;を<br>
&quot;print&quot;か&quot;term&quot;のどちらかにセットしなければならない。するとオプション<br>
<a class="Type" href="options.html#'filetype'">'filetype'</a>の値がptcapになる。<br>
<br>
例えば、/etc/termcaps/以下の全てのファイルをtermcapファイルと識別させるように<br>
するには次を書き加える:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = &quot;term&quot; |</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ set filetype=ptcap</span><br>
<br>
上方向にスクロールしているときハイライトがおかしくなり、それが<span class="Special">CTRL-L</span>で再描画す<br>
ると直るようなら、変数&quot;ptcap_minlines&quot;の値を大きくしてみるとよい:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :let ptcap_minlines = 50</span><br>
<br>
(デフォルトは20行)<br>
<br>
<br>
<span class="Statement">PROGRESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#progress.vim" name="progress.vim">*progress.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-progress-syntax" name="ft-progress-syntax">*ft-progress-syntax*</a><br>
<br>
&quot;*.w&quot;にマッチするファイルのタイプはProgressかCWEBである。自動判別がうまく機能<br>
しないなら、またはcwebファイルを一切編集しないとわかっているなら、次をvimrcに<br>
加えるとよい:<br>
<span class="Comment">&nbsp;&nbsp; :let filetype_w = &quot;progress&quot;</span><br>
同じことが&quot;*.i&quot;(アセンブリでもありうる)と&quot;*.p&quot;(Pascalでもありうる)にもいえる。<br>
アセンブリとPascalを使わないとわかっているならこれを使うこと:<br>
<span class="Comment">&nbsp;&nbsp; :let filetype_i = &quot;progress&quot;</span><br>
<span class="Comment">&nbsp;&nbsp; :let filetype_p = &quot;progress&quot;</span><br>
<br>
<br>
<br>
<span class="Statement">PYTHON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#python.vim" name="python.vim">*python.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-python-syntax" name="ft-python-syntax">*ft-python-syntax*</a><br>
<br>
Python構文ハイライトをコントロールするオプションは4つある。<br>
<br>
数字のハイライト:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let python_highlight_numbers = 1</span><br>
<br>
組み込み関数のハイライト:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let python_highlight_builtins = 1</span><br>
<br>
標準例外のハイライト:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let python_highlight_exceptions = 1</span><br>
<br>
行末の空白と、スペースとタブの混在をハイライト:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let python_highlight_space_errors = 1</span><br>
<br>
全てのハイライトを有効化させるには(上の3つのオプションをセットするのと同じ):<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let python_highlight_all = 1</span><br>
<br>
<br>
<span class="Statement">QUAKE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#quake.vim" name="quake.vim">*quake.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-quake-syntax" name="ft-quake-syntax">*ft-quake-syntax*</a><br>
<br>
Quake構文定義はQuakeエンジンのどれかに基づくほとんど全てのFPS(First Person<br>
Shooter)用に対応するはずである。しかし3つのゲーム(Quake, Quake 2, Quake 3<br>
Arena)間でコマンド名が少々異なる。そのため、3つのグローバル変数により、どのコ<br>
マンドが有効であるか指定できるようになっている。3つの変数には次のような効果が<br>
ある:<br>
<br>
Quakeでのみ利用可能なコマンドをハイライトするように設定:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let quake_is_quake1 = 1</span><br>
<br>
Quake 2でのみ利用可能なコマンドをハイライトするように設定:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let quake_is_quake2 = 1</span><br>
<br>
Quake 3 Arenaでのみ利用可能なコマンドをハイライトするように設定:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let quake_is_quake3 = 1</span><br>
<br>
これら3つのコマンドを自由に組み合わせることが出来る。しかしゲームで利用できな<br>
いコマンドもハイライトしてしまうかもしれない。<br>
<br>
<br>
<span class="Statement">READLINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#readline.vim" name="readline.vim">*readline.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-readline-syntax" name="ft-readline-syntax">*ft-readline-syntax*</a><br>
<br>
readlineライブラリは主としてBASHシェルで使われ、BASHはかなりの数のコマンドとオ<br>
プションを追加している。これらの項目を同様にハイライトするには次を<a class="Identifier" href="starting.html#vimrc">|vimrc|</a>に加<br>
えるか、readline構文ファイルを読み込む前にこれをタイプすればよい:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let readline_has_bash = 1</span><br>
<br>
こうするとBASH(バージョン2.05a以降。一部それ以前)が追加するコマンドもハイライ<br>
トするようになる。<br>
<br>
<br>
<span class="Statement">REXX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#rexx.vim" name="rexx.vim">*rexx.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-rexx-syntax" name="ft-rexx-syntax">*ft-rexx-syntax*</a><br>
<br>
上方向にスクロールしているときにハイライトがおかしくなり、それが<span class="Special">CTRL-L</span>で再描画<br>
すると直るようなら、変数&quot;rexx_minlines&quot;の値を大きくしてみるとよい:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let rexx_minlines = 50</span><br>
こうすると構文シンクロナイズが画面最上行の50行前から始まるようになる。値を大き<br>
くすることの欠点は、再描画が遅くなることである。<br>
<br>
Vim は &quot;.r&quot; ファイルのタイプを推測しようとします。(コメント行から) タイプを特<br>
定できなかった場合、デフォルトは &quot;r&quot; です。デフォルトを rexx にするには次の行<br>
を .vimrc に追加します:&nbsp;&nbsp;<a class="Constant" href="syntax.html#g:filetype_r" name="g:filetype_r">*g:filetype_r*</a><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:filetype_r = &quot;r&quot;</span><br>
<br>
<br>
<span class="Statement">RUBY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#ruby.vim" name="ruby.vim">*ruby.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-ruby-syntax" name="ft-ruby-syntax">*ft-ruby-syntax*</a><br>
<br>
Ruby構文ハイライトにはたくさんのオプションがある。<br>
<br>
デフォルトではキーワード&quot;end&quot;はそれに対応するブロック開始文にしたがって色づけ<br>
される。この機能は便利だが、コストがかかる。再描画が遅くなったら(または色機能<br>
の貧弱なターミナルを使っているなら)変数&quot;ruby_no_expensive&quot;を定義することによっ<br>
てこの機能をオフにできる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let ruby_no_expensive = 1</span><br>
<br>
この場合すべての制御キーワードに同じ色が使われる。<br>
<br>
この機能を有効化したいが、上にスクロールしているときにハイライトがおかしくなり、<br>
それが<span class="Special">CTRL-L</span>で再描画すると直るようなら、変数&quot;ruby_minlines&quot;を50以上の値にセッ<br>
トしてみるとよい:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let ruby_minlines = 100</span><br>
<br>
理想的にはこの値はファイル中の最も大きいクラスやモジュールの長さよりも大きくし<br>
ておくとよい。<br>
<br>
rubyIdentifierを取り除くと、特別な識別子がハイライトされなくなる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:hi link rubyIdentifier NONE</span><br>
<br>
これによって &quot;ConstantName&quot;, &quot;$global_var&quot;, &quot;@@class_var&quot;, &quot;@instance_var&quot;,<br>
&quot;| block_param |&quot;, &quot;:symbol&quot; のような特別な識別子がハイライトされなくなる。<br>
<br>
Kernel, Module, Object などの重要なメソッドはデフォルトでハイライトされる。<br>
&quot;ruby_no_special_methods&quot; を定義するとこれらのハイライトがされなくなる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let ruby_no_special_methods = 1</span><br>
<br>
これによって &quot;require&quot;, &quot;attr&quot;, &quot;private&quot;, &quot;raise&quot;, &quot;proc&quot; などの重要なメソッ<br>
ドのハイライトがされなくなる。<br>
<br>
Rubyの演算子をハイライトすることができる。これは&quot;ruby_operators&quot;を定義すると有<br>
効になる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let ruby_operators = 1</span><br>
<br>
&quot;ruby_space_errors&quot; を定義するとホワイトスペースのエラーがハイライトされるよう<br>
になる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let ruby_space_errors = 1</span><br>
<br>
これによって行末のホワイトスペースやタブ文字の前のスペース文字がエラーとして強<br>
調されるようになる。これは &quot;ruby_no_trail_space_error&quot; と<br>
&quot;ruby_no_tab_space_error&quot; を定義すると改善することができる。これらはそれぞれ行<br>
末のホワイトスペースとスペース文字の後のタブ文字を無視する。<br>
<br>
&quot;ruby_fold&quot; を定義すると折り畳みを有効にすることができる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let ruby_fold = 1</span><br>
<br>
これを定義すると、オプション&nbsp;<a class="Type" href="options.html#'foldmethod'">'foldmethod'</a>&nbsp;が &quot;syntax&quot; になり、クラス、モジュー<br>
ル、メソッド、コードブロック、ヒアドキュメント、コメントの折り畳みを行うように<br>
なる。<br>
<br>
&quot;ruby_no_comment_fold&quot;を定義すると複数行コメントの折り畳みを無効にできる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let ruby_no_comment_fold = 1</span><br>
<br>
<br>
<span class="Statement">SCHEME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#scheme.vim" name="scheme.vim">*scheme.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-scheme-syntax" name="ft-scheme-syntax">*ft-scheme-syntax*</a><br>
<br>
デフォルトでは R5RS のキーワードだけをハイライトし、正しくインデントする。<br>
<br>
変数 b:is_mzscheme または g:is_mzscheme が定義されていると、MzScheme 固有の設<br>
定が使われる。<br>
<br>
また、scheme.vim は Chicken Scheme-&gt;C コンパイラのキーワードにも対応している。<br>
それを有効にするには b:is_chicken または g:is_chicken を定義する。<br>
<br>
<br>
<span class="Statement">SDL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#sdl.vim" name="sdl.vim">*sdl.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-sdl-syntax" name="ft-sdl-syntax">*ft-sdl-syntax*</a><br>
<br>
SDL用のハイライトにはいくつかのキーワードが抜けているかもしれない。しかしSDLに<br>
はたくさんのキーワードがあるので、すべてに対応することはほとんど不可能である。<br>
<br>
新しい標準SDL-2000ではすべての識別子の大文字・小文字が区別される(以前はそうで<br>
はなかった)。また、すべてのキーワードが全部大文字または全部小文字であってもよ<br>
い。構文ハイライトにこれを反映させるには次の変数をセットすればよい:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let sdl_2000=1</span><br>
<br>
これはたくさんの新しいキーワードもセットする。古いキーワードを無効にするには(<br>
これはよい考えである)こうする:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let SDL_no_96=1</span><br>
<br>
インデントもおそらく不完全であるが、今のところ私はこれでとても満足している。<br>
<br>
<br>
<span class="Statement">SED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#sed.vim" name="sed.vim">*sed.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-sed-syntax" name="ft-sed-syntax">*ft-sed-syntax*</a><br>
<br>
タブをハイライトして通常の空白と区別しやすくするには、次の行をvimrcに書いて<br>
&quot;highlight_sedtabs&quot;を定義する(TODOと同じ構文グループが使われる)<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let highlight_sedtabs = 1</span><br>
<br>
(タブのハイライトは、検索パターン、置換テキスト、アドレス、<br>
Append/Change/Insertコマンドに含まれるテキストいずれかの中のタブにだけ適用され<br>
る)。このオプションを有効化するなら、タブ幅を1文字にするとよい。そうすると文字<br>
列中のタブの数を数えやすくなる。<br>
<br>
バグ:<br>
<br>
&nbsp;&nbsp;変換コマンド(y)は置換コマンドとまったく同様に扱われる。つまり、この構文ファ<br>
&nbsp;&nbsp;イルにおいては、変換は置換と同じフラグを受け取ると判断される。これは間違いで<br>
&nbsp;&nbsp;ある(変換は一切フラグを受け取らない)。これに関係したコマンドは非常に複雑な処<br>
&nbsp;&nbsp;理を要求するため(95パターン、もっともらしいパターンデリミタごとに1つ)、私は<br>
&nbsp;&nbsp;このバグを容認している。<br>
<br>
<br>
<span class="Statement">SGML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#sgml.vim" name="sgml.vim">*sgml.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-sgml-syntax" name="ft-sgml-syntax">*ft-sgml-syntax*</a><br>
<br>
SGMLファイル中のタグをハイライトする方法は以下のように動作する。<br>
<br>
開きタグ&lt;&gt;と閉じタグ&lt;/&gt;は異なる色がつけられる。これは意図されたものである。開<br>
きタグには'Function'の色が使われ、閉じタグには'Type'の色が使われる(これらがど<br>
う定義されているかを確かめたいならsyntax.vimを見ること)。<br>
<br>
登録されているタグ名はCの文と同じ方法で色づけされる。エラーを見つけやすくする<br>
ため、登録されていないタグ名は色づけされない。<br>
<br>
引数名(や属性名)も同様である。登録されている属性名は登録されていない属性名と異<br>
なる色がつけられる。<br>
<br>
いくつかのSGMLタグはテキストの外見を変更するのに使われる。以下のタグは構文ファ<br>
イルsgml.vimによって認識され、通常のテキストの表示法を変更する:<br>
&nbsp;<span class="Special">&lt;varname&gt;</span>&nbsp;<span class="Special">&lt;emphasis&gt;</span>&nbsp;<span class="Special">&lt;command&gt;</span>&nbsp;<span class="Special">&lt;function&gt;</span>&nbsp;<span class="Special">&lt;literal&gt;</span>&nbsp;<span class="Special">&lt;replaceable&gt;</span>&nbsp;<span class="Special">&lt;ulink&gt;</span><br>
&nbsp;<span class="Special">&lt;link&gt;</span>。<br>
<br>
そのテキストの表示法を変えたいなら以下の構文グループを再定義しなければならない<br>
:&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;- sgmlBold<br>
&nbsp;&nbsp;&nbsp;&nbsp;- sgmlBoldItalic<br>
&nbsp;&nbsp;&nbsp;&nbsp;- sgmlUnderline<br>
&nbsp;&nbsp;&nbsp;&nbsp;- sgmlItalic<br>
&nbsp;&nbsp;&nbsp;&nbsp;- sgmlLink for links<br>
<br>
この再定義を機能させるにはこれらすべてを再定義し、以下の変数をvimrc中で定義し<br>
なければならない(初期化の際にファイルが読み込まれる順序のため)<br>
<span class="Comment">&nbsp;&nbsp; let sgml_my_rendering=1</span><br>
<br>
この表示法を無効にしたければ次の行をvimrcに加える:<br>
<span class="Comment">&nbsp;&nbsp; let sgml_no_rendering=1</span><br>
<br>
(Claudio Fleiner &lt;claudio@fleiner.com&gt;によるhtml.vimのヘルプテキストから一部借<br>
用した)<br>
<br>
<br>
<span class="Statement">SH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#sh.vim" name="sh.vim">*sh.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-sh-syntax" name="ft-sh-syntax">*ft-sh-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#ft-bash-syntax" name="ft-bash-syntax">*ft-bash-syntax*</a>&nbsp;<a class="Constant" href="syntax.html#ft-ksh-syntax" name="ft-ksh-syntax">*ft-ksh-syntax*</a><br>
<br>
これは「普通の」Unix (Bourne) sh、bashそしてKornシェルをカバーしている。<br>
<br>
Vimは様々なファイル名がどのタイプであるかを指定することによって、どのシェルが<br>
使われているかを決定しようとする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;ksh : .kshrc* *.ksh</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;bash: .bashrc* bashrc bash.bashrc .bash_profile* *.bash</span><br>
<br>
これらのうちどれにも当てはまらなければ、ファイルの第一行によって判断される(例.<br>
/bin/sh /bin/ksh /bin/bash)。第一行でシェルを指定されていれば、そのシェルが使<br>
用される。しかしいくつかのファイル(例. .profile)はシェルファイルであることはわ<br>
かっていても、どのタイプか明らかではない。さらに、多くのシステムでshは<br>
&quot;bash&quot;(Linux, Windows+cygwin)や&quot;ksh&quot;(Posix)へのシンボリックリンクになっている。<br>
<br>
以下の3つの変数のどれかを.vimrcで定義することにより、デフォルトを設定すること<br>
が出来る:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;ksh:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:is_kornshell = 1</span><br>
&nbsp;&nbsp;&nbsp; posix: (これは is_kornshell を1に設定することと同じ)<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:is_posix&nbsp;&nbsp;&nbsp;&nbsp; = 1</span><br>
&nbsp;&nbsp;&nbsp; bash:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:is_bash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1</span><br>
&nbsp;&nbsp;&nbsp; sh: (デフォルト) Bourne shell<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:is_sh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1</span><br>
<br>
&quot;#! ...&quot; という行がなく、かつユーザが上の方法でデフォルトの sh.vim の構文を設<br>
定していない場合、sh.vim は Bourne シェルの構文であると仮定する。エラーレポート<br>
に RFC や市場浸透統計の引用を含める必要はありません。単に .vimrc でシステムで<br>
使われるデフォルトの sh のバージョンを選択してください。<br>
<br>
syntax/sh.vim は構文ベースの折り畳みを数種類用意している:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:sh_fold_enabled= 0&nbsp;&nbsp;&nbsp;&nbsp; (デフォルト。構文折り畳みなし)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:sh_fold_enabled= 1&nbsp;&nbsp;&nbsp;&nbsp; (関数の折り畳みを有効化)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:sh_fold_enabled= 2&nbsp;&nbsp;&nbsp;&nbsp; (ヒアドキュメントの折り畳みを有効化)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:sh_fold_enabled= 4&nbsp;&nbsp;&nbsp;&nbsp; (if/do/for の折り畳みを有効化)</span><br>
<br>
様々な構文要素(ヒアドキュメントと関数の中身)がsyntaxメソッドによって折り畳み可<br>
能になる(<a class="Identifier" href="syntax.html#:syn-fold">|:syn-fold|</a>)。これらのうち複数を組み合わせることもできる:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:sh_fold_enabled= 3&nbsp;&nbsp;&nbsp;&nbsp; (関数とヒアドキュメントの折畳を有効化)</span><br>
<br>
上方向にスクロールしているときにハイライトがおかしくなり、それが<span class="Special">CTRL-L</span>で再描画<br>
すると直るようなら、変数&quot;sh_minlines&quot;の値を大きくしてみるとよい。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let sh_minlines = 500</span><br>
<br>
こうすると構文シンクロナイズが画面最上行の500行前から始まるようになる。デフォ<br>
ルトの値は200である。大きい値を設定することの欠点は、動作が遅くなるかもしれな<br>
いことである。<br>
<br>
シンクロナイズさせるものがあまりないときは表示がとても遅くなるかもしれない。こ<br>
れを減らすために、変数&quot;sh_maxlines&quot;をセットすることができる。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let sh_maxlines = 100</span><br>
<br>
デフォルトはsh_minlinesの2倍の値が使われる。表示を高速化するにはこれをもっと小<br>
さい値にすること。欠点はハイライト間違いが出るかもしれないことである。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#g:sh_isk" name="g:sh_isk">*g:sh_isk*</a>&nbsp;<a class="Constant" href="syntax.html#g:sh_noisk" name="g:sh_noisk">*g:sh_noisk*</a><br>
shell 言語では &quot;.&quot; は単語やコマンドなどの一部として扱われるので、sh.vim では<br>
isk の中にその値を含むべきです。syntax/sh.vim の v116 の時点で、syntax/sh.vim<br>
はデフォルトで&nbsp;<a class="Type" href="options.html#'iskeyword'">'iskeyword'</a>&nbsp;に &quot;.&quot; を追加します。次のように設定することでこの動<br>
作を制御できます:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:sh_isk&nbsp;&nbsp;= '..iskeywordに設定した値'</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:sh_noisk= 1&nbsp;&nbsp;&quot; sh_iskを設定しない場合、この変数を定義すると isk</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; は変更されない。</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#sh-embed" name="sh-embed">*sh-embed*</a>&nbsp;&nbsp;<a class="Constant" href="syntax.html#sh-awk" name="sh-awk">*sh-awk*</a><br>
&nbsp;Sh: 埋め込み言語<br>
<br>
sh に言語を埋め込みたい場合。Lorance Stinson が awk を埋め込む例を出してくれた<br>
のでそれを載せます。以下のファイルを $HOME/.vim/after/syntax/sh/awkembed.vim<br>
に置いてください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&quot; AWK Embedding: {{ "{{{" }}1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&quot; ==============</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&quot; Shamelessly ripped from aspperl.vim by Aaron Hope.</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;if exists(&quot;b:current_syntax&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlet b:current_syntax</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;syn include @AWKScript syntax/awk.vim</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;syn region AWKScriptCode matchgroup=AWKCommand start=+[=\\]\@&lt;!'+ skip=+\\'+ end=+'+ contains=@AWKScript contained</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;syn region AWKScriptEmbedded matchgroup=AWKCommand start=+\&lt;awk\&gt;+ skip=+\\$+ end=+[=\\]\@&lt;!'+me=e-1 contains=@shIdList,@shExprList2 nextgroup=AWKScriptCode</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;syn cluster shCommandSubList add=AWKScriptEmbedded</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;hi def link AWKCommand Type</span><br>
<br>
この例では次のようなシングルクォートで囲まれた awk コードが awk 言語として強調<br>
表示されるようになります:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk '...awk code here...'</span><br>
これは他の言語にも応用できます。<br>
<br>
<br>
<span class="Statement">SPEEDUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#spup.vim" name="spup.vim">*spup.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-spup-syntax" name="ft-spup-syntax">*ft-spup-syntax*</a><br>
(AspenTech plant simulator)<br>
<br>
Speedup構文ファイルにはいくつかのオプションがある:<br>
<br>
- strict_subsections : この変数が定義されていると、セクションとサブセクション<br>
&nbsp;&nbsp;用のキーワードだけが文としてハイライトされ、他のキーワードにはされなくなる<br>
&nbsp;&nbsp;(OPERATIONセクションのWITHINと同様)。<br>
<br>
- highlight_types : この変数が定義されていると、温度や圧力のようなストリーム<br>
&nbsp;&nbsp;型が単純な識別子でなくTypeとしてハイライトされる。Includedは通常DECLAREセク<br>
&nbsp;&nbsp;ション中に現れる型である;ユーザが自分用の型を定義しているならそれらを構文ファ<br>
&nbsp;&nbsp;イルに含めなければならない。<br>
<br>
- oneline_comments : この値は1から3までの間になり、#スタイルのコメントのハイラ<br>
&nbsp;&nbsp;イトを決定する。<br>
<br>
&nbsp;&nbsp;oneline_comments = 1 : 偶数個の#の後にも通常のSpeedupコードが現れることを許す<br>
<br>
&nbsp;&nbsp;oneline_comments = 2 : 2番目の#で始まるコードをエラーとして表示する。これが<br>
&nbsp;&nbsp;デフォルトの設定である。<br>
<br>
&nbsp;&nbsp;oneline_comments = 3 : 1個以上の#を含む行全体をエラーとしてハイライトする。<br>
<br>
変数のPRESETにより、OPERATIONセクションはとても大きくなりがちであり、そのため<br>
シンクロナイズが追いつかなくなるかもしれない。あなたのコンピュータが十分速いな<br>
ら構文ファイルの最後近くでminlinesとmaxlinesの値を大きくするとよいかもしれない。<br>
<br>
<br>
<span class="Statement">SQL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#sql.vim" name="sql.vim">*sql.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-sql-syntax" name="ft-sql-syntax">*ft-sql-syntax*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#sqlinformix.vim" name="sqlinformix.vim">*sqlinformix.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-sqlinformix-syntax" name="ft-sqlinformix-syntax">*ft-sqlinformix-syntax*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#sqlanywhere.vim" name="sqlanywhere.vim">*sqlanywhere.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-sqlanywhere-syntax" name="ft-sqlanywhere-syntax">*ft-sqlanywhere-syntax*</a><br>
<br>
SQLにはANSI標準があるのだが、ほとんどのデータベースエンジンは独自の拡張を追加<br>
している。現在のところ、VimはOracleとInformixのSQL方言をサポートしている。<br>
デフォルトではVimは&quot;*.sql&quot;のファイルをOracle SQLであると判断する。<br>
<br>
現在のところ、Vimは構文スクリプトによって、様々なベンダのSQLに対応している。<br>
デフォルト設定をOracleから他の対応しているSQLに変更することができる。また、<br>
バッファごとに使うSQLの方言を変えることも簡単にできる。<br>
<br>
より詳しい説明は<a class="Identifier" href="ft_sql.html">|ft_sql.txt|</a>を参照。<br>
<br>
<br>
<span class="Statement">TCSH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#tcsh.vim" name="tcsh.vim">*tcsh.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-tcsh-syntax" name="ft-tcsh-syntax">*ft-tcsh-syntax*</a><br>
<br>
これは&quot;tcsh&quot;という名前のシェルをカバーしている。これはcshのスーパーセットであ<br>
る。ファイル形式がどのように判定されるかは<a class="Identifier" href="syntax.html#csh.vim">|csh.vim|</a>を参照。<br>
<br>
tcshはシェル変数 backslash_quote をセットしていない限り文字列中に\&quot;が現れるこ<br>
とを許さない。Vimにバックスラッシュクォート構文が存在しないと判断させたいな<br>
ら、次の行を.vimrcに加えること:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let tcsh_backslash_quote = 0</span><br>
<br>
上方向にスクロールしているときにハイライトがおかしくなり、それが<span class="Special">CTRL-L</span>で再描画<br>
すると直るようなら、変数 tcsh_minlines の値を大きくしてみるとよい:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let tcsh_minlines = 1000</span><br>
<br>
こうすると構文シンクロナイズが画面最上行の1000行前から始まるようになる。<br>
tcsh_minlines に &quot;fromstart&quot; をセットすると、ファイルの先頭からシンクロナイズ<br>
が行われるようになる。tcsh_minlines の既定値は 100。大きな値にすることの欠点は、<br>
再描画が遅くなることである。<br>
<br>
<br>
<span class="Statement">TEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#tex.vim" name="tex.vim">*tex.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-tex-syntax" name="ft-tex-syntax">*ft-tex-syntax*</a><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#tex-folding" name="tex-folding">*tex-folding*</a><br>
&nbsp;<span class="PreProc">Tex: 構文折り畳み?</span><br>
<br>
&lt;syntax/tex.vim&gt;のバージョン28以降では、構文による部分、章、節、小節などの折り<br>
畳みに対応している。それを有効にするには次の行を&lt;.vimrc&gt;に書き、<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:tex_fold_enabled=1</span><br>
:set fdm=syntaxとする。後者をLaTeXファイルの末尾にモードラインとして書いておく<br>
といいかもしれない:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% vim&#0058; fdm=syntax</span><br>
これによってシステムが遅くなり過ぎる場合は次のリンクを参照してください<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text">http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text</a></span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#tex-nospell" name="tex-nospell">*tex-nospell*</a><br>
&nbsp;<span class="PreProc">Tex: コメントの中ではスペルチェックを行わせたくない場合</span><br>
<br>
LaTeX ファイルのコメントの中にソースコードのようなものを含めることがあるので、<br>
コメントの中ではスペルチェックを無効にしたいという人もいる。そのようにするには<br>
次の行を .vimrc に加える:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:tex_comment_nospell= 1</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#tex-verb" name="tex-verb">*tex-verb*</a><br>
&nbsp;<span class="PreProc">Tex: Verbatim ゾーンをスペルチェックするには?</span><br>
<br>
たいてい verbatim リージョンはソースコードのようなものを書くのに使われます。<br>
ソースコードをスペルチェックしたいと思うことはほとんどないでしょう。とはいえ、<br>
もし verbatim ゾーンの内容をスペルチェックしたいときは &lt;.vimrc&gt; で次のように設<br>
定してください:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:tex_verbspell= 1</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#tex-runon" name="tex-runon">*tex-runon*</a><br>
&nbsp;<span class="PreProc">Tex: コメントや MathZone の区切り</span><br>
<br>
&lt;syntax/tex.vim&gt;の構文ハイライトはTeX, LaTeX, AmsTeXをサポートしている。normal,<br>
texZone, texMathZoneの3つの主な区間・範囲がサポートされている。これらの区間を<br>
適切に区切るようかなりの努力がされたが、$..$と$$..$$で線引きされる区間は開始・<br>
終了のパターンとまったく同じにシンクロナイズさせることは出来ない。その結果、特<br>
別な&quot;TeX comment&quot;が提供されている<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%stopzone</span><br>
このコメントがあると、ここで強制的にtexZoneまたはtexMathZoneのハイライトを終わ<br>
らせる。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#tex-slow" name="tex-slow">*tex-slow*</a><br>
&nbsp;<span class="PreProc">Tex: 構文ハイライトが遅いならば</span><br>
<br>
遅いコンピュータを使っているなら、これらの値を減らすとよいかもしれない<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn sync maxlines=200</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn sync minlines=50</span><br>
(特に後者を)。速いコンピュータを使っているならこれらの値を増やしてもよい。これ<br>
らは第一にシンクロナイズ(つまり、画面最上行のテキストがどのグループに入るか)に<br>
影響を与える。<br>
<br>
構文による折り畳みによって遅くなる場合もあります。回避方法については<br>
<a class="Identifier" href="syntax.html#tex-folding">|tex-folding|</a>&nbsp;を参照してください。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#tex-morecommands" name="tex-morecommands">*tex-morecommands*</a>&nbsp;<a class="Constant" href="syntax.html#tex-package" name="tex-package">*tex-package*</a><br>
&nbsp;<span class="PreProc">Tex: もっとコマンドをハイライトさせるには</span><br>
<br>
LaTeXはプログラミング言語であり、特殊化されたLaTeXのコマンド、構文、フォントが<br>
つまったパッケージがたくさんある。そのようなパッケージを使っている人は、標準の<br>
syntax/tex.vimにそのパッケージを対応させてほしいと思うだろう。しかしそれは明ら<br>
かに非現実的である。そこで、<a class="Identifier" href="syntax.html#mysyntaxfile-add">|mysyntaxfile-add|</a>で使われているテクニックを使っ<br>
て、syntax/tex.vimで提供されているハイライトを拡張・修正してみてください。拡張<br>
(典型的には $HOME/after/syntax/tex/[pkgname].vim に置いて使う) を書いたら、そ<br>
れを&nbsp;<span class="Constant"><a href="http://vim.sf.net/">http://vim.sf.net/</a></span>&nbsp;にアップロードすることを検討してみてください。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#tex-error" name="tex-error">*tex-error*</a><br>
&nbsp;<span class="PreProc">Tex: エラーのハイライトが行き過ぎならば</span><br>
<br>
&lt;tex.vim&gt;は様々な種類のレキシカルエラーチェックをサポートしている。すなわち、<br>
エラーチェックはとても便利だが、実際にはエラーでない箇所もエラーと示すかもしれ<br>
ない。それが嫌なら、次の行を&lt;.vimrc&gt;に置くとよい:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let tex_no_error=1</span><br>
すると&lt;syntax/tex.vim&gt;によるすべてのエラーチェックが行われなくなる。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#tex-math" name="tex-math">*tex-math*</a><br>
&nbsp;<span class="PreProc">Tex: 新しいMathグループが必要ならば</span><br>
<br>
新しいmathグループをLaTeXに含めるには、以下のコードがその例となるだろう:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call TexNewMathZone(sfx,mathzone,starform)</span><br>
新しいmathグループに一意な接尾辞をつけたいと思うだろう(現在のところ、AからLま<br>
でとVからZまでは&lt;syntax/tex.vim&gt;自身によって取得されている)。<br>
例として、&lt;syntax/tex.vim&gt;でeqnarrayがどのように設定されているかを見てみよ<br>
う:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call TexNewMathZone(&quot;D&quot;,&quot;eqnarray&quot;,1)</span><br>
&quot;mathzone&quot;をあなたが作ったmathグループの名前に変える必要がある。<br>
また、それが呼ばれるようにするために.vim/after/syntax/tex.vimに書くこと。<br>
変数&quot;starform&quot;が真ならば、あなたが作ったmathグループがアスタリスクつきの形を<br>
もつことを意味する(例. eqnarray*)。<br>
<br>
LOCALMATHをあなたが決めた新しいmathグループに書き換える必要がある。そしてこれ<br>
を.vim/after/syntax/tex.vimに加えること。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#tex-style" name="tex-style">*tex-style*</a><br>
&nbsp;<span class="PreProc">Tex: 新しいスタイルを始めるには</span><br>
<br>
*.texファイルで&quot;\makeatletter&quot;を使う人がいるかもしれないので、コマンド中で&quot;@&quot;<br>
が使えるようになっている。しかし*.texファイルは次の拡張子: sty cls clo dtx ltx<br>
を持たないので@をエラーと判断してハイライトする。これを解決するにはこうする:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let b:tex_stylish = 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set ft=tex</span><br>
<br>
&quot;let g:tex_stylish=1&quot;を&lt;.vimrc&gt;に書くと&lt;syntax/tex.vim&gt;は常にこのような@の使用<br>
法を受け入れるようになる。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#tex-cchar" name="tex-cchar">*tex-cchar*</a>&nbsp;<a class="Constant" href="syntax.html#tex-cole" name="tex-cole">*tex-cole*</a>&nbsp;<a class="Constant" href="syntax.html#tex-conceal" name="tex-conceal">*tex-conceal*</a><br>
&nbsp;<span class="PreProc">Tex: Conceal モードを活用する</span><br>
<br>
<a class="Type" href="options.html#'conceallevel'">'conceallevel'</a>&nbsp;が 2 に設定され、エンコーディングとして utf-8 が使われていると<br>
き、さまざまな文字シーケンスがそれに対応した utf-8 グリフとして表示されます。<br>
対応している文字としてはアクセント付き文字、Math ゾーンの中のギリシア文字、<br>
Math ゾーンの中の上付き記号と下付き記号などがあります。すべての上付き記号と下<br>
付き記号を表示できるわけではありません。utf-8 がサポートしている範囲でのみ利用<br>
可能です。実際のところ、サポートされている下付き記号は少ししかありません。<br>
<br>
使用例としては、ウィンドウを垂直分割して (<a class="Identifier" href="windows.html#CTRL-W_v">|CTRL-W_v|</a>&nbsp;参照)、一つのウィンドウは<br>
<a class="Identifier" href="options.html#'conceallevel'">|'conceallevel'|</a>&nbsp;を 0 に設定してもう一方は 2 に設定し、両方で&nbsp;<a class="Identifier" href="options.html#'scrollbind'">|'scrollbind'|</a><br>
を設定するような使い方があります。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#g:tex_conceal" name="g:tex_conceal">*g:tex_conceal*</a><br>
&nbsp;<span class="PreProc">Tex: Conceal モードの選択</span><br>
<br>
g:tex_conceal を &lt;.vimrc&gt; で設定することで Conceal モードの表示を変更できま<br>
す。初期設定は &quot;admgs&quot; で、これは次の文字セットが Conceal 表示されます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = アクセント/合字 (accents/ligatures)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = 区切り記号 (delimiters)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = 数学記号 (math symbols)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g = ギリシア文字 (Greek)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = 上付き記号/下付き記号 (superscripts/subscripts)</span><br>
<br>
これらの文字を設定から外すことで、それに関連した文字が Conceal 表示されなくな<br>
ります。<br>
<br>
<br>
<span class="Statement">TF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#tf.vim" name="tf.vim">*tf.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-tf-syntax" name="ft-tf-syntax">*ft-tf-syntax*</a><br>
<br>
tfの構文ハイライトには1つのオプションがある。<br>
<br>
シンクロナイズについて、minlinesのデフォルトは100になっている。この値を変える<br>
には、&quot;tf_minlines&quot;に望みの値をセットする。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let tf_minlines = your choice</span><br>
<br>
<br>
<span class="Statement">VIM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#vim.vim" name="vim.vim">*vim.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-vim-syntax" name="ft-vim-syntax">*ft-vim-syntax*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#g:vimsyn_minlines" name="g:vimsyn_minlines">*g:vimsyn_minlines*</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#g:vimsyn_maxlines" name="g:vimsyn_maxlines">*g:vimsyn_maxlines*</a><br>
正確な構文ハイライトと画面更新速度はトレードオフの問題である。正確さを向上させ<br>
るには、変数 g:vimsyn_minlines の値を大きくすればよい。g:vimsyn_maxlines も画<br>
面更新頻度を高めるのに使える(これについては<a class="Identifier" href="syntax.html#:syn-sync">|:syn-sync|</a>を参照)。<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:vim_minlines : シンクロナイズの最小行数を指定する</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:vim_maxlines : シンクロナイズの最大行数を指定する&nbsp;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(g:vim_minlines と g:vim_maxlines はこれらのオプションの以前の名前であ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;る)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#g:vimsyn_embed" name="g:vimsyn_embed">*g:vimsyn_embed*</a><br>
g:vimsyn_embed オプションは、どの外部スクリプト言語の埋め込みに対応するかを指<br>
定する。<br>
<br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_embed == 0&nbsp;&nbsp; : どのスクリプトの埋め込みも対応しない</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_embed =~ 'm' : mzscheme に対応 (コンパイル時に有効にした場合のみ)</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_embed =~ 'p' : perl&nbsp;&nbsp;&nbsp;&nbsp; に対応 (コンパイル時に有効にした場合のみ)</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_embed =~ 'P' : python&nbsp;&nbsp; に対応 (コンパイル時に有効にした場合のみ)</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_embed =~ 'r' : ruby&nbsp;&nbsp;&nbsp;&nbsp; に対応 (コンパイル時に有効にした場合のみ)</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_embed =~ 't' : tcl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;に対応 (コンパイル時に有効にした場合のみ)</span><br>
<br>
g:vimsyn_embed の既定値は &quot;mpPr&quot; であり、mzscheme, perl, python, ruby に対応し<br>
ている。tcl が利用可能でない環境で has(&quot;tcl&quot;) の判定を行うと Vim がハングする<br>
ようなので、デフォルトでは tcl の埋め込みには対応していない(もちろん、有効にし<br>
たい場合には g:vimembedscript に含めることで有効にできる)。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#g:vimsyn_folding" name="g:vimsyn_folding">*g:vimsyn_folding*</a><br>
<br>
syntax/vim.vim によって折り畳みが可能である:<br>
<br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_folding == 0 または変数が存在しない: 構文ベースの折り畳みはしない</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_folding =~ 'a' : augroups</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_folding =~ 'f' : 関数を折り畳む</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_folding =~ 'm' : mzscheme スクリプトを折り畳む</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_folding =~ 'p' : perl&nbsp;&nbsp;&nbsp;&nbsp; スクリプトを折り畳む</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_folding =~ 'P' : python&nbsp;&nbsp; スクリプトを折り畳む</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_folding =~ 'r' : ruby&nbsp;&nbsp;&nbsp;&nbsp; スクリプトを折り畳む</span><br>
<span class="Comment">&nbsp;&nbsp; g:vimsyn_folding =~ 't' : tcl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;スクリプトを折り畳む</span><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*g:vimsyn_noerror*</span><br>
syntax/vim.vimによるエラーのハイライトは必ずしも正しいとは限らない。Vimスクリ<br>
プトは正しくハイライトするのが難しい言語である。エラーのハイライトをやめるには<br>
次を<a class="Identifier" href="starting.html#vimrc">|vimrc|</a>に書けばよい:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:vimsyn_noerror = 1</span><br>
<br>
<br>
<br>
<span class="Statement">XF86CONFIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#xf86conf.vim" name="xf86conf.vim">*xf86conf.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-xf86conf-syntax" name="ft-xf86conf-syntax">*ft-xf86conf-syntax*</a><br>
<br>
XF86Configファイルの構文はXFree86 v3.xとv4.xで異なっている。両方のバージョンが<br>
サポートされている。自動的に判定がされるが、完全からはほど遠い。手動でバージョ<br>
ンを設定する必要があるかもしれない。使用しているXFree86に応じて、.vimrc中で変<br>
数xf86conf_xfree86_versionを3または4にセットすること。例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let xf86conf_xfree86_version=3</span><br>
複数のバージョンが混在しているときには<br>
変数b:xf86conf_xfree86_versionをセットすること。<br>
<br>
<span class="Todo">Note</span>&nbsp;オプション名の中のスペースとアンダースコアはハイライトされない。オプショ<br>
ン名をハイライトさせるには&quot;__s yn con gr_e_e_n&quot;でなく&quot;SyncOnGreen&quot;と書くこと。<br>
<br>
<br>
<span class="Statement">XML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><a class="Constant" href="syntax.html#xml.vim" name="xml.vim">*xml.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-xml-syntax" name="ft-xml-syntax">*ft-xml-syntax*</a><br>
<br>
Xml名前空間がデフォルトでハイライトされる。次のグローバル変数をセットするとそ<br>
れが無効化される:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:xml_namespace_transparent=1</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#xml-folding" name="xml-folding">*xml-folding*</a><br>
xml構文ファイルを使うと、開始タグと終了タグの間を折りたたむ<a class="Identifier" href="fold.html#folding">|folding|</a>ことができ<br>
る(<a class="Identifier" href="syntax.html#:syn-fold">|:syn-fold|</a>を参照)。これをオンにするには<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let g:xml_syntax_folding = 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set foldmethod=syntax</span><br>
<br>
とする。<br>
構文による折り畳みは、構文ハイライトを著しく遅くする可能性がある。特に巨大なファ<br>
イルではそうである。<br>
<br>
<br>
X Pixmaps (XPM)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#xpm.vim" name="xpm.vim">*xpm.vim*</a>&nbsp;<a class="Constant" href="syntax.html#ft-xpm-syntax" name="ft-xpm-syntax">*ft-xpm-syntax*</a><br>
<br>
xpm.vimは編集中のXPMファイルの内容から、動的に構文要素を生成する。そのため、色<br>
設定文字列などを変更したときは&quot;:set syn=xpm&quot;などとしてxpm.vimを読み直さなけれ<br>
ばならない。<br>
<br>
色つきのピクセルをコピーするには&quot;yl&quot;で&quot;pixel&quot;をヤンクし、どこかで&quot;P&quot;としてそれ<br>
を挿入する。<br>
<br>
マウスで図を描くには、次のようにしてみるとよい:<br>
<span class="Comment">&nbsp;&nbsp; :function! GetPixel()</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp; let c = getline(&quot;.&quot;)[col(&quot;.&quot;) - 1]</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp; echo c</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp; exe &quot;noremap &lt;LeftMouse&gt; &lt;LeftMouse&gt;r&quot;.c</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp; exe &quot;noremap &lt;LeftDrag&gt;&nbsp;&nbsp;&lt;LeftMouse&gt;r&quot;.c</span><br>
<span class="Comment">&nbsp;&nbsp; :endfunction</span><br>
<span class="Comment">&nbsp;&nbsp; :noremap &lt;RightMouse&gt; &lt;LeftMouse&gt;:call GetPixel()&lt;CR&gt;</span><br>
<span class="Comment">&nbsp;&nbsp; :set guicursor=n:hor20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; to see the color beneath the cursor</span><br>
これを行うと、右ボタンがピペットになり、左ボタンがペンになる。これは1ピクセル<br>
につき1文字だけとなっているXPMファイルでうまく機能する。ピクセル文字列の外をク<br>
リックしてはならない。これを自由に改良してください。<br>
<br>
セルサイズが正方形のフォントを使うと見栄えがよくなる。Xの場合の例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*</span><br>
<br>
<br>
<span class="PreProc">==============================================================================</span><br>
5. 構文を定義する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-define" name=":syn-define">*:syn-define*</a>&nbsp;<a class="Constant" href="syntax.html#E410" name="E410">*E410*</a><br>
<br>
構文アイテムには3つのタイプがある。<br>
<br>
1. キーワード (Keyword)<br>
&nbsp;&nbsp; これはオプション<a class="Type" href="options.html#'iskeyword'">'iskeyword'</a>で定義されるキーワード文字だけからなる。他の構文<br>
&nbsp;&nbsp; 要素を含むことはできない。完全な単語(マッチの前後にキーワード文字が存在しな<br>
&nbsp;&nbsp; い)にのみマッチする。キーワード&quot;if&quot;は&quot;if(a=b)&quot;にはマッチするが、&quot;ifdef x&quot;に<br>
&nbsp;&nbsp; はマッチしない。&quot;(&quot;はキーワード文字でなく、&quot;d&quot;はキーワード文字だから。<br>
<br>
2. マッチ (Match)<br>
&nbsp;&nbsp; 単一の正規表現パターンにマッチする。<br>
<br>
3. リージョン (Region)<br>
&nbsp;&nbsp; 正規表現パターン&quot;start&quot;のマッチ位置から始まり、正規表現パターン&quot;end&quot;のマッ<br>
&nbsp;&nbsp; チ位置で終わる。その間にどんなテキストがあってもよい。正規表現パターン<br>
&nbsp;&nbsp; &quot;skip&quot;を使うとパターン&quot;end&quot;にマッチするのを避けることができる。<br>
<br>
複数の構文アイテムを1つの構文グループに入れることができる。構文グループにはハ<br>
イライト属性を与えることができる。例えば、&quot;/* .. */&quot;のコメントを定義する要素と<br>
&quot;// ..&quot;のコメントを定義する要素を作り、両方を&quot;Comment&quot;グループに入れる。そして<br>
&quot;Comment&quot;を青のボールドフォントで表示するように指定すると、両方のタイプのコメ<br>
ントに対して同じハイライトがされるようになる。1つの構文要素に対し1つの構文グルー<br>
プを作ってもよいし、すべての要素を1つのグループに入れてもよい。これはハイライ<br>
ト属性をどう指定したいかによる。各要素をそれ自身のグループに入れるとすると、た<br>
くさんのグループに対して色を指定しなければならなくなる。<br>
<br>
構文グループとハイライトグループは似ているが異なることに注意。ハイライトグルー<br>
プに対してはハイライト属性を与えることになる。それらの属性が同名の構文グループ<br>
に対して適用される。<br>
<br>
同じ箇所に対して複数のアイテムがマッチした場合には、最後に定義されたものが有効<br>
になる。よって同じテキストにマッチする要素を使って、以前に定義された構文アイテ<br>
ムを上書きすることができる。大文字・小文字の違いも含めてマッチするキーワードが<br>
ある場合は、そうでないものより優先される。<br>
<br>
<br>
優先順位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-priority" name=":syn-priority">*:syn-priority*</a><br>
<br>
複数の構文アイテムがマッチするときは、以下のルールが適用される:<br>
<br>
1. 複数のマッチまたはリージョンアイテムが同じ場所で始まるときは、後に定義され<br>
&nbsp;&nbsp; たものが優先される。<br>
2. マッチとリージョンよりキーワードが優先される。<br>
3. より前の位置から始まる要素が優先される。<br>
<br>
<br>
大文字・小文字の区別&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-case" name=":syn-case">*:syn-case*</a>&nbsp;<a class="Constant" href="syntax.html#E390" name="E390">*E390*</a><br>
<br>
:sy[ntax] case [match | ignore]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;これ以降の&quot;:syntax&quot;コマンドが大文字・小文字を区別するかどうかを定義す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;る。&quot;match&quot;を使うと区別し、&quot;ignore&quot;を使うと区別しなくなる。これ以前の<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要素には影響せず、次の&quot;:syntax case&quot;コマンドまでのすべての要素に影響<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;する。<br>
<br>
<br>
スペルチェック&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-spell" name=":syn-spell">*:syn-spell*</a><br>
<br>
:sy[ntax] spell [toplevel | notoplevel | default]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;構文アイテムに入っていないテキストに対して、どこでスペルチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;を行うかを定義する:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toplevel:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; テキストのスペルチェックを行う。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notoplevel:&nbsp;&nbsp;&nbsp;&nbsp; テキストのスペルチェックを行わない。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;クラスタ@Spellがあるときスペルチェックを行わない。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;構文アイテムに入っているテキストはクラスタ@Spellと@NoSpellを使う<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">|spell-syntax|</span>。クラスタ@Spellと@NoSpellがないときは、スペルチェックは<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;default&quot;と&quot;toplevel&quot;に対して行われる。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;スペルチェックを有効化するにはオプション<a class="Type" href="options.html#'spell'">'spell'</a>をオンにしなければなら<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ない。<br>
<br>
<br>
キーワードの定義&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-keyword" name=":syn-keyword">*:syn-keyword*</a><br>
<br>
:sy[ntax] keyword&nbsp;<span class="Special">{group-name}</span>&nbsp;[<span class="Special">{options}</span>]&nbsp;<span class="Special">{keyword}</span>&nbsp;.. [<span class="Special">{options}</span>]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;キーワードを定義する。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{group-name}</span>&nbsp;&nbsp;&nbsp;&nbsp;&quot;Comment&quot;のような構文グループ名。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="Special">{options}</span>]&nbsp;&nbsp;&nbsp;&nbsp; 後述の<a class="Identifier" href="syntax.html#:syn-arguments">|:syn-arguments|</a>を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{keyword}</span>&nbsp;..&nbsp;&nbsp;&nbsp;&nbsp;このグループに含めるキーワードのリスト。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例:<br>
<span class="Comment">&nbsp;&nbsp;:syntax keyword&nbsp;&nbsp; Type&nbsp;&nbsp; int long char</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{options}</span>は行のどこに置いてもよい。それらは与えられたキーワード全てに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;適用される。オプションがキーワードの後にあっても同じ。以下の例はまった<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;く同じ意味になる:<br>
<span class="Comment">&nbsp;&nbsp;:syntax keyword&nbsp;&nbsp; Type&nbsp;&nbsp; contained int long char</span><br>
<span class="Comment">&nbsp;&nbsp;:syntax keyword&nbsp;&nbsp; Type&nbsp;&nbsp; int long contained char</span><br>
<span class="Comment">&nbsp;&nbsp;:syntax keyword&nbsp;&nbsp; Type&nbsp;&nbsp; int long char contained</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#E789" name="E789">*E789*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vimのexコマンドのようにキーワードに短縮形があるとき、省略可能な部分を<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[]のでくくることによって受け入れるキーワードをいっぺんに定義することが<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;できる:<br>
<span class="Comment">&nbsp;&nbsp;:syntax keyword&nbsp;&nbsp; vimCommand&nbsp;&nbsp; ab[breviate] n[ext]</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;キーワードは、その文字全てがオプション<a class="Type" href="options.html#'iskeyword'">'iskeyword'</a>に含まれていないと認<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;識されないことに注意。1文字でも含まれていないものがあると、そのキーワー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ドは認識されない。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マルチバイト文字を使うこともできる。マルチバイト文字は<a class="Type" href="options.html#'iskeyword'">'iskeyword'</a>に含<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;まれている必要はない。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;キーワードは常にマッチやリージョンより優先される。キーワードは一要素以<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上マッチしたとき使われる。キーワードは入れ子にならなく、それ以外のもの<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;を含むこともできない。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;オプション名と同じ単語は、それがその位置で利用できないものであったとし<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ても、キーワードとして定義することはできない。マッチで代用すること。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;キーワードの長さは最大80文字である。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containmentが異なれば、同じキーワードを複数回定義することができる。例<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;えば、まずキーワードをcontainedでなく定義して1つのハイライトグループを<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;設定し、次にcontainedとして定義して別のハイライトグループを設定するこ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;とができる。例:<br>
<span class="Comment">&nbsp;&nbsp;:syn keyword vimCommand tag</span><br>
<span class="Comment">&nbsp;&nbsp;:syn keyword vimSetting contained tag</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 構文要素の外側に&quot;tag&quot;があったときはハイライトグループ&quot;vimCommand&quot;が適<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用される。&quot;vimSetting&quot;を含む構文要素の中に&quot;tag&quot;があったときは<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;vimSetting&quot;グループが適用される。<br>
<br>
<br>
マッチの定義&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-match" name=":syn-match">*:syn-match*</a><br>
<br>
:sy[ntax] match&nbsp;<span class="Special">{group-name}</span>&nbsp;[<span class="Special">{options}</span>]&nbsp;<span class="Special">[excludenl]</span>&nbsp;<span class="Special">{pattern}</span>&nbsp;[<span class="Special">{options}</span>]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マッチを定義する。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{group-name}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Comment&quot;のような構文グループ名。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="Special">{options}</span>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 後述の<a class="Identifier" href="syntax.html#:syn-arguments">|:syn-arguments|</a>を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">[excludenl]</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 行末の&quot;$&quot;を含んでいるパターンに対して、行末以<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;降までマッチやリージョンを拡張しないようにす<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;る。パターンの前に置かなければならない。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-excludenl">|:syn-excludenl|</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{pattern}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; マッチを定義する検索パターン。<a class="Identifier" href="syntax.html#:syn-pattern">|:syn-pattern|</a>を<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;後述の参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;パターンは複数行にもマッチする。よって検<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;索を開始する場所によってマッチが変わってくる可<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能性がある。シンクロナイズが関係してくることに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例 (文字定数にマッチする):<br>
<span class="Comment">&nbsp;&nbsp;:syntax match Character /'.'/hs=s+1,he=e-1</span><br>
&nbsp;&nbsp;<br>
<br>
リージョンの定義&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-region" name=":syn-region">*:syn-region*</a>&nbsp;<a class="Constant" href="syntax.html#:syn-start" name=":syn-start">*:syn-start*</a>&nbsp;<a class="Constant" href="syntax.html#:syn-skip" name=":syn-skip">*:syn-skip*</a>&nbsp;<a class="Constant" href="syntax.html#:syn-end" name=":syn-end">*:syn-end*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#E398" name="E398">*E398*</a>&nbsp;<a class="Constant" href="syntax.html#E399" name="E399">*E399*</a><br>
<br>
:sy[ntax] region&nbsp;<span class="Special">{group-name}</span>&nbsp;[<span class="Special">{options}</span>]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[matchgroup=<span class="Special">{group-name}</span>]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">[keepend]</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">[extend]</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">[excludenl]</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start={start_pattern} ..<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[skip={skip_pattern}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end={end_pattern} ..<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="Special">{options}</span>]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リージョンを定義する。複数行にわたってもよい。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{group-name}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Comment&quot;のような構文グループ名。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="Special">{options}</span>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 後述の<a class="Identifier" href="syntax.html#:syn-arguments">|:syn-arguments|</a>を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[matchgroup=<span class="Special">{group-name}</span>]&nbsp;&nbsp;以下の開始パターンと終了パターンのマッチに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;のみ使われる構文グループ。マッチの開始パターン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;と終了パターンには使われない。開始パターンと終<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了パターン用に異なるグループを使わないようにリ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;セットするにはNONEを使う。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-matchgroup">|:syn-matchgroup|</a>を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keepend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内包されたマッチが終了パターンを越えないように<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;する。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-keepend">|:syn-keepend|</a>を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;このリージョンを含むアイテムの&quot;keepend&quot;を上書<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;きする。<a class="Identifier" href="syntax.html#:syn-extend">|:syn-extend|</a>を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;excludenl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 行末の&quot;$&quot;を含んでいるパターンに対して、行末以<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;降までマッチやアイテムを拡張しないようにする。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;終了パターンに対してのみ使い道がある。適用する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;パターンの前に置かねばならない。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-excludenl">|:syn-excludenl|</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start={start_pattern}&nbsp;&nbsp; リージョンの開始を定義する検索パターン。後述の<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-pattern">|:syn-pattern|</a>を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skip={skip_pattern}&nbsp;&nbsp;&nbsp;&nbsp; その中ではリージョンの終了を探さないテキストを<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定義する検索パターン。<a class="Identifier" href="syntax.html#:syn-pattern">|:syn-pattern|</a>を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end={end_pattern}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; リージョンの終了を定義する検索パターン。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;後述の<a class="Identifier" href="syntax.html#:syn-pattern">|:syn-pattern|</a>を参照。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例:<br>
<span class="Comment">&nbsp;&nbsp;:syntax region String&nbsp;&nbsp; start=+&quot;+&nbsp;&nbsp;skip=+\\&quot;+&nbsp;&nbsp;end=+&quot;+</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start/skip/endパターンとオプションはどんな順序で書いてもよい。skip<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;パターンは0個か1個許される。startとendパターンは1個以上なければならな<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;い。つまりskipパターンは省略できるが、少なくとも1つのstartとendパター<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ンを書かなければならない。等号記号の前後にはホワイトスペースがあっても<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;よい(たいていはホワイトスペースがないほうが見やすいが)。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2個以上のstartパターンが与えられたときは、それらの1つがマッチすれば十<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分である。つまりstartパターンらの間にはOR関係があることになる。最後に<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マッチしたものが使われる。endパターンについても同じである。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endパターンの検索はstartパターンの直後から行われる。これはendパターン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;のマッチとstartパターンは決して重ならないことを意味する。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skipとendパターンは改行をまたいでマッチしてもよい。しかしパターンの検<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;索はどの行からも始まりうるので、望みどおりにならないこともある。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skipパターンは次の行のendパターンのマッチを回避しない。問題を避けるには<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;単一行のパターンを使うこと。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>: リージョンの開始は、startパターンのマッチによってのみ決まる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endパターンの照合のチェックはされない。次のは機能しない:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn region First&nbsp;&nbsp;start=&quot;(&quot;&nbsp;&nbsp;end=&quot;:&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn region Second start=&quot;(&quot;&nbsp;&nbsp;end=&quot;;&quot;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2番目のは常にFirstより前にマッチする(最後に定義されたパターンが優先され<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;る)。こうすると、その前に':'があるかどうかに関わらず、2番目のリージョ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ンが次の';'まで続く。マッチを使うとうまくいく:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn match First&nbsp;&nbsp;&quot;(\_.\{-}:&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn match Second &quot;(\_.\{-};&quot;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; このパターンは&quot;\_.&quot;によって任意の文字と改行にマッチし、&quot;\<span class="Special">{-}</span>&quot;によって<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;繰り返しにマッチする(最小限の個数の繰り返し)。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-keepend" name=":syn-keepend">*:syn-keepend*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;デフォルトでは内包されたマッチはendパターンのマッチを隠す。これはネス<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ト用に便利である。例えば、&quot;{&quot;で始まり&quot;}&quot;で終わるリージョンがもう1つの<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リージョンを含むことができる。&quot;}&quot;に出会うと内包されたリージョンが終わ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;り、外側のリージョンは終了しない:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 外側の&quot;{}&quot;リージョンの開始<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内包された&quot;{}&quot;リージョンの開始<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内包された&quot;{}&quot;リージョンの終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 外側の&quot;{}&quot;リージョンの終了<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;この挙動が望みでないなら、引数&quot;keepend&quot;をつければ、外側のリージョンの<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endパターンのマッチによって内包されたアイテムも終了させることができる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;そうすると同一リージョンのネストが不可能になるが、内包されたアイテムで<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endパターンをスキップさせることなく、endパターンの一部をハイライトする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ことができる。例:<br>
<span class="Comment">&nbsp;&nbsp;:syn match&nbsp;&nbsp;vimComment +&quot;[^&quot;]\+$+</span><br>
<span class="Comment">&nbsp;&nbsp;:syn region vimCommand start=&quot;set&quot; end=&quot;$&quot; contains=vimComment keepend</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;keepend&quot;によってvimCommandが常に行末で終わるようにしている。たとえ内<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包されたvimCommentが<span class="Special">&lt;EOL&gt;</span>とのマッチを含んでいてもそのようになる。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;keepend&quot;が使われないときは、内包されたマッチの後でendパターンのマッチ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;が検索される。&quot;keepend&quot;が含まれているときは最初にendパターンにマッチし<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;たところで終了し、内包されたマッチもすべてそこで終了になる。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-extend" name=":syn-extend">*:syn-extend*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引数&quot;extend&quot;を使うと&quot;keepend&quot;の挙動が変わる。&quot;keepend&quot;付きのアイテム中<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;に&quot;extend&quot;付きのアイテムが内包されていると、&quot;keepend&quot;が無視され、外側<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;のリージョンが拡張される。これによっていくつかのアイテムに対して例外的<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;にリージョンを拡張させるようにできる。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :syn region htmlRef start=+&lt;a&gt;+ end=+&lt;/a&gt;+ keepend contains=htmlItem,htmlScript</span><br>
<span class="Comment">&nbsp;&nbsp; :syn match htmlItem +&lt;[^&gt;]*&gt;+ contained</span><br>
<span class="Comment">&nbsp;&nbsp; :syn region htmlScript start=+&lt;script+ end=+&lt;/script[^&gt;]*&gt;+ contained extend</span><br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;この例では、htmlItemの位置でhtmlRefが終了する。htmlItemは&lt;&gt;要素をハイ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ライトするためだけに使われる。htmlScriptアイテムはhtmlRefアイテムを拡<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;張する。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;もう1つの例:<br>
<span class="Comment">&nbsp;&nbsp; :syn region xmlFold start=&quot;&lt;a&gt;&quot; end=&quot;&lt;/a&gt;&quot; fold transparent keepend extend</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;&lt;/a&gt;&quot;を別の色でハイライトしたいときなどのために、&quot;keepend&quot;つきでリー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ジョンを定義し、内包するアイテムによって終端が変更されないようにしてい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;る。ただしxmlFoldがネストしたとき(それ自身を含んだとき)、&quot;extend&quot;が適<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用され、内側の&quot;&lt;/a&gt;&quot;はそのリージョン自身だけを終了させ、それを含んでい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;るリージョンは終了しない。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-excludenl" name=":syn-excludenl">*:syn-excludenl*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マッチ用のパターンやリージョンの終了パターンが行末にマッチさせるために<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'$'を含んでいると、それを含むリージョンアイテムが次の行まで継続するよ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;うになる。例えば、&quot;\\$&quot;(行末のバックスラッシュ)とのマッチを使うと、通<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常は行末で終了するはずのリージョンを継続させることができる。これはデ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;フォルトの挙動である。これが望みどおりでないなら、これをされる2つの方<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;法がある:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 外側のアイテムに&quot;keepend&quot;を使う。こうすると含んでいるアイテム全てに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 対して拡張しないようにする。含んでいるアイテム全てが外側のアイテム<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; を拡張してはならないときに使える。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 内側のアイテムに&quot;excludenl&quot;を使う。こうするとそのマッチに対して、そ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; れを含んでいるマッチやリージョンを拡張しないようにする。これはいく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; つかのアイテムだけが外側のアイテムを拡張してはならないときに使える。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;excludenl&quot;はそれを適用するパターンの前に置かねばならない。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-matchgroup" name=":syn-matchgroup">*:syn-matchgroup*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;matchgroup&quot;は、リージョンの本体とその開始・終了パターンに対して異なる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ハイライトをしたいときに使える。例:<br>
<span class="Comment">&nbsp;&nbsp;:syntax region String matchgroup=Quote start=+&quot;+&nbsp;&nbsp;skip=+\\&quot;+&nbsp;&nbsp;end=+&quot;+</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; こうすると引用符を&quot;Quote&quot;グループでハイライトし、その間にあるテキスト<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;を&quot;String&quot;グループでハイライトすることができる。&quot;matchgroup&quot;はそれが従<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;うすべての開始・終了パターンに対して使われる。matchgroupを使わないよう<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;に戻すには&quot;matchgroup=NONE&quot;を使う。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;開始・終了パターンが&quot;matchgroup&quot;でハイライトされるとき、そのリージョン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;に含まれているアイテムは無視される。これによって含まれているアイテムが<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;開始・終了パターンにマッチするのを避けることができる。&quot;transparent&quot;を<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使っている場合、これは&quot;matchgroup&quot;でハイライトされる開始・終了パターン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;のマッチ部分には適用されない。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;次の例は、3段階の括弧を異なる色でハイライトする例である:<br>
<span class="Comment">&nbsp;&nbsp; :sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2</span><br>
<span class="Comment">&nbsp;&nbsp; :sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained</span><br>
<span class="Comment">&nbsp;&nbsp; :sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained</span><br>
<span class="Comment">&nbsp;&nbsp; :hi par1 ctermfg=red guifg=red</span><br>
<span class="Comment">&nbsp;&nbsp; :hi par2 ctermfg=blue guifg=blue</span><br>
<span class="Comment">&nbsp;&nbsp; :hi par3 ctermfg=darkgreen guifg=darkgreen</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#E849" name="E849">*E849*</a><br>
構文グループの最大数は 19999 です。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
6. :syntaxの引数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-arguments" name=":syn-arguments">*:syn-arguments*</a><br>
<br>
構文アイテムを定義する:syntaxコマンドにはたくさんの引数がある。<br>
ここでは共通のものを説明する。引数はどんな順序でもよく、パターンと混ざっていて<br>
もよい。<br>
<br>
全てのコマンドが全ての引数を受けいれるわけではない。次の表はどの引数がどのコマ<br>
ンドに対して利用可能かを示している:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#E395" name="E395">*E395*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">contains&nbsp;&nbsp;oneline&nbsp;&nbsp; fold&nbsp;&nbsp;display&nbsp;&nbsp;extend concealends</span><br>
:syntax keyword&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-<br>
:syntax match&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yes&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp; -<br>
:syntax region&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yes&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp; yes&nbsp;&nbsp;&nbsp;&nbsp;yes<br>
<br>
以下の引数は3つのコマンド全てに対して使える:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conceal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cchar<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contained<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containedin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextgroup<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transparent<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skipwhite<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skipnl<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skipempty<br>
<br>
conceal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#conceal" name="conceal">*conceal*</a>&nbsp;<a class="Constant" href="syntax.html#:syn-conceal" name=":syn-conceal">*:syn-conceal*</a><br>
訳注: conceal = 隠す、秘密にする<br>
<br>
&quot;conceal&quot; 引数が指定されると、そのアイテムは Conceal 可能になります。アイテム<br>
が実際に Conceal 表示されるかどうかは&nbsp;<a class="Type" href="options.html#'conceallevel'">'conceallevel'</a>&nbsp;オプションの設定に依存し<br>
ます。現在行のアイテムを Conceal 表示するかどうかは&nbsp;<a class="Type" href="options.html#'concealcursor'">'concealcursor'</a>&nbsp;オプション<br>
で制御できます (行の編集を妨げないようにするため)。<br>
<br>
concealends&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-concealends" name=":syn-concealends">*:syn-concealends*</a><br>
<br>
&quot;concealends&quot; 引数が指定されると、リージョンの開始部分と終了部分が Conceal 可<br>
能になります (リージョンの中身はなりません)。アイテムが実際に Conceal 表示され<br>
るかどうかは&nbsp;<a class="Type" href="options.html#'conceallevel'">'conceallevel'</a>&nbsp;の設定に依存します。&quot;matchgroup&quot; で別のハイライト<br>
を設定することでリージョンの終了部分だけを別に Conceal 表示するということもで<br>
きます。<br>
<br>
cchar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-cchar" name=":syn-cchar">*:syn-cchar*</a><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#E844" name="E844">*E844*</a><br>
&quot;cchar&quot; 引数はアイテムが Conceal 表示されたときに実際に画面に表示される文字を<br>
定義します (&quot;cchar&quot; は conceal 引数が指定されたときのみ意味を持ちます)。<br>
&quot;cchar&quot; が指定されていない場合はデフォルトの Conceal 文字として&nbsp;<a class="Type" href="options.html#'listchars'">'listchars'</a>&nbsp;オ<br>
プションが使われます。Tab 文字のようなコントロール文字は使用できません。例:<br>
<span class="Comment">&nbsp;&nbsp; :syntax match Entity &quot;&amp;amp;&quot; conceal cchar=&amp;</span><br>
ハイライトについては&nbsp;<a class="Identifier" href="syntax.html#hl-Conceal">|hl-Conceal|</a>&nbsp;を参照してください。<br>
<br>
contained&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-contained" name=":syn-contained">*:syn-contained*</a><br>
<br>
引数&quot;contained&quot;が与えられると、そのアイテムはトップレベルでは認識されず、他の<br>
マッチの&quot;contains&quot;フィールドで指定されたときのみ認識される。例:<br>
<span class="Comment">&nbsp;&nbsp; :syntax keyword Todo&nbsp;&nbsp;&nbsp;&nbsp;TODO&nbsp;&nbsp;&nbsp;&nbsp;contained</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax match&nbsp;&nbsp; Comment &quot;//.*&quot;&nbsp;&nbsp;contains=Todo</span><br>
<br>
<br>
display&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-display" name=":syn-display">*:syn-display*</a><br>
<br>
引数&quot;display&quot;が与えられると、そのアイテムは検出されたハイライトが表示されない<br>
時にはスキップされる。こうすることで、表示されるべきテキストの構文状態だけを検<br>
索するときにはこのアイテムはスキップされ、ハイライトが高速になる。<br>
<br>
通常は、以下の条件に合うときマッチとリージョンに&quot;display&quot;を使うとよい:<br>
- アイテムが行末を越えて継続しない。Cの例: &quot;/*&quot;コメント用のリージョンは<br>
&nbsp;&nbsp;&quot;display&quot;を含んではならない。なぜなら次の行に継続するからである。<br>
- アイテムが、行を越えて継続したり、そのコンテナを次行まで継続させる効果を持つ<br>
&nbsp;&nbsp;子アイテムを含んでいない。<br>
- それを含むどんなアイテムのサイズも変更しない。Cの例: プリプロセッサマッチ中<br>
&nbsp;&nbsp;の&quot;\\$&quot;とのマッチは&quot;display&quot;を含んではならない。なぜならこれによってプリプロ<br>
&nbsp;&nbsp;セッサマッチが短くなるかもしれないからである。<br>
- 他のアイテムがマッチすることを許さず、そうでなければマッチせず、加えてマッチ<br>
&nbsp;&nbsp;自体が非常に長くなるようなアイテム。<br>
&nbsp;&nbsp;Cの例: &quot;//&quot;コメント用のマッチは&quot;display&quot;を使ってはならない。なぜならそのコメ<br>
&nbsp;&nbsp;ントの内側の&quot;/*&quot;がマッチするかも知れず、そうなると行末をまたぐコメントが始ま<br>
&nbsp;&nbsp;るからである。<br>
<br>
例としてC言語では次のとき&quot;display&quot;が使える:<br>
- 数字とのマッチ<br>
- ラベルとのマッチ<br>
<br>
<br>
transparent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-transparent" name=":syn-transparent">*:syn-transparent*</a><br>
<br>
引数&quot;transparent&quot;が与えられると、そのアイテムはそれ自身ではハイライトされず、<br>
それを含むアイテムのハイライトを引き継ぐ。これはハイライトはせず、テキストの一<br>
部をスキップするためだけに使われる構文アイテムに対して有効である。<br>
<br>
transparentなアイテム自身に引数&quot;contains&quot;が与えられていない場合、それを含むア<br>
イテムから引数&quot;contains=&quot;も受け継がれる。望まないアイテムが含まれるのを避ける<br>
には&quot;contains=NONE&quot;とすること。文字列中の単語をハイライトするが、&quot;vim&quot;だけは<br>
例外とする例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn match myString /'[^']*'/ contains=myWord,myVim</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn match myWord&nbsp;&nbsp; /\&lt;[a-z]*\&gt;/ contained</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn match myVim&nbsp;&nbsp;&nbsp;&nbsp;/\&lt;vim\&gt;/ transparent contained contains=NONE</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:hi link myString String</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:hi link myWord&nbsp;&nbsp; Comment</span><br>
&quot;myVimが&quot;myWord&quot;の後に来ているので、&quot;myVim&quot;が優先される(同じ位置で複数のアイテ<br>
ムにマッチした場合、最後に定義されたものが前のものを上書きする)。&quot;transparent&quot;<br>
により、&quot;myVim&quot;にマッチしたテキストは&quot;myString&quot;と同じハイライトになる。しかし<br>
&quot;myVim&quot;は何も含まない。もし&quot;contains=NONE&quot;を取り除くと、&quot;myVim&quot;は&quot;myString&quot;か<br>
ら引数containsを受け継いで&quot;myWord&quot;を含むようになり、テキスト&quot;vim&quot;はConstantと<br>
してハイライトされる。これは、内包されたマッチは同じ位置でそれ自身の内側でマッ<br>
チしないためこうなる。つまり、ここではマッチ&quot;myVim&quot;は&quot;マッチmyWord&quot;を上書きし<br>
ない。<br>
<br>
色づけされたテキストは、内包されたアイテムの層のようにみなすことができる。内包<br>
されたアイテムは内包しているアイテムより上にあり、そのため内包されたアイテムを<br>
見ることができる。内包されたアイテムがtransparentな場合、それを透過して見るこ<br>
とができ、よってそれを含んでいるアイテムが見える。図にすると:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ここから見る<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp; |<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp; V&nbsp;&nbsp; V&nbsp;&nbsp; V&nbsp;&nbsp; V&nbsp;&nbsp; V<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xxxx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yyy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; さらに内包されたアイテム達<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....................&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内包されたアイテム (transparent)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=============================&nbsp;&nbsp; 最初のアイテム (最も外側のアイテム)<br>
<br>
'x', 'y', '='はハイライトされた構文アイテムを表す。'.'はtransparentなグループ<br>
を表している。<br>
<br>
このとき次のように見える:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=======xxxx=======yyy========<br>
<br>
つまりtransparentな&quot;....&quot;は透過して見える。<br>
<br>
<br>
oneline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-oneline" name=":syn-oneline">*:syn-oneline*</a><br>
<br>
引数&quot;oneline&quot;をつけると、そのリージョンは行をまたがないという意味になる。つま<br>
り、現在行の中で完全にマッチしなければならない。しかし、そのリージョンが行をま<br>
たぐアイテムを内包している場合は次の行に継続する。内包されたアイテムによって行<br>
継続パターンを認識することができる。しかしその場合でも&quot;end&quot;パターンは最初の行<br>
内でマッチしなければならない。そうでないとリージョンは開始すらしない。<br>
<br>
startパターンが行末にマッチする&quot;\n&quot;を含んでいるときは、startパターンの終了位置<br>
と同じ行にendパターンがなければならない。endパターンも行末を含んでもよい。<br>
つまり引数&quot;oneline&quot;は、startパターンの終了位置とendパターンの開始位置が同一行<br>
にあることを意味する。改行にマッチするskipパターンを使ってもこの規則を変えるこ<br>
とはできない。<br>
<br>
fold&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-fold" name=":syn-fold">*:syn-fold*</a><br>
<br>
引数&quot;fold&quot;はこのアイテムに対して折り畳みレベルを1増加させる。例:<br>
<span class="Comment">&nbsp;&nbsp; :syn region myFold start=&quot;{&quot; end=&quot;}&quot; transparent fold</span><br>
<span class="Comment">&nbsp;&nbsp; :syn sync fromstart</span><br>
<span class="Comment">&nbsp;&nbsp; :set foldmethod=syntax</span><br>
これは{}ブロックごとに1つの折り畳みを作らせる。<br>
<br>
折り畳みはそのアイテムの開始位置から始まり、アイテムの終了位置で終わる。開始位<br>
置と終了位置が同一行にある場合、折り畳みは作られない。<br>
オプション<a class="Type" href="options.html#'foldnestmax'">'foldnestmax'</a>によって構文折り畳みのネストを制限できる。<br>
{<a class="Identifier" href="various.html#+folding">|+folding|</a>機能なしでコンパイルされた場合は利用できない}<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-contains" name=":syn-contains">*:syn-contains*</a>&nbsp;<a class="Constant" href="syntax.html#E405" name="E405">*E405*</a>&nbsp;<a class="Constant" href="syntax.html#E406" name="E406">*E406*</a>&nbsp;<a class="Constant" href="syntax.html#E407" name="E407">*E407*</a>&nbsp;<a class="Constant" href="syntax.html#E408" name="E408">*E408*</a>&nbsp;<a class="Constant" href="syntax.html#E409" name="E409">*E409*</a><br>
contains=<span class="Special">{groupname}</span>,..<br>
<br>
引数&quot;contains&quot;の後には構文グループ名のリストを続ける。&quot;contains&quot;で指定されたグ<br>
ループは、そのアイテムの内側で始まることを許可される(内包されるグループによっ<br>
ては、外側のアイテムの終端が拡張されることもある)。これを使うと、マッチとリー<br>
ジョンが再帰的にネストできるようになる。引数&quot;contains&quot;がまったく指定されない場<br>
合は、そのアイテムはどんなグループも内包しない。ここで使うグループ名は、必ずし<br>
も以前に定義していなくてもよい。<br>
<br>
contains=ALL<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containsリストが&quot;ALL&quot;だけのとき、全てのグループがこのアイテム<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;の内側で許可される。<br>
<br>
contains=ALLBUT,<span class="Special">{group-name}</span>,..<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containsリストの最初の要素が&quot;ALLBUT&quot;のとき、<span class="Special">{group-name}</span>で列挙<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;したグループを除く全てのグループがこのアイテムの内側で許可され<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;る。例:<br>
<span class="Comment">&nbsp;&nbsp;:syntax region Block start=&quot;{&quot; end=&quot;}&quot; ... contains=ALLBUT,Function</span><br>
<br>
contains=TOP<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containsリストの最初の要素が&quot;TOP&quot;のとき、引数&quot;contained&quot;を持た<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ないグループ全てが許可される。<br>
contains=TOP,<span class="Special">{group-name}</span>,..<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;TOP&quot;と同様だが、<span class="Special">{group-name}</span>に列挙したグループは除かれる。<br>
<br>
contains=CONTAINED<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;containsリストの最初の要素が&quot;CONTAINED&quot;のとき、引数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;contained&quot;を持つグループ全てが許可される。<br>
contains=CONTAINED,<span class="Special">{group-name}</span>,..<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;CONTAINED&quot;と同様だが、<span class="Special">{group-name}</span>に列挙したグループは除かれ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;る。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
<br>
&quot;contains&quot;リスト内の<span class="Special">{group-name}</span>はパターンであってもよい。そのパターンにマッチ<br>
するグループ名全てが含まれる(&quot;ALLBUT&quot;が使われたときはそれが除かれる)。パターン<br>
はホワイトスペースや','を含んではならない。例:<br>
<span class="Comment">&nbsp;&nbsp; ... contains=Comment.*,Keyw[0-3]</span><br>
パターンの照合はそのsyntaxコマンドが実行されたときに行われる。それ以降に定義さ<br>
れたグループは照合されない。また、現在のsyntaxコマンドが新しいグループを定義し<br>
ている場合、そのグループは照合されない。ファイル内にsyntaxコマンドを書く場合、<br>
定義されていないグループを当てにすることはできないことに注意。これは、そのファ<br>
イルは以前に読み込まれているかもしれず、&quot;:syn clear&quot;はグループ名を削除しないた<br>
めである。<br>
<br>
内包されたグループはリージョンのstartとendパターン内にもマッチする。これが望み<br>
の挙動でないなら、引数&quot;matchgroup&quot;を使うとよい<a class="Identifier" href="syntax.html#:syn-matchgroup">|:syn-matchgroup|</a>。オフセット<br>
&quot;ms=&quot;と&quot;me=&quot;によって内包されたアイテムがマッチする領域を変更することができる。<br>
これはハイライトされる範囲も制限することに注意。<br>
<br>
<br>
containedin=<span class="Special">{groupname}</span>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-containedin" name=":syn-containedin">*:syn-containedin*</a><br>
<br>
引数&quot;containedin&quot;の後には構文グループ名のリストを続ける。するとこのアイテムが<br>
それらのグループの内側で始まることが許可される。これは外側のアイテムが引数<br>
&quot;contains=&quot;でこのアイテムを指定したのと同じように動作する。<br>
<br>
<span class="Special">{group-name}</span>...の指定の仕方は前述の&quot;contains&quot;と同様である。<br>
<br>
これは構文アイテムを後から追加するときに便利である。既に定義されているアイテム<br>
の定義を変更することなく、その内側にアイテムを含めることができる。例えば、Cの<br>
構文を読み込んだ後で、Cコメント中の単語をハイライトしたいときは:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:syn keyword myword HELP containedin=cComment contained</span><br>
このアイテムがトップレベルではマッチしないように&quot;contained&quot;を使っている。<br>
<br>
&quot;containedin&quot;の照合は、このアイテムが現れる場所に追加される。引数&quot;contains&quot;も<br>
通常通り追加される。注意: キーワードは他のアイテムを含むことができないため、<br>
&quot;containedin&quot;の先にキーワードを指定することは無意味である。<br>
<br>
<br>
nextgroup=<span class="Special">{groupname}</span>,..&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-nextgroup" name=":syn-nextgroup">*:syn-nextgroup*</a><br>
<br>
引数&quot;nextgroup&quot;の後には構文グループ名のリストをカンマ区切りで続ける<br>
(&quot;contains&quot;と同様。パターンを使うこともできる)。<br>
<br>
引数&quot;nextgroup&quot;が与えられると、マッチやリージョンの終了位置の後ろで、指定され<br>
た構文グループにマッチする部分が探される。どのグループもマッチしなければ、ハイ<br>
ライトは通常通り続けられる。マッチが見つかった場合はそのグループが使われる。現<br>
在のグループの引数&quot;contains&quot;でそのグループが指定されていなくてもそうなる。つま<br>
り、これは指定されたグループの優先度を最大にすることと同じである。例:<br>
<span class="Comment">&nbsp;&nbsp; :syntax match&nbsp;&nbsp;ccFoobar&nbsp;&nbsp;&quot;Foo.\{-}Bar&quot;&nbsp;&nbsp;contains=ccFoo</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax match&nbsp;&nbsp;ccFoo&nbsp;&nbsp;&nbsp;&nbsp; &quot;Foo&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; contained nextgroup=ccFiller</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax region ccFiller&nbsp;&nbsp;start=&quot;.&quot;&nbsp;&nbsp;matchgroup=ccBar&nbsp;&nbsp;end=&quot;Bar&quot;&nbsp;&nbsp;contained</span><br>
<br>
これは&quot;Foo&quot;の後に&quot;Bar&quot;が現れたときのみ、&quot;Foo&quot;と&quot;Bar&quot;に異なるハイライトをする。<br>
以下のテキストにおいて、&quot;f&quot;と書いたところはccFooでハイライトされ、&quot;bbb&quot;と書い<br>
たところはccBarでハイライトされる。<br>
<br>
<span class="Comment">&nbsp;&nbsp; Foo asdfasd Bar asdf Foo asdf Bar asdf</span><br>
<span class="Comment">&nbsp;&nbsp; fff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bbb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bbb</span><br>
<br>
&quot;.\<span class="Special">{-}</span>&quot;を使い、次のBarまでのスキップが最小になるようにしている。もし&quot;.*&quot;を使う<br>
と、最初の&quot;Foo&quot;と最後の&quot;Bar&quot;がccFooBarのマッチ部分に含まれるため、&quot;Bar&quot;と&quot;Foo&quot;<br>
の間の&quot;asdf&quot;が&quot;ccFoobar&quot;グループとしてハイライトされてしまう(<a class="Identifier" href="pattern.html#pattern">|pattern|</a>を参照)。<br>
<br>
<br>
skipwhite&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-skipwhite" name=":syn-skipwhite">*:syn-skipwhite*</a><br>
skipnl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-skipnl" name=":syn-skipnl">*:syn-skipnl*</a><br>
skipempty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-skipempty" name=":syn-skipempty">*:syn-skipempty*</a><br>
<br>
これら3個の引数は&quot;nextgroup&quot;と組み合わせたときのみ意味を持つ。これらを指定する<br>
と、次のグループがマッチする前に、以下のテキストがあってもよくなる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skipwhite&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; スペースとタブ文字をスキップする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skipnl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行末をスキップする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skipempty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 空行をスキップする(自動的に&quot;skipnl&quot;も含むことになる)<br>
<br>
例えば&quot;skilwhite&quot;を指定した場合、次のどのグループもホワイトスペースにマッチし<br>
ないならば、ホワイトスペースをスキップする。<br>
<br>
&quot;skipnl&quot;を指定すると、nextgroupの照合が次の行からも探される。これは現在のアイ<br>
テムが行末で終わったときのみ有効である。&quot;skipnl&quot;を指定しない場合、nextgroupは<br>
同一行のそのアイテム以降から照合される。<br>
<br>
次のグループまでスキップされたテキストの中では他のグループの照合は無視される。<br>
次のグループの照合が見つからなかったとき、再び他のグループの照合が検索される。<br>
つまり、次のグループの照合と、ホワイトスペースと<span class="Special">&lt;EOL&gt;</span>のスキップは他のアイテム<br>
より優先される。<br>
<br>
例:<br>
<span class="Comment">&nbsp;&nbsp;:syn match ifstart &quot;\&lt;if.*&quot;&nbsp;&nbsp;&nbsp;&nbsp; nextgroup=ifline skipwhite skipempty</span><br>
<span class="Comment">&nbsp;&nbsp;:syn match ifline&nbsp;&nbsp;&quot;[^ \t].*&quot; nextgroup=ifline skipwhite skipempty contained</span><br>
<span class="Comment">&nbsp;&nbsp;:syn match ifline&nbsp;&nbsp;&quot;endif&quot;&nbsp;&nbsp;&nbsp;&nbsp;contained</span><br>
<span class="Todo">Note</span>&nbsp;マッチ&quot;[^ \t].*&quot;はホワイトスペース以外の全てのテキストにマッチする。よっ<br>
て&quot;endif&quot;にもマッチする。そのためマッチ&quot;endif&quot;を最後に置き、最優先にしている。<br>
<span class="Todo">Note</span>&nbsp;この例はネストした&quot;if&quot;には機能しないことに注意。ネストに対応するには引数<br>
&quot;contains&quot;を指定する必要がある(この例では簡単のため省略した)。<br>
<br>
暗黙 CONCEAL (IMPLICIT CONCEAL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-conceal-implicit" name=":syn-conceal-implicit">*:syn-conceal-implicit*</a><br>
<br>
:sy[ntax] conceal [on|off]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;これ以降の &quot;:syntax&quot; コマンドでキーワード、マッチ、リージョンを定義し<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;たときに &quot;conceal&quot; フラグをセットするかどうかを定義します。&quot;:syn<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conceal on&quot; を実行した後で &quot;:syn keyword&quot;、&quot;:syn match&quot;、&quot;:syn region&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;を実行すると、暗黙的に &quot;conceal&quot; フラグがセットされます。&quot;:syn conceal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;off&quot; を実行することで通常の状態、つまり &quot;conceal&quot; フラグを明示的に設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;しなければならない状態に戻ります。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
7. syntaxのパターン&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-pattern" name=":syn-pattern">*:syn-pattern*</a>&nbsp;<a class="Constant" href="syntax.html#E401" name="E401">*E401*</a>&nbsp;<a class="Constant" href="syntax.html#E402" name="E402">*E402*</a><br>
<br>
syntaxコマンドでは、パターンの前後を同じ文字で囲まなければならない。これは<br>
&quot;:s&quot;コマンドと同様である。もっともよく使われるのはダブルクォートである。しかし<br>
パターンがダブルクォートを含んでいる場合は、そのパターンが含んでいない他の文字<br>
を使ったほうがよい。例:<br>
<span class="Comment">&nbsp;&nbsp;:syntax region Comment&nbsp;&nbsp;start=&quot;/\*&quot;&nbsp;&nbsp;end=&quot;\*/&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;:syntax region String&nbsp;&nbsp; start=+&quot;+&nbsp;&nbsp;&nbsp;&nbsp;end=+&quot;+&nbsp;&nbsp; skip=+\\&quot;+</span><br>
<br>
パターンの説明については<a class="Identifier" href="pattern.html#pattern">|pattern|</a>を参照。構文パターンは常に<a class="Type" href="options.html#'magic'">'magic'</a>オプションが<br>
セットされているのと同じように解釈される(実際の<a class="Type" href="options.html#'magic'">'magic'</a>オプションの値とは無関<br>
係)。また、<a class="Type" href="options.html#'cpoptions'">'cpoptions'</a>に'l' フラグが含まれていない場合と同じように解釈される。<br>
これは構文ファイルの可搬性を高め、<a class="Type" href="options.html#'compatible'">'compatible'</a>と<a class="Type" href="options.html#'magic'">'magic'</a>の設定と無関係にするた<br>
めである。<br>
<br>
&quot;[a-z]*&quot;など空文字列にマッチするパターンは避けること。これは全ての位置にマッチ<br>
するため、ハイライトがとても遅くなる。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-pattern-offset" name=":syn-pattern-offset">*:syn-pattern-offset*</a><br>
パターンに文字数のオフセットを指定することができる。これによってハイライトされ<br>
る部分を変更したり、マッチやリージョンに含まれるテキスト領域(これは他のアイテ<br>
ムを照合するときにだけ関係する)を変更することができる。どちらもマッチしたパター<br>
ンに相対的である。skipパターンに対して文字数のオフセットを指定すると、endパター<br>
ンの検索が始まる位置を決めることができる。<br>
<br>
オフセットは&quot;<span class="Special">{what}</span>=<span class="Special">{offset}</span>&quot;の形で指定する。<br>
<span class="Special">{what}</span>は次の7個の文字列のどれかである:<br>
<br>
ms&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match Start&nbsp;&nbsp;&nbsp;&nbsp; マッチしたテキストの開始位置のオフセット<br>
me&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match End&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; マッチしたテキストの終了位置のオフセット<br>
hs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Highlight Start ハイライトが始まる位置のオフセット<br>
he&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Highlight End&nbsp;&nbsp; ハイライトが終わる位置のオフセット<br>
rs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Region Start&nbsp;&nbsp;&nbsp;&nbsp;リージョンの本体が始まる位置のオフセット<br>
re&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Region End&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リージョンが終わる位置のオフセット<br>
lc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Leading Context パターンの&quot;leading context&quot;を過ぎた後のオフセット<br>
<br>
<span class="Special">{offset}</span>は次のうちのどれか:<br>
<br>
s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; パターンのマッチ部分の先頭<br>
s+<span class="Special">{nr}</span>&nbsp;&nbsp;パターンのマッチ部分の先頭から右へ<span class="Special">{nr}</span>文字目<br>
s-<span class="Special">{nr}</span>&nbsp;&nbsp;パターンのマッチ部分の先頭から左へ<span class="Special">{nr}</span>文字目<br>
e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; パターンのマッチ部分の末尾<br>
e+<span class="Special">{nr}</span>&nbsp;&nbsp;パターンのマッチ部分の末尾から右へ<span class="Special">{nr}</span>文字目<br>
e-<span class="Special">{nr}</span>&nbsp;&nbsp;パターンのマッチ部分の末尾から左へ<span class="Special">{nr}</span>文字目<br>
<span class="Special">{nr}</span>&nbsp;&nbsp;&nbsp;&nbsp;(&quot;lc&quot;専用): ら左へ<span class="Special">{nr}</span>文字目<br>
<br>
例: &quot;ms=s+1&quot;, &quot;hs=e-2&quot;, &quot;lc=3&quot;.<br>
<br>
どのパターンの後にどのオフセットを指定してもよいが、それが意味を持たない場合も<br>
ある。次の表はどのオフセットが実際に有効かを示している:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">ms&nbsp;&nbsp; me&nbsp;&nbsp; hs&nbsp;&nbsp; he&nbsp;&nbsp; rs&nbsp;&nbsp; re&nbsp;&nbsp; lc</span><br>
match item&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yes&nbsp;&nbsp;yes&nbsp;&nbsp;yes&nbsp;&nbsp;yes&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;yes<br>
region item start&nbsp;&nbsp; yes&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;yes&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;yes&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;yes<br>
region item skip&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;yes&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;yes<br>
region item end&nbsp;&nbsp;&nbsp;&nbsp; -&nbsp;&nbsp;&nbsp;&nbsp;yes&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;yes&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;yes&nbsp;&nbsp;yes<br>
<br>
複数のオフセットの間に','を入れて連結することができる。例:<br>
<span class="Comment">&nbsp;&nbsp;:syn match String&nbsp;&nbsp;/&quot;[^&quot;]*&quot;/hs=s+1,he=e-1</span><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;some &quot;string&quot; text<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^^^^^^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ここがハイライトされる<br>
<br>
注意:<br>
- パターンとオフセットの間にホワイトスペースを挟んではならない。<br>
- ハイライトされる領域がマッチしたテキストの外側にはみ出してはならない。<br>
- endパターンに対する負のオフセットは機能しない場合がある。これはハイライトが<br>
&nbsp;&nbsp;既に終わっているべきとき、endパターンは検出されない可能性があるからである。<br>
- Vim 7.2 以前では、オフセットは文字単位でなくバイト単位であった。それではマル<br>
&nbsp;&nbsp;チバイト文字ではうまく機能しないので、7.2 から変更された。<br>
- マッチの開始位置が、パターンがマッチした位置と別の行になってはならない。つま<br>
&nbsp;&nbsp;り&quot;a\nb&quot;ms=eというのは正常に機能しない。ハイライトの開始位置は別の行にあって<br>
&nbsp;&nbsp;もかまわない。&quot;a\nb&quot;hs=eというのは正常に機能する。<br>
<br>
例(コメントにマッチするが /* と */ はハイライトしない):<br>
<span class="Comment">&nbsp;&nbsp;:syntax region Comment start=&quot;/\*&quot;hs=e+1 end=&quot;\*/&quot;he=s-1</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* this is a comment */<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^^^^^^^^^^^^^^^^^^^&nbsp;&nbsp;&nbsp;&nbsp; ここがハイライトされる<br>
<br>
より複雑な例:<br>
<span class="Comment">&nbsp;&nbsp;:syn region Exa matchgroup=Foo start=&quot;foo&quot;hs=s+2,rs=e+2 matchgroup=Bar end=&quot;bar&quot;me=e-1,he=e-1,re=s-1</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abcfoostringbarabc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mmmmmmmmmmm&nbsp;&nbsp;&nbsp;&nbsp; マッチ部分<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sssrrreee&nbsp;&nbsp;&nbsp;&nbsp; start/region/endとしてハイライトされる部分 (&quot;Foo&quot;, &quot;Exa&quot;, &quot;Bar&quot;)<br>
<br>
Leading context&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-lc" name=":syn-lc">*:syn-lc*</a>&nbsp;<a class="Constant" href="syntax.html#:syn-leading" name=":syn-leading">*:syn-leading*</a>&nbsp;<a class="Constant" href="syntax.html#:syn-context" name=":syn-context">*:syn-context*</a><br>
<br>
注意:これは古い機能であり、以前のバージョンとの後方互換性のためだけに残されて<br>
いる。現在はパターン中の<a class="Identifier" href="pattern.html#/\@<=">|/\@&lt;=|</a>コンストラクトを使うことが推奨されている。<br>
<br>
&quot;lc&quot;オフセットはリーディングコンテキストを指定する。これはパターンの一部になけ<br>
ればならないが、マッチ部分の一部とは見なされないものである。&quot;lc=n&quot;のオフセット<br>
を使うとパターンの照合を試みる前にn桁戻るようになる。リーディングコンテキスト<br>
内に他のパターンにマッチしている文字が現れてもよい。これはマッチの前方にあって<br>
はならない「エスケープ」文字を指定する場合などに使える:<br>
<br>
<span class="Comment">&nbsp;&nbsp;:syn match ZNoBackslash &quot;[^\\]z&quot;ms=s+1</span><br>
<span class="Comment">&nbsp;&nbsp;:syn match WNoBackslash &quot;[^\\]w&quot;lc=1</span><br>
<span class="Comment">&nbsp;&nbsp;:syn match Underline &quot;_\+&quot;</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;___zzzz ___wwww<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^^^&nbsp;&nbsp;&nbsp;&nbsp; ^^^&nbsp;&nbsp;&nbsp;&nbsp; Underlineにマッチする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^ ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZNoBackslashにマッチする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^^^^ WNoBackslashにマッチする<br>
<br>
&quot;ms&quot;を指定しないと自動的に&quot;lc&quot;と同じ値にセットされる。<br>
<br>
<br>
複数行にわたるパターン&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-multi-line" name=":syn-multi-line">*:syn-multi-line*</a><br>
<br>
パターンが&quot;\n&quot;を含むと改行にマッチするようになる。たいていの場合これは期待通り<br>
に動作するが、少しだけ例外がある。<br>
<br>
startパターンにオフセットをつけるとき、マッチ部分の開始位置が次の行の先頭で<br>
あってはならない。ハイライトは次の行で始まってもよい。&quot;\zs&quot; を使うときも、マッ<br>
チ部分の開始位置が他の行になってはならない。<br>
<br>
skipパターンも&quot;\n&quot;を含んでよい。ただし次の行の最初の文字がskipパターンにマッチ<br>
していても、そこからendパターンの検索が続けられる。これは、再描画は領域内のど<br>
の行でも始まることができ、skipパターンが前の行から始まったかどうかはチェックさ<br>
れないからである。例えば、skipパターンが&quot;a\nb&quot;で、endパターンが&quot;b&quot;のとき、次の<br>
テキストの2行目でendパターンがマッチする。<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x x a</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b x x</span><br>
つまり、skipパターンは&quot;\n&quot;以降の文字にはマッチしないことになる。<br>
<br>
<br>
外部マッチ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-ext-match" name=":syn-ext-match">*:syn-ext-match*</a><br>
<br>
リージョンのパターンでは特別に以下の正規表現が使える:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#/\z(" name="/\z(">*/\z(*</a>&nbsp;<a class="Constant" href="syntax.html#/\z(\)" name="/\z(\)">*/\z(\)*</a>&nbsp;<a class="Constant" href="syntax.html#E50" name="E50">*E50*</a>&nbsp;<a class="Constant" href="syntax.html#E52" name="E52">*E52*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;\z(\)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一部を「external」としてマークする。これをつけると他のパターン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;からアクセスできるようになる。現在はリージョンのstartパターン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内でのみ使用可能。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#/\z1" name="/\z1">*/\z1*</a>&nbsp;<a class="Constant" href="syntax.html#/\z2" name="/\z2">*/\z2*</a>&nbsp;<a class="Constant" href="syntax.html#/\z3" name="/\z3">*/\z3*</a>&nbsp;<a class="Constant" href="syntax.html#/\z4" name="/\z4">*/\z4*</a>&nbsp;<a class="Constant" href="syntax.html#/\z5" name="/\z5">*/\z5*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;\z1&nbsp;&nbsp;...&nbsp;&nbsp;\z9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#/\z6" name="/\z6">*/\z6*</a>&nbsp;<a class="Constant" href="syntax.html#/\z7" name="/\z7">*/\z7*</a>&nbsp;<a class="Constant" href="syntax.html#/\z8" name="/\z8">*/\z8*</a>&nbsp;<a class="Constant" href="syntax.html#/\z9" name="/\z9">*/\z9*</a>&nbsp;<a class="Constant" href="syntax.html#E66" name="E66">*E66*</a>&nbsp;<a class="Constant" href="syntax.html#E67" name="E67">*E67*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startパターンにマッチしたテキスト中からマークしておいた部分を<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参照する。<br>
<br>
リージョンのstartとendパターンで正規表現の一部を共有したい場合がある。<br>
一般的な例としてはPerlやUnixシェルのヒアドキュメントがある。これは特別な正規表<br>
現アイテム&quot;\z&quot;を使えば達成できる。これは正規表現の一部を&quot;external&quot;としてマーク<br>
しておく。するとその部分を他のパターンから参照できるようになる。例えば、ヒアド<br>
キュメントは次のようにすればよい:<br>
<span class="Comment">&nbsp;&nbsp;:syn region hereDoc start=&quot;&lt;&lt;\z(\I\i*\)&quot; end=&quot;^\z1$&quot;</span><br>
<br>
このように、\zは2つの役割を果たす。startパターンにおいては正規表現の一部<br>
&quot;\(\I\i*\)&quot;をexternalとしてマークする。endパターンでは\1によってstartパターン<br>
中の最初のマークされた部分への外部参照とする。外部参照はskipパターン中でも使え<br>
る:<br>
<span class="Comment">&nbsp;&nbsp;:syn region foo start=&quot;start \(\I\i*\)&quot; skip=&quot;not end \z1&quot; end=&quot;end \z1&quot;</span><br>
<br>
通常のマークとexternalなマークはまったく独立であり、別々に番号が振られる。例え<br>
ば、文字列&quot;aabb&quot;に対してパターン&quot;\z(..\)\(..\)&quot;を適用すると、\1は&quot;bb&quot;を参照<br>
し、\z1は&quot;aa&quot;を参照するようになる。externalなマークをした部分は、通常のマーク<br>
と違って、同一パターン内で後方参照することはできない。ある部分に対して通常の<br>
マーク、externalなマーク両方をつけたい場合は、&quot;\(\z(...\)\)&quot;のようにネストさせ<br>
ればよい。<br>
<br>
一行内でマッチした部分しか参照できないことに注意。複数行にわたってマッチした部<br>
分は参照できない。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
8. クラスタ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-cluster" name=":syn-cluster">*:syn-cluster*</a>&nbsp;<a class="Constant" href="syntax.html#E400" name="E400">*E400*</a><br>
<br>
:sy[ntax] cluster&nbsp;<span class="Special">{cluster-name}</span>&nbsp;[contains=<span class="Special">{group-name}</span>..]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [add=<span class="Special">{group-name}</span>..]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [remove=<span class="Special">{group-name}</span>..]<br>
<br>
このコマンドを使うと、複数の構文グループを1つの名前のもとにまとめることができ<br>
る。このまとまりのことをクラスタと呼ぶ。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contains=<span class="Special">{group-name}</span>..<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;クラスタに含まれるグループを指定する。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add=<span class="Special">{group-name}</span>..<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定したグループをクラスタに加える。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove=<span class="Special">{group-name}</span>..<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定したグループをクラスタからとり除く。<br>
<br>
定義したクラスタはcontains=..やcontainedin=..、nextgroup=..、add=..、remove=..<br>
などの文脈で使うことができる。そのとき、クラスタ名の頭に&quot;@&quot;をつける。クラスタ<br>
を定義する前にそのクラスタ名を使用してもよい。<br>
<br>
例:<br>
<span class="Comment">&nbsp;&nbsp; :syntax match Thing &quot;# [^#]\+ #&quot; contains=@ThingMembers</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax cluster ThingMembers contains=ThingMember1,ThingMember2</span><br>
<br>
この例からわかるように、クラスタに対する変更はさかのぼって効果がある。クラスタ<br>
の定義は直前になってチェックされる。例:<br>
<span class="Comment">&nbsp;&nbsp; :syntax keyword A aaa</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax keyword B bbb</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax cluster AandB contains=A</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax match Stuff &quot;( aaa bbb )&quot; contains=@AandB</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax cluster AandB add=B&nbsp;&nbsp;&nbsp;&nbsp;&quot; これによって2つのキーワードがStuff内で</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マッチするようになる</span><br>
<br>
これはクラスタのネスト度にも関係がある:<br>
<span class="Comment">&nbsp;&nbsp; :syntax keyword A aaa</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax keyword B bbb</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax cluster SmallGroup contains=B</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax cluster BigGroup contains=A,@SmallGroup</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax match Stuff &quot;( aaa bbb )&quot; contains=@BigGroup</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax cluster BigGroup remove=B&nbsp;&nbsp;&nbsp;&nbsp;&quot; BはBigGroup内にないので無意味</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax cluster SmallGroup remove=B&nbsp;&nbsp;&quot; Stuff内でbbbがマッチしなくなる</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#E848" name="E848">*E848*</a><br>
クラスタの最大数は 9767 です。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
9. 構文ファイルのインクルード&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-include" name=":syn-include">*:syn-include*</a>&nbsp;<a class="Constant" href="syntax.html#E397" name="E397">*E397*</a><br>
<br>
構文ファイルの中で、関係する構文ファイルをインクルードしたい場合がある。<br>
これには、構文ファイルの関係に応じて2種類の方法がある:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- インクルードされるファイル内のトップレベルのアイテムをそのままトップ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;レベルとしたい場合は、単に<a class="Identifier" href="repeat.html#:runtime">|:runtime|</a>コマンドを使えばよい:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&quot; In cpp.vim:</span><br>
<span class="Comment">&nbsp;&nbsp;:runtime! syntax/c.vim</span><br>
<span class="Comment">&nbsp;&nbsp;:unlet b:current_syntax</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - インクルードされるファイル内のトップレベルのアイテムをリージョンに内<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;包させるには、&quot;:syntax include&quot;コマンドを使うとよい:<br>
<br>
:sy[ntax] include [@<span class="Special">{grouplist-name}</span>]&nbsp;<span class="Special">{file-name}</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;インクルードされるファイル中で宣言された構文アイテム全てに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;contained&quot;フラグがつけられる。さらにグループのリストを指定すると、<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;インクルードされるファイル中のトップレベルの構文アイテム全てに対して<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;そのリストがつけられる。<br>
<br>
<span class="Comment">&nbsp;&nbsp; &quot; In perl.vim:</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax include @Pod &lt;sfile&gt;:p:h/pod.vim</span><br>
<span class="Comment">&nbsp;&nbsp; :syntax region perlPOD start=&quot;^=head&quot; end=&quot;^=cut&quot; contains=@Pod</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{file-name}</span>が絶対パスである場合(&quot;/&quot;, &quot;c:&quot;, &quot;$VAR&quot;, &quot;<span class="Special">&lt;sfile&gt;</span>&quot;のどれか<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;で始まる場合)そのファイルが読み込まれる(sourceされる)。相対パスの場<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;合(例:&quot;syntax/pod.vim&quot;)、そのファイルが<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>中から探される。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マッチしたファイル全てが読み込まれる。相対パスを使用することが推奨さ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;れる。そうすればユーザが&quot;:syn include&quot;を書き換えることなく、インク<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ルードされるファイルを改変して別の場所におけるからである。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#E847" name="E847">*E847*</a><br>
インクルードの最大数は 999 です。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
10. 表示のシンクロナイズ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-sync" name=":syn-sync">*:syn-sync*</a>&nbsp;<a class="Constant" href="syntax.html#E403" name="E403">*E403*</a>&nbsp;<a class="Constant" href="syntax.html#E404" name="E404">*E404*</a><br>
<br>
ドキュメント中のどの位置からでも再描画を開始できると望ましい。これを実現するに<br>
は、再描画を開始する位置における構文の状態を知る必要がある。<br>
<br>
:sy[ntax] sync [ccomment&nbsp;<span class="Special">[group-name]</span>&nbsp;| minlines=<span class="Special">{N}</span>&nbsp;| ...]<br>
<br>
シンクロナイズには4つのやり方がある:<br>
1. 常にファイルの最初からパースする。<br>
&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-sync-first">|:syn-sync-first|</a><br>
2. Cスタイルのコメントに基づく。VimはCコメントの仕様を理解し、現在行がコメント<br>
&nbsp;&nbsp; の内側から始まっているか外側から始まっているかを判定することができる。<br>
&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-sync-second">|:syn-sync-second|</a><br>
3. 一定行さかのぼり、そこからパースを開始する。<br>
&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-sync-third">|:syn-sync-third|</a><br>
4. テキストをさかのぼり、シンクロナイズを始める目印の正規表現を検索する。<br>
&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:syn-sync-fourth">|:syn-sync-fourth|</a><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-sync-maxlines" name=":syn-sync-maxlines">*:syn-sync-maxlines*</a>&nbsp;<a class="Constant" href="syntax.html#:syn-sync-minlines" name=":syn-sync-minlines">*:syn-sync-minlines*</a><br>
最後の3つの方法に関して、さかのぼる行数は&quot;minlines&quot;と&quot;maxlines&quot;で制限される。<br>
<br>
引数&quot;minlines=<span class="Special">{N}</span>&quot;が指定されると、常に少なくともその行数さかのぼってパースが開<br>
始される。パースする行数が少なすぎて正しくハイライトできないかもしれないとき、<br>
またはシンクロナイズを使うのが不可能であるとき、この引数を使うとよい。<br>
<br>
引数&quot;maxlines=<span class="Special">{N}</span>&quot;が指定されると、コメントや正規表現を検索するためにさかのぼる<br>
行数が最大<span class="Special">N</span>行になる。これは遅いマシンを使っていて、シンクロナイズする行数が少<br>
ないとわかっているときに便利である。例:<br>
<span class="Comment">&nbsp;&nbsp; :syntax sync ccomment maxlines=500</span><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-sync-linebreaks" name=":syn-sync-linebreaks">*:syn-sync-linebreaks*</a><br>
複数行にマッチする正規表現を使っているとき、ある行に変更を施すと、前の行でマッ<br>
チしていた正規表現がマッチしなくなってしまうことがある。この場合、変更を施した<br>
位置より上からシンクロナイズを行わなければならない。その行数を引数&quot;linebreaks&quot;<br>
で指定する。例えば、正規表現が改行を1個含んでいる場合はこのようにする:<br>
<span class="Comment">&nbsp;&nbsp; :syntax sync linebreaks=1</span><br>
こうすると、常に変更が施された行の少なくとも1行前から再描画が開始される。<br>
&quot;linebreaks&quot;のデフォルト値は0。通常&quot;minlines&quot;の値は&quot;linebreaks&quot;の値より大きい。<br>
<br>
第一の方法:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-sync-first" name=":syn-sync-first">*:syn-sync-first*</a><br>
<br>
<span class="Comment">&nbsp;&nbsp; :syntax sync fromstart</span><br>
<br>
ファイルの最初からパースする。この方法を使うと構文ハイライトが正確になるが、大<br>
きいファイルに対しては遅くなる。Vimは以前にパースしたテキストをキャッシュして<br>
おく。そのため、遅くなるのはファイルを最初にパースするときだけである。しかし、<br>
変更を施すと、それ以降の一部をパースし直さなければならなくなる(最悪の場合はファ<br>
イルの最後まで)。<br>
<br>
&quot;fromstart&quot;を使うことは&quot;minlines&quot;を非常に大きな値にすることと同じ効果を持つ。<br>
<br>
<br>
第二の方法:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-sync-second" name=":syn-sync-second">*:syn-sync-second*</a>&nbsp;<a class="Constant" href="syntax.html#:syn-sync-ccomment" name=":syn-sync-ccomment">*:syn-sync-ccomment*</a><br>
<br>
第二の方法を使うには、単に引数&quot;ccomment&quot;をつければよい。<br>
例:<br>
<span class="Comment">&nbsp;&nbsp; :syntax sync ccomment</span><br>
<br>
画面最上行がCスタイルコメントの内側にあると判断される場合、グループ名が<br>
&quot;Comment&quot;のリージョン構文アイテムが使われる。この方法を使うには&quot;Comment&quot;という<br>
グループ名のリージョンがなければならないことに注意。他のグループ名を指定するこ<br>
ともできる。例:<br>
<span class="Comment">&nbsp;&nbsp; :syntax sync ccomment javaComment</span><br>
こうすると、検出されたCコメントのリージョンに対して&quot;syn region javaComment&quot;で<br>
指定されたアイテムのうち最後のものが使われる。ここで指定するリージョンのstart<br>
パターンが&quot;\/*&quot;、endパターンが&quot;*\/&quot;となっていないと適切に機能しない。<br>
<br>
引数&quot;maxlines&quot;を使うと検索の行数を制限できる。引数&quot;minlines&quot;を使うと少なくとも<br>
その行数だけさかのぼって開始させることができる(例:2,3行だけを受け取るコンスト<br>
ラクトがある場合。ただしその場合シンクロナイズするのが困難)<br>
<br>
注意: &quot;*/&quot;を含む文字列で行をまたぐものがあると、Cコメントによるシンクロナイズ<br>
は適切に機能しない。行をまたいで文字列を書くのは悪いプログラミング習慣である<br>
(多くのコンパイラが警告を出す)。また、コメント中に&quot;*/&quot;が現れる機会はまれなの<br>
で、この制限は注意するほどのものではない。<br>
<br>
<br>
第三の方法:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-sync-third" name=":syn-sync-third">*:syn-sync-third*</a><br>
<br>
第三の方法を使うには引数&quot;minlines=<span class="Special">{N}</span>&quot;を加えればよい。この方法を指定すると、<br>
<span class="Special">{N}</span>行前からパースを開始する。これは<span class="Special">{N}</span>行余分にパースされることを意味する。その<br>
ためこの方法は少し遅くなる。<br>
例:<br>
<span class="Comment">&nbsp;&nbsp; :syntax sync minlines=50</span><br>
<br>
&quot;lines&quot;は&quot;minlines&quot;と同じ意味である(古いバージョンで使われている)。<br>
<br>
第四の方法:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-sync-fourth" name=":syn-sync-fourth">*:syn-sync-fourth*</a><br>
<br>
第四の方法は、シンクロナイズパターンと呼ばれる特定のリージョンの末尾でシンクロ<br>
ナイズするものである。行をまたげるのはリージョンだけなので、リージョンの末尾に<br>
出会ったら、どの構文アイテムの中にいるのかを知ることができる。再描画が始まる行<br>
のすぐ上から検索を開始し、ファイルの上方に向かって検索する。<br>
<br>
これはシンクロナイズしない構文アイテムとちょうど同じように機能する。内包された<br>
マッチ、nextgroupなどを使うことができる。ただし少しだけ違いがある。<br>
- キーワードを使うことはできない。<br>
- &quot;sync&quot;キーワード付きの構文アイテムは、完全に別の構文アイテムのグループを形成<br>
&nbsp;&nbsp;する。シンクロナイズするグループとしないグループを混ぜることはできない。<br>
- 照合はバッファ内で1行ごとに逆向きに行われる(前向きではない)。<br>
- 行継続パターンをつけることができる。これを使うと、あたかも1行であるかのよう<br>
&nbsp;&nbsp;に検索する一連の行を指定することができる。これは、指定したアイテムとの照合が<br>
&nbsp;&nbsp;継続パターンを含む一連の行の最初から始まることを意味する。<br>
- &quot;nextgroup&quot;や&quot;contains&quot;は1行(または継続された一連の行)内でだけ有効。<br>
- リージョンは同一行(または継続された一連の行)内で開始・終了しなければならな<br>
&nbsp;&nbsp;い。そうでないと行末(または継続された一連の行)内で終わるものとされる。<br>
- シンクロナイズパターンとのマッチが見つかると、その行(または継続された一連の<br>
&nbsp;&nbsp;行)の残りから再びマッチが探される。最後のマッチが使われる。<br>
&nbsp;&nbsp;これはリージョンの開始と終了が同一行内にあるとき使われる<br>
&nbsp;&nbsp;(例: /* this */のようなCコメントでは、最後の&quot;*/&quot;が使われる)。<br>
<br>
シンクロナイズパターンとのマッチは2通りの使い方がある。<br>
1. 再描画を始める場所(シンクロナイズパターンの検索が始まる場所でもある)から強<br>
&nbsp;&nbsp; 調のためのパースを始める。そこで有効であると期待される構文グループを指定し<br>
&nbsp;&nbsp; なければならない。行をまたぐリージョンが他のリージョンを含んではならない場<br>
&nbsp;&nbsp; 合にこれはうまく機能する。<br>
2. ハイライトのためのパースはマッチの直後から継続される。マッチの直後に現れる<br>
&nbsp;&nbsp; と期待される構文グループを指定しなければならない。<br>
&nbsp;&nbsp; これは前の方法がうまくいかないときに使われる。より多くのテキストをパースす<br>
&nbsp;&nbsp; る必要があるため、とても遅い。<br>
両方のタイプを同時に使うこともできる。<br>
<br>
シンクロナイズパターンだけでなく、他のマッチとリージョンを指定して望まないマッ<br>
チが見つかるのを避けることができる。<br>
<br>
[シンクロナイズパターンが別々に与えられる理由は、シンクロナイズポイントの検索<br>
はたいていの場合、ハイライトするところを判別するよりずっと単純だからである。パ<br>
ターンの数が減るとそれだけ速くなる。]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#syn-sync-grouphere" name="syn-sync-grouphere">*syn-sync-grouphere*</a>&nbsp;<a class="Constant" href="syntax.html#E393" name="E393">*E393*</a>&nbsp;<a class="Constant" href="syntax.html#E394" name="E394">*E394*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;:syntax sync match&nbsp;<span class="Special">{sync-group-name}</span>&nbsp;grouphere&nbsp;<span class="Special">{group-name}</span>&nbsp;&quot;pattern&quot; ..<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;シンクロナイズ用に使うマッチを定義する。<span class="Special">{group-name}</span>はマッチのすぐ後に<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;続く構文グループの名前である。ハイライトのためのテキストのパースはマッ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チの直後から始まる。この<span class="Special">{group-name}</span>がついたリージョンが存在しなければ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ならない。最初に定義されたリージョンが使われる。マッチの後に構文グルー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;プが続かない場合は&quot;NONE&quot;を使う。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#syn-sync-groupthere" name="syn-sync-groupthere">*syn-sync-groupthere*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;:syntax sync match&nbsp;<span class="Special">{sync-group-name}</span>&nbsp;groupthere&nbsp;<span class="Special">{group-name}</span>&nbsp;&quot;pattern&quot; ..<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;grouphere&quot;と同様。ただし<span class="Special">{group-name}</span>はシンクロナイズポイントの検索が<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;始まる行の行頭で使われる構文グループの名前である。マッチとシンクロナイ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ズパターンの検索が始まる位置との間のテキストは構文ハイライトを変えては<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ならない。例えばCにおいて&quot;/*&quot;と&quot;*/&quot;を後方検索することができる。&quot;/*&quot;が<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先に見つかったら、今はコメントの内側にいるとわかる。なので&quot;groupthere&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;は&quot;cComment&quot;となる。&quot;*/&quot;が先に見つかったら今はコメントの中ではないとわ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;かる。なので&quot;groupthere&quot;は&quot;NONE&quot;となる。(実際は、文字列の中に&quot;/*&quot;と<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;*/&quot;があるかもしれないので、もう少し込み入っている。これは読者の練習問<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;題としておく...)。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;:syntax sync match ..<br>
&nbsp;&nbsp;&nbsp;&nbsp;:syntax sync region ..<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引数&quot;groupthere&quot;なしの場合。シンクロナイズポイントの検索の際にスキップ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;されるリージョンやマッチを定義する。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#syn-sync-linecont" name="syn-sync-linecont">*syn-sync-linecont*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;:syntax sync linecont&nbsp;<span class="Special">{pattern}</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{pattern}</span>とのマッチが次の行にも継続されるとみなされる。つまりシンクロ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ナイズポイントの検索の際、行は連結されているものと見なされる。<br>
<br>
引数&quot;maxlines=<span class="Special">{N}</span>&quot;が同時に与えられると、マッチを検索する行が<span class="Special">N</span>行に制限される。<br>
これは遅いマシンを使っていて、シンクロナイズするものが少ないとわかっているとき<br>
に便利。例:<br>
<span class="Comment">&nbsp;&nbsp; :syntax sync maxlines=100</span><br>
<br>
全てのシンクロナイズの設定をクリアするには:<br>
<span class="Comment">&nbsp;&nbsp; :syntax sync clear</span><br>
<br>
あるシンクロナイズパターンをクリアするには:<br>
<span class="Comment">&nbsp;&nbsp; :syntax sync clear {sync-group-name} ..&nbsp;&nbsp;</span><br>
<br>
<span class="PreProc">==============================================================================</span><br>
11. 構文アイテムのリストを表示する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syntax" name=":syntax">*:syntax*</a>&nbsp;<a class="Constant" href="syntax.html#:sy" name=":sy">*:sy*</a>&nbsp;<a class="Constant" href="syntax.html#:syn" name=":syn">*:syn*</a>&nbsp;<a class="Constant" href="syntax.html#:syn-list" name=":syn-list">*:syn-list*</a><br>
<br>
次のコマンドは全ての構文アイテムのリストを表示する:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:sy[ntax] [list]</span><br>
<br>
ある構文グループに属する構文アイテムを表示するには:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:sy[ntax] list {group-name}</span><br>
<br>
あるクラスタに属する構文グループを表示するには:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#E392" name="E392">*E392*</a>&nbsp;&nbsp;<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:sy[ntax] list @{cluster-name}</span><br>
<br>
&quot;:syntax&quot;コマンドに対する他の引数については上を参照。<br>
<br>
&quot;:syntax&quot;コマンドは&quot;:sy&quot;とも略記できる。しかし&quot;:syn&quot;の方が見栄えがよいため、普<br>
通はこちらが使われる。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
12. ハイライトコマンド&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:highlight" name=":highlight">*:highlight*</a>&nbsp;<a class="Constant" href="syntax.html#:hi" name=":hi">*:hi*</a>&nbsp;<a class="Constant" href="syntax.html#E28" name="E28">*E28*</a>&nbsp;<a class="Constant" href="syntax.html#E411" name="E411">*E411*</a>&nbsp;<a class="Constant" href="syntax.html#E415" name="E415">*E415*</a><br>
<br>
ハイライトグループには3つのタイプがある:<br>
- 特定の構文言語用のもの。名前がその言語の名前で始まる。このタイプのほとんど<br>
&nbsp;&nbsp;は属性を持たず、2番目のタイプのグループにリンクされる。<br>
- 全ての構文言語に対して使われるもの。<br>
-&nbsp;<a class="Type" href="options.html#'highlight'">'highlight'</a>オプションに使われるもの。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hitest.vim" name="hitest.vim">*hitest.vim*</a><br>
現在有効な全てのグループを知るにはこのコマンドを使う:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;:so $VIMRUNTIME/syntax/hitest.vim</span><br>
このコマンドは新しいウィンドウを開き、そこに全てのハイライトグループ名を、それ<br>
自身の色を使って表示する。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:colo" name=":colo">*:colo*</a>&nbsp;<a class="Constant" href="syntax.html#:colorscheme" name=":colorscheme">*:colorscheme*</a>&nbsp;<a class="Constant" href="syntax.html#E185" name="E185">*E185*</a><br>
:colo[rscheme]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;現在のカラースキームの名前を表示します。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本的には次のコマンドと同じです<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo g:colors_name</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g:colors_name が定義されていない場合は &quot;default&quot; と表<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示されます。<a class="Identifier" href="various.html#+eval">|+eval|</a>&nbsp;機能付きでコンパイルされていない場<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;合は &quot;unknown&quot; と表示されます。<br>
<br>
:colo[rscheme]&nbsp;<span class="Special">{name}</span>&nbsp;&nbsp; カラースキーム<span class="Special">{name}</span>を読み込む。これは<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>中<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;から&quot;colors/<span class="Special">{name}</span>.vim&quot;というファイルを検索する。最初<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;に見つかったものが読み込まれる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;現在使われているカラースキームの名前を見るには次のよう<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;にします:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:colo</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 名前は g:colors_name 変数にも格納されています。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再帰的な読み込みはされない。つまりカラースキームスクリ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;プト中で&quot;:colorscheme&quot;を使うことはできない。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カラースキームが読み込まれた後、自動コマンドイベント<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="autocmd.html#ColorScheme">|ColorScheme|</a>が発生する。カラースキームファイルを書く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ための情報については次を参照:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:edit $VIMRUNTIME/colors/README.txt</span><br>
<br>
:hi[ghlight]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性がセットされたハイライトグループを全て表示する。<br>
<br>
:hi[ghlight]&nbsp;<span class="Special">{group-name}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1つのハイライトグループを表示する。<br>
<br>
:hi[ghlight] clear&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全てのハイライトをデフォルトに戻す。ユーザによって加え<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;られたグループに対するハイライトが全て消去される。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;現在の<a class="Type" href="options.html#'background'">'background'</a>の値によってデフォルトの色が決まる。<br>
<br>
:hi[ghlight] clear&nbsp;<span class="Special">{group-name}</span><br>
:hi[ghlight]&nbsp;<span class="Special">{group-name}</span>&nbsp;NONE<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1つのハイライトグループに対するハイライトを無効にする。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;デフォルトの色に戻すわけではない。<br>
<br>
:hi[ghlight]&nbsp;<span class="Special">[default]</span>&nbsp;<span class="Special">{group-name}</span>&nbsp;<span class="Special">{key}</span>=<span class="Special">{arg}</span>&nbsp;..<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ハイライトグループを追加する、または既存のグループに対<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;する強調を変更する。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引数<span class="Special">{key}</span>=<span class="Special">{arg}</span>については<a class="Identifier" href="syntax.html#highlight-args">|highlight-args|</a>を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;オプショナルな引数[default]については<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#:highlight-default">|:highlight-default|</a>を参照。<br>
<br>
通常、ハイライトグループは起動時に一度だけ追加される。そこでハイライトのデフォ<br>
ルト値をセットする。その後、ハイライトコマンドを使うことによってデフォルトでな<br>
い値に変えることができる。値&quot;NONE&quot;を使うとその値をオフにしたりデフォルト値に戻<br>
したりできる。<br>
<br>
色を変える簡単な方法は<a class="Identifier" href="syntax.html#:colorscheme">|:colorscheme|</a>コマンドを使うことである。すると、次のよう<br>
な&quot;:highlight&quot;コマンドが書かれたファイルが読み込まれる:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :hi Comment&nbsp;&nbsp;gui=bold</span><br>
<br>
このファイルに含まれない設定は変更されないままである。指定されたフィールドだけ<br>
が更新され、それ以前の設定とマージされる。なのでその結果は次のコマンド1つを実<br>
行するのと同じである:<br>
<span class="Comment">&nbsp;&nbsp; :hi Comment&nbsp;&nbsp;term=bold ctermfg=Cyan guifg=#80a0ff gui=bold</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:highlight-verbose" name=":highlight-verbose">*:highlight-verbose*</a><br>
<a class="Type" href="options.html#'verbose'">'verbose'</a>を0でない値にしてハイライトグループの一覧を表示すると、最後に設定され<br>
た場所も表示される。例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:verbose hi Comment</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">Comment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xxx term=bold ctermfg=4 guifg=Blue</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">Last set from /home/mool/vim/vim7/runtime/syntax/syncolor.vim</span><br>
<br>
&quot;:hi clear&quot;が実行されると、このコマンドを実行したスクリプトがデフォルト値とし<br>
て言及される。より詳しくは<a class="Identifier" href="various.html#:verbose-cmd">|:verbose-cmd|</a>を参照。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#highlight-args" name="highlight-args">*highlight-args*</a>&nbsp;<a class="Constant" href="syntax.html#E416" name="E416">*E416*</a>&nbsp;<a class="Constant" href="syntax.html#E417" name="E417">*E417*</a>&nbsp;<a class="Constant" href="syntax.html#E423" name="E423">*E423*</a><br>
ハイライトに関して、ターミナルは3種類に分類される:<br>
term&nbsp;&nbsp;&nbsp;&nbsp;通常のターミナル(vt100, xterm)<br>
cterm&nbsp;&nbsp; カラーターミナル(MS-DOS console, color-xterm。これらはtermcapエントリ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Co&quot;をもつ)&nbsp;<br>
gui&nbsp;&nbsp;&nbsp;&nbsp; GUI<br>
<br>
ハイライトはこれらのタイプごとに指定できる。そうすることによって、同じ構文ファ<br>
イルを全てのターミナルに対して使用でき、ターミナルごとに最善のハイライトを利用<br>
できるようになっている。<br>
<br>
1. highlightコマンドの引数(通常のターミナル用)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#bold" name="bold">*bold*</a>&nbsp;<a class="Constant" href="syntax.html#underline" name="underline">*underline*</a>&nbsp;<a class="Constant" href="syntax.html#undercurl" name="undercurl">*undercurl*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#inverse" name="inverse">*inverse*</a>&nbsp;<a class="Constant" href="syntax.html#italic" name="italic">*italic*</a>&nbsp;<a class="Constant" href="syntax.html#standout" name="standout">*standout*</a><br>
term=<span class="Special">{attr-list}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#attr-list" name="attr-list">*attr-list*</a>&nbsp;<a class="Constant" href="syntax.html#highlight-term" name="highlight-term">*highlight-term*</a>&nbsp;<a class="Constant" href="syntax.html#E418" name="E418">*E418*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attr-listはカンマ区切りのリスト(スペースは入れない)で、要素は以下の通<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;り(順序はどうでもよい):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bold<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underline<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undercurl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 必ずしも使用できるとは限らない<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverse<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inverse&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverseと同じ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;italic<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;standout<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NONE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性を使用しない(属性をリセットするために使う)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;この引数で&quot;bold&quot;を指定してもよいし、太文字のフォントを指定してもよい。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;どちらも表示は同じになる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;undercurl&quot;は波線のこと。&quot;undercurl&quot;が使用できないときは&quot;underline&quot;が<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使われる。一般的には&quot;undercurl&quot;はGUIでのみ使用できる。その色は<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="syntax.html#highlight-guisp">|highlight-guisp|</a>で設定できる。<br>
<br>
start=<span class="Special">{term-list}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#highlight-start" name="highlight-start">*highlight-start*</a>&nbsp;<a class="Constant" href="syntax.html#E422" name="E422">*E422*</a><br>
stop=<span class="Special">{term-list}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#term-list" name="term-list">*term-list*</a>&nbsp;<a class="Constant" href="syntax.html#highlight-stop" name="highlight-stop">*highlight-stop*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;これらのターミナルコードのリストを使ってターミナルについての標準的でな<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;い属性を得ることができる。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引数&quot;start&quot;でエスケープシーケンスを指定すると、ハイライトするテキスト<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;の前にそれが書き込まれる。そのテキストをハイライトする際にターミナルに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;送りたいものをなんでも指定できる。引数&quot;stop&quot;でエスケープシーケンスを指<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定すると、強調されるテキストの後にそれが書き込まれる。&quot;start&quot;で行った<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ことを&quot;stop&quot;で元に戻すべきである。そうしないとスクリーンがごちゃごちゃ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;になってしまうだろう。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{term-list}</span>は2つの形を持つ:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. エスケープシーケンス付きの文字列。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; これは&quot;t_&quot;で始まるものと空文字列を除く任意の文字列である。&quot;<span class="Special">&lt;Esc&gt;</span>&quot;や<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;<span class="Special">&lt;Space&gt;</span>&quot;のような&lt;&gt;記法が利用できる。例:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start=<span class="Special">&lt;Esc&gt;</span>[27h;<span class="Special">&lt;Esc&gt;</span>[<span class="Special">&lt;Space&gt;</span>r;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. ターミナルコードのリスト。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ターミナルコードは&quot;t_xx&quot;の形を持つ。&quot;xx&quot;はtermcapエントリ名である。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ターミナルコードはカンマで区切る。ホワイトスペースは使えない。例:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start=t_C1,t_BL<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 対応するターミナルコードが存在しなければならない。<br>
<br>
2. highlightコマンドの引数(カラーターミナル用)<br>
<br>
cterm=<span class="Special">{attr-list}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#highlight-cterm" name="highlight-cterm">*highlight-cterm*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{attr-list}</span>の説明は上を参照<a class="Identifier" href="syntax.html#attr-list">|attr-list|</a>。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色を使う場合、引数&quot;cterm&quot;は&quot;term&quot;と異なる結果になる。例えば、通常の<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ターミナルではコメントにアンダーラインを引き、カラーターミナルではコメ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ントを青色で表示することができる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意:DOSコンソールなど多くのターミナルでは色づけの際にこれらの属性を混<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在させることはできない。&quot;cterm=&quot;か&quot;ctermfg=&quot;が&quot;ctermbg=&quot;のどれか1つだ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;けを使うこと。<br>
<br>
ctermfg=<span class="Special">{color-nr}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#highlight-ctermfg" name="highlight-ctermfg">*highlight-ctermfg*</a>&nbsp;<a class="Constant" href="syntax.html#E421" name="E421">*E421*</a><br>
ctermbg=<span class="Special">{color-nr}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#highlight-ctermbg" name="highlight-ctermbg">*highlight-ctermbg*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引数<span class="Special">{color-nr}</span>で色番号を指定する。色番号の範囲は0からtermcapエントリ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Co&quot;の値 - 1 までである。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;この色番号で実際に表示される色はターミナルの種類とその設定に依存する。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;cterm&quot;の設定によって色が変わる場合もある。例えば、あるシステムでは<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;cterm=bold ctermfg=3&quot;でそのまま3番の色を表示し、他のシステムでは異な<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;る色を表示することがある。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xtermにおいてはこれはユーザのリソースに依存し、やや予測ができない。デ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;フォルトについてはxtermのドキュメントを参照のこと。カラーxterm用の色は<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Xdefaultsファイルで変更することができる。このため、ユーザごとに表示さ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;れる色が異なるかもしれない。カラーxtermについては<a class="Identifier" href="syntax.html#xterm-color">|xterm-color|</a>を参照。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;コンソールウィンドウ内のMSDOS標準色は固定されている。そのため、これら<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;の色を名前に使っている。一方、X11の色名の意味は固定されている。そこで<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ハイライトの設定に可搬性を持たせるため、X11の色設定が使われている(複雑<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;であるが)。以下の色名を、色番号の代わりに使うことができる:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#cterm-colors" name="cterm-colors">*cterm-colors*</a>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">NR-16&nbsp;&nbsp; NR-8&nbsp;&nbsp;&nbsp;&nbsp;COLOR NAME</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Black<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DarkBlue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DarkGreen<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DarkCyan<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DarkRed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DarkMagenta<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Brown, DarkYellow<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LightGray, LightGrey, Gray, Grey<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DarkGray, DarkGrey<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blue, LightBlue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Green, LightGreen<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cyan, LightCyan<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Red, LightRed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Magenta, LightMagenta<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yellow, LightYellow<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;White<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;NR-16&quot;の下の番号は16色ターミナル(<a class="Type" href="term.html#'t_Co'">'t_Co'</a>が16以上のもの)用である。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;NR-8&quot;の下の番号は8色ターミナル(<a class="Type" href="term.html#'t_Co'">'t_Co'</a>が16未満のもの)用である。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'*'はctermfgにbold属性がセットされることを意味している。&quot;linux&quot;な<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ど多くの8色ターミナルでは明るい色になる。ただし背景色には適用され<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ない。'*'がないものはbold属性なしになる。他の方法でbold属性をつけ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;たいなら引数&quot;cterm=&quot;を&quot;ctermfg=&quot;や&quot;ctermbg=&quot;の後に書くこと。または<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色名の代わりに番号を使うこと。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色名の大文字・小文字は無視される。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16色ansiスタイルターミナル(xtermを含む)ではNR-8の列の番号が使われ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ることに注意。ここで'*'は'add 8'という意味になる。つまりBlueが12<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;に、DarkGrayが8になる。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カラーターミナルによっては、色名を使うと間違った色で表示される場合<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;もあることに注意。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:hi-normal-cterm" name=":hi-normal-cterm">*:hi-normal-cterm*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Normalグループに対して&quot;ctermfg&quot;や&quot;ctermbg&quot;を設定すると、これらはハイラ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;イトされないテキストに対する色になる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:highlight Normal ctermfg=grey ctermbg=darkblue</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Normalグループに対して&quot;ctermbg&quot;を設定すると、オプション<a class="Type" href="options.html#'background'">'background'</a>が<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自動的に調整される。これによって<a class="Type" href="options.html#'background'">'background'</a>に依存するハイライトグルー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;プが変更される。そのため、まずNormalに対する色を設定し、それから他の色<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;を設定するべきである。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カラースキーム使用時に<a class="Type" href="options.html#'background'">'background'</a>を変更するとカラースキームが再読み込<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;みされる。そしてNormalを含む全ての色がリセットされる。これが嫌なら最初<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;に変数&quot;g:colors_name&quot;を削除すること。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Normalグループの&quot;ctermfg&quot;や&quot;ctermbg&quot;を変更した場合、Vim終了時にその色<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;をリセットする必要がある。これはtermcapエントリ&quot;op&quot;<a class="Identifier" href="term.html#t_op">|t_op|</a>を使ってなさ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;れる。リセットがうまくいかない場合は.vimrc中で<a class="Type" href="term.html#'t_op'">'t_op'</a>を設定してみること。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#E419" name="E419">*E419*</a>&nbsp;<a class="Constant" href="syntax.html#E420" name="E420">*E420*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vimが通常の文字色と背景色を知っている場合、色名として&quot;fg&quot;と&quot;bg&quot;を使用<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;できる。これはNormalグループの色とMS-DOSコンソールの色を設定しないと使<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;えない。例えば反転表示をするには:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:highlight Visual ctermfg=bg ctermbg=fg</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; このコマンドを実行した時点で有効な色が使われることに注意。この後で<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Normalグループを変更しても&quot;fg&quot;と&quot;bg&quot;は調整されない。<br>
<br>
<br>
3. highlightコマンドの引数(GUI用)<br>
<br>
gui=<span class="Special">{attr-list}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#highlight-gui" name="highlight-gui">*highlight-gui*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;これらはGUIモードで使われる属性を設定する。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;説明は<a class="Identifier" href="syntax.html#attr-list">|attr-list|</a>を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ここで&quot;bold&quot;を設定しても太字のフォントを使ってもよい。どちらも同じ効果<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;を持つ。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Normal&quot;グループに対する属性は無視される。<br>
<br>
font=<span class="Special">{font-name}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#highlight-font" name="highlight-font">*highlight-font*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;font-nameはVimを実行しているシステム上で使われるフォント名である。X11<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ではこれは複雑な名前になる。例えば:<br>
<span class="Comment">&nbsp;&nbsp; font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;フォント名&quot;NONE&quot;を使うとデフォルトのフォントに戻る。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Normal&quot;グループに対してフォントを設定すると、これがデフォルトフォント<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;になる(オプション<a class="Type" href="options.html#'guifont'">'guifont'</a>が変更されるまでは; 最後に設定したものが使わ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;れる)。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下のものはMotifとAthena上でのみ動作し、他のGUI上では利用できない:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Menu&quot;グループに対してフォントを設定すると、メニューが変更される。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Tooltip&quot;グループに対してフォントを設定するt、ツールチップが変更され<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;る。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Menu用とTooltip用を除く全てのフォントのサイズがデフォルトフォントのサ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;イズと同じでなければならない。そうでないと再描画の際に問題が発生する。<br>
<br>
guifg=<span class="Special">{color-name}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#highlight-guifg" name="highlight-guifg">*highlight-guifg*</a><br>
guibg=<span class="Special">{color-name}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#highlight-guibg" name="highlight-guibg">*highlight-guibg*</a><br>
guisp=<span class="Special">{color-name}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#highlight-guisp" name="highlight-guisp">*highlight-guisp*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guifgは文字色、guibgは背景色、guispは波線の色を指定する。これらはGUIで<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用される。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;いくつか特別な名前がある:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NONE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;no color (透明)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常の背景色を使う<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;background&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常の背景色を使う<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常の文字色を使う<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreground&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常の文字色を使う<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;埋め込みスペースや他の特別な文字に対して色名を使うには、色名をシングル<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;クォートでくくる。それゆえシングルクォートを使うことはできない。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:hi comment guifg='salmon pink'</span><br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#gui-colors" name="gui-colors">*gui-colors*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;推奨されている色名 (これらはほとんどのシステムで利用可能である)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Red&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LightRed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DarkRed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Green&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LightGreen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DarkGreen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SeaGreen<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LightBlue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DarkBlue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SlateBlue<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LightCyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DarkCyan<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Magenta&nbsp;&nbsp;&nbsp;&nbsp; LightMagenta&nbsp;&nbsp;&nbsp;&nbsp;DarkMagenta<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yellow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LightYellow&nbsp;&nbsp;&nbsp;&nbsp; Brown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DarkYellow<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LightGray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DarkGray<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Black&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; White<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Orange&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Purple&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Violet<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Win32 GUIバージョンでは他にもシステムカラーが利用できる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="gui_w32.html#win32-colors">|win32-colors|</a>を参照。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RGB値によって色を指定することもできる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;フォーマットは&quot;#rrggbb&quot;、ここで<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;rr&quot;&nbsp;&nbsp;&nbsp;&nbsp;Red値<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;gg&quot;&nbsp;&nbsp;&nbsp;&nbsp;Green値<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;bb&quot;&nbsp;&nbsp;&nbsp;&nbsp;Blue値<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;これらの値は16進であり、範囲は&quot;00&quot;から&quot;ff&quot;。例:<br>
<span class="Comment">&nbsp;&nbsp;:highlight Comment guifg=#11f0c3 guibg=#ff00ff</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#highlight-groups" name="highlight-groups">*highlight-groups*</a>&nbsp;<a class="Constant" href="syntax.html#highlight-default" name="highlight-default">*highlight-default*</a><br>
以下はデフォルトのハイライトグループである。これらのグループはデフォルトでオプ<br>
ション<a class="Type" href="options.html#'highlight'">'highlight'</a>によって使われる。ただしハイライトは<a class="Type" href="options.html#'background'">'background'</a>の値に依存す<br>
ることに注意。&quot;:highlight&quot;コマンドで現在の設定を知ることができる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-ColorColumn" name="hl-ColorColumn">*hl-ColorColumn*</a><br>
ColorColumn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Type" href="options.html#'colorcolumn'">'colorcolumn'</a>&nbsp;で設定された列の表示に使われる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Conceal" name="hl-Conceal">*hl-Conceal*</a><br>
Conceal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Conceal されたテキストの代わりに表示される代替文字の表示に使わ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;れる (<a class="Type" href="options.html#'conceallevel'">'conceallevel'</a>&nbsp;参照)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Cursor" name="hl-Cursor">*hl-Cursor*</a><br>
Cursor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カーソル下の文字<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-CursorIM" name="hl-CursorIM">*hl-CursorIM*</a><br>
CursorIM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cursorと同じだが、IMEモードにいるとき使われる<a class="Identifier" href="mbyte.html#CursorIM">|CursorIM|</a>。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-CursorColumn" name="hl-CursorColumn">*hl-CursorColumn*</a><br>
CursorColumn&nbsp;&nbsp;&nbsp;&nbsp;<a class="Type" href="options.html#'cursorcolumn'">'cursorcolumn'</a>がオンになっているときのカーソルがある画面上の桁<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-CursorLine" name="hl-CursorLine">*hl-CursorLine*</a><br>
CursorLine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Type" href="options.html#'cursorline'">'cursorline'</a>がオンになっているときのカーソルがある画面上の行<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Directory" name="hl-Directory">*hl-Directory*</a><br>
Directory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ディレクトリ名(とリストにある特別な名前)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-DiffAdd" name="hl-DiffAdd">*hl-DiffAdd*</a><br>
DiffAdd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; diffモード: 追加された行&nbsp;<a class="Identifier" href="diff.html">|diff.txt|</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-DiffChange" name="hl-DiffChange">*hl-DiffChange*</a><br>
DiffChange&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diff モード: 変更された行&nbsp;<a class="Identifier" href="diff.html">|diff.txt|</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-DiffDelete" name="hl-DiffDelete">*hl-DiffDelete*</a><br>
DiffDelete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diff モード: 削除された行&nbsp;<a class="Identifier" href="diff.html">|diff.txt|</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-DiffText" name="hl-DiffText">*hl-DiffText*</a><br>
DiffText&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diff モード: 変更された行中の変更されたテキスト&nbsp;<a class="Identifier" href="diff.html">|diff.txt|</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-ErrorMsg" name="hl-ErrorMsg">*hl-ErrorMsg*</a><br>
ErrorMsg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;コマンドラインに現れるエラーメッセージ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-VertSplit" name="hl-VertSplit">*hl-VertSplit*</a><br>
VertSplit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 垂直分割したウィンドウの区切りとなる桁<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Folded" name="hl-Folded">*hl-Folded*</a><br>
Folded&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;閉じた折り畳みの行<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-FoldColumn" name="hl-FoldColumn">*hl-FoldColumn*</a><br>
FoldColumn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Type" href="options.html#'foldcolumn'">'foldcolumn'</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-SignColumn" name="hl-SignColumn">*hl-SignColumn*</a><br>
SignColumn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目印<a class="Identifier" href="sign.html#signs">|signs|</a>が表示される行。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-IncSearch" name="hl-IncSearch">*hl-IncSearch*</a><br>
IncSearch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Type" href="options.html#'incsearch'">'incsearch'</a>のハイライト; &quot;:s///c&quot;で置換されたテキストにも使わ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;れる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-LineNr" name="hl-LineNr">*hl-LineNr*</a><br>
LineNr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;:number&quot; と &quot;:#&quot; コマンドの行番号。<a class="Type" href="options.html#'number'">'number'</a>&nbsp;オプションか<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Type" href="options.html#'relativenumber'">'relativenumber'</a>&nbsp;オプションが設定されているときにはその表示に<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;も使われる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-MatchParen" name="hl-MatchParen">*hl-MatchParen*</a><br>
MatchParen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カーソル下の文字、または直後の文字が括弧であるとき、その文字と<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;対応する括弧に使われる。<a class="Identifier" href="pi_paren.html">|pi_paren.txt|</a><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-ModeMsg" name="hl-ModeMsg">*hl-ModeMsg*</a><br>
ModeMsg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Type" href="options.html#'showmode'">'showmode'</a>のメッセージ (例. &quot;-- INSERT --&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-MoreMsg" name="hl-MoreMsg">*hl-MoreMsg*</a><br>
MoreMsg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="message.html#more-prompt">|more-prompt|</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-NonText" name="hl-NonText">*hl-NonText*</a><br>
NonText&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ウィンドウの端の'~'と'@'、<a class="Type" href="options.html#'showbreak'">'showbreak'</a>で設定された文字など、実<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;際のテキストには存在しない文字(例. 全角文字が行末に収まらない<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;とき&quot;&gt;&quot;が表示される)。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Normal" name="hl-Normal">*hl-Normal*</a><br>
Normal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常のテキスト<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Pmenu" name="hl-Pmenu">*hl-Pmenu*</a><br>
Pmenu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ポップアップメニュー: 通常の項目。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-PmenuSel" name="hl-PmenuSel">*hl-PmenuSel*</a><br>
PmenuSel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ポップアップメニュー: 選択されている項目。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-PmenuSbar" name="hl-PmenuSbar">*hl-PmenuSbar*</a><br>
PmenuSbar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ポップアップメニュー: スクロールバー。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-PmenuThumb" name="hl-PmenuThumb">*hl-PmenuThumb*</a><br>
PmenuThumb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ポップアップメニュー: スクロールバーのつまみ部分。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Question" name="hl-Question">*hl-Question*</a><br>
Question&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ヒットエンタープロンプト<a class="Identifier" href="message.html#hit-enter">|hit-enter|</a>とyes/noクエスチョン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Search" name="hl-Search">*hl-Search*</a><br>
Search&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最後に検索した語のハイライト(<a class="Type" href="options.html#'hlsearch'">'hlsearch'</a>)を参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickfixウィンドウ内の現在行のハイライトや、それに類するものに<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使われる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-SpecialKey" name="hl-SpecialKey">*hl-SpecialKey*</a><br>
SpecialKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;:map&quot;でリストされるメタキーと特別なキー。テキスト中の<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unprintableな文字を表示するのにも使われる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般に: 実際とは異なる文字で表示されるテキスト<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-SpellBad" name="hl-SpellBad">*hl-SpellBad*</a><br>
SpellBad&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;スペルチェッカに認識されない単語。<span class="MissingTag">|spell|</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;これは他のハイライトと同時に組み合わせられる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-SpellCap" name="hl-SpellCap">*hl-SpellCap*</a><br>
SpellCap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大文字で始まるべき単語。&nbsp;<span class="MissingTag">|spell|</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;これは他のハイライトと同時に組み合わせられる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-SpellLocal" name="hl-SpellLocal">*hl-SpellLocal*</a><br>
SpellLocal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;スペルチェッカによって他の地域で使われると判断される単語。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">|spell|</span>これは他のハイライトと同時に組み合わせられる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-SpellRare" name="hl-SpellRare">*hl-SpellRare*</a><br>
SpellRare&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; スペルチェッカによってまず使わないと判断される単語。<span class="MissingTag">|spell|</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;これは他のハイライトと同時に組み合わせられる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-StatusLine" name="hl-StatusLine">*hl-StatusLine*</a><br>
StatusLine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カレントウィンドウのステータスライン<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-StatusLineNC" name="hl-StatusLineNC">*hl-StatusLineNC*</a><br>
StatusLineNC&nbsp;&nbsp;&nbsp;&nbsp;非カレントウィンドウのステータスライン。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>: これが&quot;StatusLine&quot;に等しい場合、カレントウィンドウのステー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;タスラインに&quot;^^^&quot;が使われる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-TabLine" name="hl-TabLine">*hl-TabLine*</a><br>
TabLine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; タブページの行の、アクティブでないタブページのラベル<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-TabLineFill" name="hl-TabLineFill">*hl-TabLineFill*</a><br>
TabLineFill&nbsp;&nbsp;&nbsp;&nbsp; タブページの行の、ラベルがない部分<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-TabLineSel" name="hl-TabLineSel">*hl-TabLineSel*</a><br>
TabLineSel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;タブページの行の、アクティブなタブページのラベル<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Title" name="hl-Title">*hl-Title*</a><br>
Title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;:set all&quot;、&quot;:autocmd&quot;などによる出力のタイトル。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Visual" name="hl-Visual">*hl-Visual*</a><br>
Visual&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ビジュアルモード選択<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-VisualNOS" name="hl-VisualNOS">*hl-VisualNOS*</a><br>
VisualNOS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vimが&quot;Not Owning the Selection&quot;のときのビジュアルモード選択。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;これをサポートしているのはX11GUI<a class="Identifier" href="gui_x11.html#gui-x11">|gui-x11|</a>と<a class="Identifier" href="term.html#xterm-clipboard">|xterm-clipboard|</a>の<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;み。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-WarningMsg" name="hl-WarningMsg">*hl-WarningMsg*</a><br>
WarningMsg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;警告メッセージ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-WildMenu" name="hl-WildMenu">*hl-WildMenu*</a><br>
WildMenu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Type" href="options.html#'wildmenu'">'wildmenu'</a>補完における現在の候補<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-User1" name="hl-User1">*hl-User1*</a>&nbsp;<a class="Constant" href="syntax.html#hl-User1..9" name="hl-User1..9">*hl-User1..9*</a>&nbsp;<a class="Constant" href="syntax.html#hl-User9" name="hl-User9">*hl-User9*</a><br>
<a class="Type" href="options.html#'statusline'">'statusline'</a>構文によってステータスラインとルーラー(<a class="Type" href="options.html#'rulerformat'">'rulerformat'</a>によって)中で9<br>
個のハイライトが使えるようになっている。その名前はUser1からUser9である。<br>
<br>
GUI使用時には、これらのグループを使ってメニューやスクロールバー、ツールチップ<br>
の色を設定することができる。これらにデフォルト値はない。これはWin32では利用で<br>
きない。ここではhighlightの引数のうちfont, guibg, guifgの3つだけが効果を持つ。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Menu" name="hl-Menu">*hl-Menu*</a><br>
Menu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メニューのフォント、文字、背景。ツールバーにも使われる。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用可能なhighlightの引数: font, guibg, guifg.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">NOTE</span>: MotifとAthenaでは<a class="Type" href="options.html#'guifontset'">'guifontset'</a>が空かどうかに関わらず、常<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;に引数fontで実際のフォントセットを指定する。そしてそれが現在の<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="mlang.html#:language">|:language|</a>に結び付けられる。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Scrollbar" name="hl-Scrollbar">*hl-Scrollbar*</a><br>
Scrollbar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; メインウィンドウのスクロールバーの文字と背景。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用可能なhighlightの引数: guibg, guifg.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hl-Tooltip" name="hl-Tooltip">*hl-Tooltip*</a><br>
Tooltip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ツールチップのフォント、文字、背景。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用可能なhighlightの引数: font, guibg, guifg.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">NOTE</span>: MotifとAthenaでは<a class="Type" href="options.html#'guifontset'">'guifontset'</a>が空かどうかに関わらず、常<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;に引数fontで実際のフォントセットを指定する。そしてそれが現在の<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="mlang.html#:language">|:language|</a>に結び付けられる。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
13. グループのリンク&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:hi-link" name=":hi-link">*:hi-link*</a>&nbsp;<a class="Constant" href="syntax.html#:highlight-link" name=":highlight-link">*:highlight-link*</a>&nbsp;<a class="Constant" href="syntax.html#E412" name="E412">*E412*</a>&nbsp;<a class="Constant" href="syntax.html#E413" name="E413">*E413*</a><br>
<br>
複数の構文グループに対して同じハイライトを適用させるには、両方のグループから一<br>
つの強調グループにリンクを作り、リンク先に対して色属性を与えると簡単である。<br>
<br>
リンクを作るには:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;:hi[ghlight][!]&nbsp;<span class="Special">[default]</span>&nbsp;link&nbsp;<span class="Special">{from-group}</span>&nbsp;<span class="Special">{to-group}</span><br>
<br>
リンクを削除するには:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;:hi[ghlight][!]&nbsp;<span class="Special">[default]</span>&nbsp;link&nbsp;<span class="Special">{from-group}</span>&nbsp;NONE<br>
<br>
<span class="Todo">Notes</span>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#E414" name="E414">*E414*</a><br>
-&nbsp;<span class="Special">{from-group}</span>か<span class="Special">{to-group}</span>のどちらかが存在しない場合、リンクは作成されない。こ<br>
&nbsp;&nbsp;の場合エラーメッセージは表示されない。<br>
- リンクされたグループに対して&quot;:highlight&quot;を使うと、即座にリンクが削除される。<br>
- 既に<span class="Special">{from-group}</span>にハイライト設定がされている場合、'!'をつけないとリンクは作<br>
&nbsp;&nbsp;成されない。sourceされたファイル中の&quot;:highlight link&quot;コマンドに関して、エラー<br>
&nbsp;&nbsp;メッセージは表示されない。そのため既に設定を持つグループに対するリンクがスキッ<br>
&nbsp;&nbsp;プされる。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:hi-default" name=":hi-default">*:hi-default*</a>&nbsp;<a class="Constant" href="syntax.html#:highlight-default" name=":highlight-default">*:highlight-default*</a><br>
引数[default]によってグループに対するデフォルトのハイライトを設定することがで<br>
きる。そのグループに対して既にハイライトが指定されている場合、このコマンドは無<br>
視される。既にリンクが存在する場合も同様。<br>
<br>
[default] は、そのハイライト設定をあとから上書きさせるために使われる。例えば<br>
C 構文ファイルは次の行を含んでいる:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:highlight default link cComment Comment</span><br>
この設定を変更し、C コメントに対して Question のハイライトをつけたい場合、次の<br>
行を .vimrc に加える:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:highlight link cComment Question</span><br>
&quot;default&quot; をつけないと、.vimrc より C 構文ファイルの方があとに読み込まれるた<br>
め、.vimrc の設定を上書きしてしまう。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
14. 構文の消去&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syn-clear" name=":syn-clear">*:syn-clear*</a>&nbsp;<a class="Constant" href="syntax.html#E391" name="E391">*E391*</a><br>
<br>
カレントバッファに対する構文設定を消去したいときはこのコマンドを使う:<br>
<span class="Comment">&nbsp;&nbsp;:syntax clear</span><br>
<br>
このコマンドは、構文ハイライトをオフにしたいときや他の構文を適用したいときに使<br>
う。通常、これを構文ファイル内で行う必要はない。なぜなら、構文ファイルを読み込<br>
む自動コマンドによって構文がクリアされる。<br>
また、このコマンドは変数&quot;b:current_syntax&quot;を削除する。このコマンドの実行後には<br>
すべての構文がなくなるからである。<br>
<br>
全てのバッファに対して構文ハイライトを無効にしたいときは、構文ファイルを読み込<br>
む自動コマンドを削除する必要がある:<br>
<span class="Comment">&nbsp;&nbsp;:syntax off</span><br>
<br>
このコマンドが実際に行うことは次のコマンドを実行するのと同じである:<br>
<span class="Comment">&nbsp;&nbsp;:source $VIMRUNTIME/syntax/nosyntax.vim</span><br>
詳細は&quot;nosyntax.vim&quot;を参照。これが正常に機能するためには$VIMRUNTIMEが正しく設<br>
定されている必要がある。<a class="Identifier" href="starting.html#$VIMRUNTIME">|$VIMRUNTIME|</a>を参照。<br>
<br>
カレントバッファに対する特定の構文グループを消去するには:<br>
<span class="Comment">&nbsp;&nbsp;:syntax clear {group-name} ..</span><br>
これは<span class="Special">{group-name}</span>に対する全てのパターンとキーワードを消去する。<br>
<br>
カレントバッファに対する特定の構文グループリストを消去するには:<br>
<span class="Comment">&nbsp;&nbsp;:syntax clear @{grouplist-name} ..</span><br>
これは<span class="Special">{grouplist-name}</span>の中身を空リストにセットする。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:syntax-reset" name=":syntax-reset">*:syntax-reset*</a>&nbsp;<a class="Constant" href="syntax.html#:syn-reset" name=":syn-reset">*:syn-reset*</a><br>
色を変えたため、色がごちゃごちゃになってしまったときは、次のコマンドを使うとデ<br>
フォルトに戻る:<br>
<br>
<span class="Comment">&nbsp;&nbsp;:syntax reset</span><br>
<br>
これはオプション<a class="Type" href="options.html#'highlight'">'highlight'</a>に対する色は変更しない。<br>
<br>
ユーザのvimrcファイル中で設定した構文色もVimのデフォルト値に戻ることに注意。<br>
カラースキームを使っている場合、カラースキームによって定義された色は失われるこ<br>
とに注意。<br>
<br>
このコマンドが実際に行うことは次と同じ:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let g:syntax_cmd = &quot;reset&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runtime! syntax/syncolor.vim</span><br>
<br>
ここでオプション<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>が使われていることに注意。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#syncolor" name="syncolor">*syncolor*</a><br>
構文ハイライトに別の色を使うには、色を設定するVimスクリプトを作ればよい。その<br>
ファイルを<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>中(<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>は$VIMRUNTIMEを含む)のディレクトリに置<br>
くと、その設定がデフォルトの色設定を上書きする。こうして&quot;:syntax reset&quot;コマン<br>
ドを実行すると、それらの色が有効になる。<br>
<br>
Unixでは~/.vim/after/syntax/syncolor.vimファイルを使うとよい。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if &amp;background == &quot;light&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;highlight comment ctermfg=darkgreen guifg=darkgreen</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;highlight comment ctermfg=green guifg=green</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</span><br>
<br>
カラースキームを使用すると、ユーザ定義の色が使われるのか、それともカラースキー<br>
ムで定義された色が使われるのかわからなくなる場合がある。これはカラースキーム<br>
ファイルに依存する。<a class="Identifier" href="syntax.html#:colorscheme">|:colorscheme|</a>を参照。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#E679" name="E679">*E679*</a><br>
このsyncolor.vimが&quot;syntax on&quot;を実行しないこと、また、オプション<a class="Type" href="options.html#'background'">'background'</a>を<br>
設定したりコマンド&quot;colorscheme&quot;を実行しないように注意すること。もしこれらを実<br>
行すると無限ループに陥ってしまう。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#syntax_cmd" name="syntax_cmd">*syntax_cmd*</a><br>
syntax/syncolor.vimファイルが読み込まれると、変数&quot;syntax_cmd&quot;に次の3つの値のど<br>
れかがセットされる:<br>
&nbsp;&nbsp; &quot;on&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;:syntax on&quot; コマンド。ハイライト色が上書きされるがリンクはそ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;のまま。<br>
&nbsp;&nbsp; &quot;enable&quot;&nbsp;&nbsp;&nbsp;&nbsp; &quot;:syntax enable&quot; コマンド。まだハイライトが定義されていないグ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ループに対して色を定義するだけ。&quot;:syntax default&quot;を使うこと。<br>
&nbsp;&nbsp; &quot;reset&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;:syntax reset&quot; コマンドまたはカラースキームを読み込む。全ての<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色を定義する。<br>
&nbsp;&nbsp; &quot;skip&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 色を定義しない。<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>で前にあるsyncolor.vimファイルが<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既にデフォルト設定をセットしているとき、そのデフォルト設定をス<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;キップするために使われる。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
15. 関数名などのハイライト&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#tag-highlight" name="tag-highlight">*tag-highlight*</a><br>
<br>
ファイル中の全てのタグ(関数名など)をハイライトするには、次のマッピングを使うと<br>
よい。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">&lt;F11&gt;</span>&nbsp;&nbsp; -- tags.vimファイルを生成し、タグをハイライトする。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">&lt;F12&gt;</span>&nbsp;&nbsp; -- 既存のtags.vimファイルをもとにハイライトする。<br>
<br>
<span class="Comment">&nbsp;&nbsp;:map &lt;F11&gt;&nbsp;&nbsp;:sp tags&lt;CR&gt;:%s/^\([^&nbsp;&nbsp;&nbsp;&nbsp; :]*:\)\=\([^&nbsp;&nbsp;&nbsp;&nbsp;]*\).*/syntax keyword Tag \2/&lt;CR&gt;:wq! tags.vim&lt;CR&gt;/^&lt;CR&gt;&lt;F12&gt;</span><br>
<span class="Comment">&nbsp;&nbsp;:map &lt;F12&gt;&nbsp;&nbsp;:so tags.vim&lt;CR&gt;</span><br>
<br>
WARNING: tagsファイルが大きくなるほどこの操作は遅くなり、消費するメモリ量も多<br>
くなる。<br>
<br>
typedef、union、structだけをハイライトすることもできる。そのためにはExuberant ctags<br>
(<span class="Constant"><a href="http://ctags.sf.net">http://ctags.sf.net</a></span>で入手可能)が必要である。<br>
<br>
以下をあなたのMakefileに加える:<br>
<br>
# 型用のハイライトファイルを作成する。Exuberant ctagsとawkが必要<br>
types: types.vim<br>
types.vim: *.[ch]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctags --c-kinds=gstu -o- *.[ch] |\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;awk 'BEGIN{printf(&quot;syntax keyword Type\t&quot;)}\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{printf(&quot;%s &quot;, $$1)}END{print &quot;&quot;}' &gt; $@<br>
<br>
そして以下を.vimrcに加える:<br>
<br>
<span class="Comment">&nbsp;&nbsp; &quot; load the types.vim highlighting file, if it exists</span><br>
<span class="Comment">&nbsp;&nbsp; autocmd BufRead,BufNewFile *.[ch] let fname = expand('&lt;afile&gt;:p:h') . '/types.vim'</span><br>
<span class="Comment">&nbsp;&nbsp; autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)</span><br>
<span class="Comment">&nbsp;&nbsp; autocmd BufRead,BufNewFile *.[ch]&nbsp;&nbsp; exe 'so ' . fname</span><br>
<span class="Comment">&nbsp;&nbsp; autocmd BufRead,BufNewFile *.[ch] endif</span><br>
<br>
<span class="PreProc">==============================================================================</span><br>
16. ウィンドウローカル構文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#:ownsyntax" name=":ownsyntax">*:ownsyntax*</a><br>
<br>
通常は同じバッファを表示するすべてのウィンドウは同じ構文設定を共有します。しか<br>
しながら、特定のウィンドウだけ別の構文設定を使用することも可能です。例えば<br>
一つのウィンドウで LaTeX のソースを普通に表示して、別のウィンドウで異なる表示<br>
をする (文字を隠したり太字や斜字体で表示したりする) ことが可能です。その場合は<br>
<a class="Type" href="options.html#'scrollbind'">'scrollbind'</a>&nbsp;オプションを使うと便利です。<br>
<br>
同じバッファを表示しているウィンドウが複数あって、現在のウィンドウの構文だけを<br>
&quot;foo&quot; に設定するには次のようにします:<br>
<span class="Comment">&nbsp;&nbsp; :ownsyntax foo</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#w:current_syntax" name="w:current_syntax">*w:current_syntax*</a><br>
&quot;w:current_syntax&quot; 変数が &quot;foo&quot; に設定されます。&quot;b:current_syntax&quot; 変数の値は<br>
変更されません。&quot;b:current_syntax&quot; は構文ファイルによって変更されますが、<br>
&quot;b:current_syntax&quot; を一時的に保存・復元することで値が変わらないようになってい<br>
ます。構文ファイルによって設定された値が &quot;w:current_syntax&quot; に代入されます。<br>
<br>
ウィンドウの独自構文が定義されると、同じバッファの他のウィンドウで実行された構<br>
文コマンドが影響しなくなります。逆に、そのウィンドウで実行された構文コマンドも<br>
他のウィンドウには影響しなくなります。<br>
<br>
独自構文を持ったウィンドウは他のバッファを読み込むかファイルを再読み込みするこ<br>
とで通常の動作に戻ります。<br>
ウィンドウを分割したときは、新しいウィンドウは元々の構文を使います。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
17. カラー対応xterm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#xterm-color" name="xterm-color">*xterm-color*</a>&nbsp;<a class="Constant" href="syntax.html#color-xterm" name="color-xterm">*color-xterm*</a><br>
<br>
ほとんどのカラー対応xtermは8色しか持たない。デフォルト設定で色がつかない場合は<br>
以下を.vimrcに加えれば正常に色がつくはずである:<br>
<span class="Comment">&nbsp;&nbsp; :if &amp;term =~ &quot;xterm&quot;</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;if has(&quot;terminfo&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;set t_Co=8</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;set t_Sf=&lt;Esc&gt;[3%p1%dm</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;set t_Sb=&lt;Esc&gt;[4%p1%dm</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;else</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;set t_Co=8</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;set t_Sf=&lt;Esc&gt;[3%dm</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;set t_Sb=&lt;Esc&gt;[4%dm</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp; :endif</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<span class="Special">&lt;Esc&gt;</span>はエスケープ文字そのもの。<span class="Special">CTRL-V</span>&nbsp;<span class="Special">&lt;Esc&gt;</span>とタイプして入力する]<br>
<br>
最初の&quot;if&quot;を自分のターミナル名にマッチするように変更する必要があるかもしれない<br>
例: &quot;xterm&quot;でなく&quot;dtterm&quot;。<br>
<br>
<span class="Todo">Note</span>: これらの設定は&quot;:syntax on&quot;の前に行うこと。そうでないと色がおかしくなって<br>
しまう。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#xiterm" name="xiterm">*xiterm*</a>&nbsp;<a class="Constant" href="syntax.html#rxvt" name="rxvt">*rxvt*</a><br>
上の設定はxitermとrxvtでも動作するように注意されている。しかしrxvtで16色を使う<br>
場合にはterminfoを設定しなければならない:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set t_AB=&lt;Esc&gt;[%?%p1%{8}%&lt;%t25;%p1%{40}%+%e5;%p1%{32}%+%;%dm</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set t_AF=&lt;Esc&gt;[%?%p1%{8}%&lt;%t22;%p1%{30}%+%e1;%p1%{22}%+%;%dm</span><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*colortest.vim*</span><br>
色設定をテストするためのファイルがVimディストリビューションに入っている。これ<br>
を使うには次のコマンドを実行する:<br>
<span class="Comment">&nbsp;&nbsp; :runtime syntax/colortest.vim</span><br>
<br>
xtermのあるバージョン(とlinuxコンソールのようなターミナル)は、たとえ色数が8に<br>
定義されていても、より明るい文字色を出力することができる。そのため<a class="Type" href="term.html#'t_Co'">'t_Co'</a>が8の<br>
とき、Vimは明るい文字色に対して&quot;cterm=bold&quot;属性をセットする。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#xfree-xterm" name="xfree-xterm">*xfree-xterm*</a><br>
16色以上を使うにはxtermの最新バージョンを入手すること(XFree86 3.3以降に含まれ<br>
ているはずである)。また、以下の場所でも最新バージョンを入手できる:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://invisible-island.net/xterm/xterm.html">http://invisible-island.net/xterm/xterm.html</a></span><br>
次にそれをconfigureするよい方法を示す。これは88色を使い、termcap-query機能を有<br>
効化する。これによってVimがxtermに何色をサポートしているか問い合わせることがで<br>
きるようになる<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;./configure --disable-bold-color --enable-88-color --enable-tcap-query</span><br>
もし8色しか使えなかったらxtermのコンパイル設定を確認すること。<br>
(このxtermをUTF-8エンコーディングで使う場合には<a class="Identifier" href="mbyte.html#UTF8-xterm">|UTF8-xterm|</a>も参照)。<br>
<br>
以下を.vimrcに加えるとこのxtermで動くはずである(16色用):<br>
<span class="Comment">&nbsp;&nbsp; :if has(&quot;terminfo&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_Co=16</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_AB=&lt;Esc&gt;[%?%p1%{8}%&lt;%t%p1%{40}%+%e%p1%{92}%+%;%dm</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_AF=&lt;Esc&gt;[%?%p1%{8}%&lt;%t%p1%{30}%+%e%p1%{82}%+%;%dm</span><br>
<span class="Comment">&nbsp;&nbsp; :else</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_Co=16</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_Sf=&lt;Esc&gt;[3%dm</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_Sb=&lt;Esc&gt;[4%dm</span><br>
<span class="Comment">&nbsp;&nbsp; :endif</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<span class="Special">&lt;Esc&gt;</span>はエスケープ文字そのもの。<span class="Special">CTRL-V</span>&nbsp;<span class="Special">&lt;Esc&gt;</span>とタイプして入力する]<br>
<br>
<a class="Identifier" href="various.html#+terminfo">|+terminfo|</a>なしではVimはこれらの設定を認識し、自動的にctermの8色と上の設定を<br>
&quot;<span class="Special">&lt;Esc&gt;</span>[9%dm&quot; と &quot;<span class="Special">&lt;Esc&gt;</span>[10%dm&quot;に変換する。16色以上も自動的に変換される。<br>
<br>
以下の設定が256色用にうまくいくと報告されている:<br>
<br>
<span class="Comment">&nbsp;&nbsp; :set t_AB=&lt;Esc&gt;[48;5;%dm</span><br>
<span class="Comment">&nbsp;&nbsp; :set t_AF=&lt;Esc&gt;[38;5;%dm</span><br>
<br>
または単にTERM環境変数を&quot;xterm-color&quot;または&quot;xterm-16color&quot;にセットし、うまくい<br>
くか試してみるとよい。<br>
<br>
以下のX resourcesを(~/.Xdefaultsファイルで)使いたいかもしれない:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #000000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #c00000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #008000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #808000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color4:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #0000c0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color5:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #c000c0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color6:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #008080<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color7:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #c0c0c0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color8:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #808080<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color9:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #ff6060<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color10:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#00ff00<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color11:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ffff00<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color12:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#8080ff<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color13:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ff40ff<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color14:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#00ffff<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*color15:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ffffff<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xterm*cursorColor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Black<br>
<br>
[<span class="Todo">Note</span>: cursorColorにはバグがある。カーソルの色が最後に描画されたテキストの色に<br>
なってしまうというものである。これはxtermの新しいバージョンを使うと解決する<br>
が、まだ全ての人がそれを使っているわけではない。]<br>
<br>
これらを即座に更新するには.XdefaultsファイルをXオプションデータベースマネー<br>
ジャに再読み込みさせる(.Xdefaultsを変更したときはこれを行う必要がある):<br>
<span class="Comment">&nbsp;&nbsp;xrdb -merge ~/.Xdefaults</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*xterm-blink* *xterm-blinking-cursor*</span><br>
xtermでカーソルを点滅させるにはtools/blink.cを見ること。またはThomas Dickeyの<br>
xtermのパッチレベル107以上を使い(入手場所は上を参照)、以下のリソースを設定す<br>
る。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*cursorBlink:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*cursorOnTime:&nbsp;&nbsp;&nbsp;&nbsp; 400<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*cursorOffTime:&nbsp;&nbsp;&nbsp;&nbsp;250<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XTerm*cursorColor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;White<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#hpterm-color" name="hpterm-color">*hpterm-color*</a><br>
次の設定はhptermで(大体)うまく機能する。文字色は8色だけサポートしている:<br>
<span class="Comment">&nbsp;&nbsp; :if has(&quot;terminfo&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_Co=8</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_Sf=&lt;Esc&gt;[&amp;v%p1%dS</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_Sb=&lt;Esc&gt;[&amp;v7S</span><br>
<span class="Comment">&nbsp;&nbsp; :else</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_Co=8</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_Sf=&lt;Esc&gt;[&amp;v%dS</span><br>
<span class="Comment">&nbsp;&nbsp; :&nbsp;&nbsp;set t_Sb=&lt;Esc&gt;[&amp;v7S</span><br>
<span class="Comment">&nbsp;&nbsp; :endif</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<span class="Special">&lt;Esc&gt;</span>はエスケープ文字そのもの。<span class="Special">CTRL-V</span>&nbsp;<span class="Special">&lt;Esc&gt;</span>とタイプして入力する]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#Eterm" name="Eterm">*Eterm*</a>&nbsp;<a class="Constant" href="syntax.html#enlightened-terminal" name="enlightened-terminal">*enlightened-terminal*</a><br>
次の設定がEnlightenedターミナルエミュレータまたはEtermで機能すると報告されてい<br>
る。また、明るい色を表示するのにbold属性を使うxtermライクターミナル全てで機能<br>
すると思われる。必要なら前述のように&quot;:if&quot;をつけること。<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :set t_Co=16</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :set t_AF=^[[%?%p1%{8}%&lt;%t3%p1%d%e%p1%{22}%+%d;1%;m</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :set t_AB=^[[%?%p1%{8}%&lt;%t4%p1%d%e%p1%{32}%+%d;1%;m</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="syntax.html#TTpro-telnet" name="TTpro-telnet">*TTpro-telnet*</a><br>
次の設定がTTpro telnet用にうまくいく。Tera Term ProはMS-Windows用のフリーウェ<br>
ア/オープンソースプログラムである。<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set t_Co=16</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set t_AB=^[[%?%p1%{8}%&lt;%t%p1%{40}%+%e%p1%{32}%+5;%;%dm</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set t_AF=^[[%?%p1%{8}%&lt;%t%p1%{30}%+%e%p1%{22}%+1;%;%dm</span><br>
また、TTproのSetup→Window→Full Colorが有効になっていることと、<br>
Setup→Font→Enable Boldが無効になっていることを確認すること。<br>
(この情報はJohn Love-Jensen &lt;eljay@Adobe.COM&gt;によって提供された)<br>
<br>
&nbsp;vim&#0058;tw=78:sw=4:ts=8:ft=help:norl:<br>
