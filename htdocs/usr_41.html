---
layout: vimdoc
helpname: 'usr_41'
---
<a class="Constant" href="usr_41.html" name="usr_41.txt">*usr_41.txt*</a>&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;<span class="Identifier">Vim バージョン 7.3.</span>&nbsp;&nbsp;Last change: 2011 Dec 15<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VIM USER MANUAL - by Bram Moolenaar<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vim スクリプト書法<br>
<br>
<br>
Vim スクリプト言語は vimrc ファイルや構文ファイルなど、さまざまな目的に使われ<br>
ます。この章では Vim スクリプトの書き方を説明します。説明することがたくさんあ<br>
るので大きな章になってます。<br>
<br>
<a class="Identifier" href="usr_41.html#41.1">|41.1|</a>&nbsp;&nbsp;はじめに<br>
<a class="Identifier" href="usr_41.html#41.2">|41.2|</a>&nbsp;&nbsp;変数<br>
<a class="Identifier" href="usr_41.html#41.3">|41.3|</a>&nbsp;&nbsp;式<br>
<a class="Identifier" href="usr_41.html#41.4">|41.4|</a>&nbsp;&nbsp;条件式<br>
<a class="Identifier" href="usr_41.html#41.5">|41.5|</a>&nbsp;&nbsp;式を実行する<br>
<a class="Identifier" href="usr_41.html#41.6">|41.6|</a>&nbsp;&nbsp;関数を使う<br>
<a class="Identifier" href="usr_41.html#41.7">|41.7|</a>&nbsp;&nbsp;関数を定義する<br>
<a class="Identifier" href="usr_41.html#41.8">|41.8|</a>&nbsp;&nbsp;リストと辞書<br>
<a class="Identifier" href="usr_41.html#41.9">|41.9|</a>&nbsp;&nbsp;例外<br>
<a class="Identifier" href="usr_41.html#41.10">|41.10|</a>&nbsp;注意事項<br>
<a class="Identifier" href="usr_41.html#41.11">|41.11|</a>&nbsp;プラグインを書く<br>
<a class="Identifier" href="usr_41.html#41.12">|41.12|</a>&nbsp;ファイルタイププラグインを書く<br>
<a class="Identifier" href="usr_41.html#41.13">|41.13|</a>&nbsp;コンパイラプラグインを書く<br>
<a class="Identifier" href="usr_41.html#41.14">|41.14|</a>&nbsp;プラグインを書く (高速ロード版)<br>
<a class="Identifier" href="usr_41.html#41.15">|41.15|</a>&nbsp;ライブラリスクリプトを書く<br>
<a class="Identifier" href="usr_41.html#41.16">|41.16|</a>&nbsp;Vim スクリプトを配布する<br>
<br>
次章:&nbsp;<a class="Identifier" href="usr_42.html">|usr_42.txt|</a>&nbsp;&nbsp;新しいメニューを追加する<br>
前章:&nbsp;<a class="Identifier" href="usr_40.html">|usr_40.txt|</a>&nbsp;&nbsp;新しいコマンドを作る<br>
目次:&nbsp;<a class="Identifier" href="usr_toc.html">|usr_toc.txt|</a><br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.1" name="41.1">*41.1*</a>&nbsp;&nbsp;はじめに&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#vim-script-intro" name="vim-script-intro">*vim-script-intro*</a>&nbsp;<a class="Constant" href="usr_41.html#script" name="script">*script*</a><br>
<br>
誰もが最初に触れる Vim スクリプトは vimrc ファイルです。Vim が起動するときに読<br>
み込まれ、書かれているコマンドが実行されます。それにより好きなように設定を変更<br>
できます。vimrc の中ではすべてのコロンコマンドが使えます (&quot;:&quot; で始まるコマンド<br>
のこと。Ex コマンドやコマンドラインコマンドと呼ばれることもある)。<br>
シンタックスファイルも Vim スクリプトです。シンタックスファイルは、ファイルタ<br>
イプ別にオプションを設定するファイルの一種です。複雑なマクロ定義を別ファイルに<br>
分けて保存しておくこともできます。このように、いろいろな使用方法が考えられま<br>
す。<br>
<br>
簡単な例から始めましょう:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let i = 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:while i &lt; 5</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo &quot;count is&quot; i</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let i += 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endwhile</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;実際には &quot;:&quot; を書く必要はありません。&quot;:&quot; が必要なのはコマンドラインで<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;入力するときだけです。Vim スクリプトファイルを書くときは省略できます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;このヘルプでは、コロンコマンドであることを強調し、ノーマルモードと区別<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;するためにコロンを表記しています。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例文をヤンクして :@&quot; コマンドで実際に実行できます。<br>
<br>
出力は次のようになります:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">count is 1</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">count is 2</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">count is 3</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">count is 4</span><br>
<br>
一行目では &quot;:let&quot; コマンドで変数に値を代入しています。書式は次のとおりです:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let {変数名} = {式}</span><br>
<br>
例では、変数名が &quot;i&quot;、式が 1 です。<br>
&quot;:while&quot; コマンドでループを開始します。書式は次のとおりです:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:while {条件式}</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;{ステートメント}</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endwhile</span><br>
<br>
条件式が真である間、ステートメントが実行されます。例では、条件式は &quot;i &lt; 5&quot; で<br>
す。これは、i が 5 より小さい場合に真になります。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;何かのミスで while ループが止まらなかった場合は、<span class="Special">CTRL-C</span>&nbsp;を押せば中断で<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;きます (MS-Windows では&nbsp;<span class="Special">CTRL-Break</span>)。<br>
<br>
&quot;:echo&quot; コマンドは引数を出力します。例では、&quot;count is&quot; という文字列と、変数 i<br>
の値を出力しています。i が 1 なら、次のように表示されます:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">count is 1</span><br>
<br>
&quot;:let i += 1&quot; は &quot;:let i = i + 1&quot; と同じ意味です。変数 i に 1 を加算し、新しい<br>
値を同じ変数に代入します。<br>
<br>
上述の例は、実際にはもっと簡潔に書くことができます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:for i in range(1, 4)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo &quot;count is&quot; i</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfor</span><br>
<br>
<a class="Identifier" href="eval.html#:for">|:for|</a>&nbsp;と&nbsp;<a class="Identifier" href="eval.html#range()">|range()|</a>&nbsp;の説明はもっと先です。すぐに知りたい人はリンク先にジャンプ<br>
してください。<br>
<br>
<br>
三種類の数値<br>
<span class="PreProc">------------</span><br>
<br>
数値は10進数、16進数、8進数のいずれかで表記します。16進数は &quot;0x&quot; か &quot;0X&quot; で開<br>
始します。例えば &quot;0x1f&quot; は10進数の 31 です。8進数は &quot;0&quot; で開始します。例えば<br>
&quot;017&quot; は10進数の 15 です。注意: 10進数で書くときは先頭に &quot;0&quot; を付けないでくだ<br>
さい。8進数として扱われてしまいます。<br>
&quot;:echo&quot; コマンドは常に10進数で出力します。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo 0x7f 036</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">127 30</span><br>
<br>
数値にマイナス記号を付けると負数になります。8進数や16進数も負数にできます。マ<br>
イナス記号は減算記号としても使われます。次の例を上の例と比べてみてください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo 0x7f -036</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">97</span><br>
<br>
式の途中にある空白は無視されますが、可読性を高めるために、適切に空白で区切るこ<br>
とをお勧めします。例えば上記の数値が負数であると勘違いしてしまわないように、マ<br>
イナス記号と数値の間に空白をいれましょう:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo 0x7f - 036</span><br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.2" name="41.2">*41.2*</a>&nbsp;&nbsp;変数<br>
<br>
変数名にはアルファベット、数字、アンダースコアが使えます。変数名を数字で開始す<br>
ることはできません。次のような変数名が使えます:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_aap3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;very_long_variable_name_with_underscores<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FuncLength<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LENGTH<br>
<br>
&quot;foo+var&quot; や &quot;6var&quot; のような名前は使えません。<br>
例に挙げた変数はグローバル変数です。定義されている変数の一覧を見るのは次のコマ<br>
ンドを使います:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let</span><br>
<br>
グローバル変数はどこでも使えます。そのため、あるスクリプトファイルで &quot;count&quot;<br>
という変数を使ったとき、その変数は他のスクリプトでも使われている可能性がありま<br>
す。これは混乱を招きますし、トラブルの元です。それを避けるには &quot;s:&quot; を付けてス<br>
クリプトローカル変数を使います。例えば、次のように使います:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let s:count = 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:while s:count &lt; 5</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;source other.vim</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let s:count += 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endwhile</span><br>
<br>
&quot;s:count&quot; はスクリプトローカル変数なので、他のスクリプトファイルによって変更さ<br>
れる心配はありません。他のスクリプトファイルで &quot;s:count&quot; 変数が使われていたと<br>
しても、それは別の変数です。スクリプトローカル変数についての詳細は<br>
<a class="Identifier" href="eval.html#script-variable">|script-variable|</a>&nbsp;を参照してください。<br>
<br>
変数の種類は他にもあります。<a class="Identifier" href="eval.html#internal-variables">|internal-variables|</a>&nbsp;参照。次の変数がよく使われま<br>
す:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b:name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;バッファローカル変数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w:name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ウィンドウローカル変数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;グローバル変数 (関数内では g: 必須)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v:name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vim が定義する変数<br>
<br>
<br>
変数の削除<br>
<span class="PreProc">----------</span><br>
<br>
変数はメモリを消費します。&quot;:let&quot; コマンドの出力にも表示されます。変数を削除す<br>
るには &quot;:unlet&quot; コマンドを使います。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unlet s:count</span><br>
<br>
スクリプトローカル変数の &quot;s:count&quot; が削除され、使用されていたメモリが開放され<br>
ます。変数が存在しない場合でもエラーを起こしたくない場合は ! を付けてください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unlet! s:count</span><br>
<br>
スクリプトの実行が終了したとき、ローカル変数は自動的には削除されません。次に同<br>
じスクリプトを実行したときにその変数を使うことができます。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if !exists(&quot;s:call_count&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let s:call_count = 0</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let s:call_count = s:call_count + 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo &quot;called&quot; s:call_count &quot;times&quot;</span><br>
<br>
&quot;exists()&quot; 関数は変数が定義されているかどうかをチェックします。引数に調べたい<br>
変数の名前を指定します。変数自体を指定するのではありません。例えば:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if !exists(s:call_count)</span><br>
<br>
これは、s:call_count の値を変数名として exists() 関数を呼び出しているので、意<br>
味が違ってしまいます。<br>
感嘆符 (! 記号) は値を反転します。値が真なら偽になり、偽なら真になります。この<br>
記号は &quot;not&quot; と読むことができます。つまり、&quot;if !exists()&quot; は &quot;if not exists()&quot;<br>
と読むことができます。<br>
Vim では、0 以外の値はすべて真です。0 は偽です。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数値が必要なところで文字列を使ったとき、文字列は自動的に数値に変換され<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ます。文字列の先頭が数字ではなかった場合は 0 に変換されます。つまり:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if &quot;true&quot;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;true&quot; は 0 に変換されるので偽になります。<br>
<br>
<br>
文字列変数と定数<br>
<span class="PreProc">----------------</span><br>
<br>
ここまでは変数の値に数値だけを使っていましたが、文字列を使うこともできます。<br>
Vim は数値と文字列を基本型としてサポートしています。変数は動的に型付けされま<br>
す。型は &quot;:let&quot; コマンドで変数に値を代入するたびに変化します。詳しくは<a class="Identifier" href="usr_41.html#41.8">|41.8|</a><br>
を参照してください。<br>
変数に文字列を代入するには文字列定数を使う必要があります。文字列定数には二つの<br>
種類があります。一つはダブルクオート文字列です:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let name = &quot;peter&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo name</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">peter</span><br>
<br>
文字列の中でダブルクオートを使いたい場合は、バックスラッシュを前置してくださ<br>
い:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let name = &quot;\&quot;peter\&quot;&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo name</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">&quot;peter&quot;</span><br>
<br>
バックスラッシュを使いたくない場合はシングルクオート文字列を使ってください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let name = '&quot;peter&quot;'</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo name</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">&quot;peter&quot;</span><br>
<br>
シングルクオート文字列の中ではすべての文字がそのまま使われます。ただし、シング<br>
ルクオートだけは特別で、一つのシングルクオートを表すためには二つのシングルク<br>
オートを書く必要があります。バックスラッシュはそのまま使われるので、特殊文字は<br>
使えません。<br>
ダブルクオート文字列の中では特殊文字が使えます。次のようなものがあります:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">&lt;Tab&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">&lt;NL&gt;</span>, 改行<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">&lt;CR&gt;</span>,&nbsp;<span class="Special">&lt;Enter&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">&lt;Esc&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">&lt;BS&gt;</span>, バックスペース<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\, バックスラッシュ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<span class="Special">&lt;Esc&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">&lt;Esc&gt;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<span class="Special">&lt;C-W&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">CTRL-W</span><br>
<br>
最後の二つはただの一例です。&quot;\<span class="Special">&lt;name&gt;</span>&quot; 形式で &quot;name&quot; という特殊キーを使うことが<br>
できます。<br>
文字列で使える特殊表記については&nbsp;<a class="Identifier" href="eval.html#expr-quote">|expr-quote|</a>&nbsp;を参照してください。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.3" name="41.3">*41.3*</a>&nbsp;&nbsp;式<br>
<br>
Vim の式は高機能でシンプルです。式の定義については&nbsp;<a class="Identifier" href="eval.html#expression-syntax">|expression-syntax|</a>&nbsp;を参照<br>
してください。ここでは基本的なことだけを説明します。<br>
数値と文字列と変数はそれ自体が式です。つまり、式が必要なところでは数値でも文字<br>
列でも変数でも使えます。他にも次のようなものが使えます:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 環境変数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; オプション<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;レジスタ<br>
<br>
例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo &quot;The value of 'tabstop' is&quot; &amp;ts</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo &quot;Your home directory is&quot; $HOME</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if @a &gt; 5</span><br>
<br>
&amp;name 形式を使うと、オプションを保存し、別の値に設定し、何かを実行して、オプ<br>
ションを元に戻す、というようなことができます。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let save_ic = &amp;ic</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set noic</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:/The Start/,$delete</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let &amp;ic = save_ic</span><br>
<br>
<a class="Type" href="options.html#'ignorecase'">'ignorecase'</a>&nbsp;オプションをオフにしてから &quot;The Start&quot; パターンを検索しています。<br>
しかし設定は変更されません。(パターンに &quot;\C&quot; を加える方法でも同じことができま<br>
す。<a class="Identifier" href="pattern.html#/\C">|/\C|</a>&nbsp;参照。)<br>
<br>
<br>
数値計算<br>
<span class="PreProc">--------</span><br>
<br>
基本的な要素を組み合わせると面白くなってきます。まずは数値計算です:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a + b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 加算<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a - b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 減算<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a * b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 乗算<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a / b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 除算<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a % b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 剰余演算(余りを得る)<br>
<br>
演算子の優先順位は一般的な規則と同じです:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo 10 + 5 * 2</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">20</span><br>
<br>
カッコを使って優先順位を変更できます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo (10 + 5) * 2</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">30</span><br>
<br>
文字列は &quot;.&quot; で連結できます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo &quot;foo&quot; . &quot;bar&quot;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">foobar</span><br>
<br>
&quot;:echo&quot; コマンドに複数の引数を指定すると、スペースで区切られて表示されます。こ<br>
れらの例では一つの式しか使われていないので、スペースは挿入されていません。<br>
<br>
C 言語と同じ条件演算子も使えます:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a ? b : c<br>
<br>
&quot;a&quot; が真なら &quot;b&quot; が使われ、そうでなければ &quot;c&quot; が使われます。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let i = 4</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo i &gt; 5 ? &quot;i is big&quot; : &quot;i is small&quot;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">i is small</span><br>
<br>
被演算子の部分は優先的に評価されるので、次のように見なすことができます:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a) ? (b) : (c)<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.4" name="41.4">*41.4*</a>&nbsp;&nbsp;条件式<br>
<br>
&quot;:if&quot; コマンドは条件が真の場合に &quot;:endif&quot; までのステートメントを実行します。書<br>
式は次のとおり:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if&nbsp;<span class="Special">{condition}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{statements}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif<br>
<br>
<span class="Special">{condition}</span>&nbsp;を評価した結果が真 (0以外) であれば、<span class="Special">{statements}</span>&nbsp;の内容が実行され<br>
ます。<span class="Special">{statements}</span>&nbsp;は正しく記述されている必要があります。不正な記述があると<br>
&quot;:endif&quot; までたどり着けません。<br>
&quot;:else&quot; を使うこともできます。書式は次のとおり:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if&nbsp;<span class="Special">{condition}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{statements}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{statements}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif<br>
<br>
二つ目の&nbsp;<span class="Special">{statements}</span>&nbsp;は条件が偽の場合にだけ実行されます。<br>
&quot;:elseif&quot; を使うこともできます:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if&nbsp;<span class="Special">{condition}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{statements}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:elseif&nbsp;<span class="Special">{condition}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{statements}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif<br>
<br>
これは &quot;:else&quot; に続けて &quot;if&quot; 文を使うのと同じ動作ですが、余計な &quot;:endif&quot; を使<br>
わなくて済みます。<br>
vimrc ファイルで便利に使える例を示しましょう。<a class="Type" href="options.html#'term'">'term'</a>&nbsp;オプションの値を調べ、そ<br>
の値に応じて処理を分けます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if &amp;term == &quot;xterm&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&quot; xterm 用の設定</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:elseif &amp;term == &quot;vt100&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&quot; vt100 端末用の設定</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:else</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&quot; その他の端末用の設定</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif</span><br>
<br>
<br>
論理演算子<br>
<span class="PreProc">----------</span><br>
<br>
今までの説明で既に論理演算子を使いました。次の演算子がよく使われます:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a == b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等しい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a != b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等しくない<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a &gt;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;より大きい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a &gt;= b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;より大きいか等しい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a &lt;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;より小さい<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a &lt;= b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;より小さいか等しい<br>
<br>
条件が成立するなら 1、そうでなければ 0 が返ります。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if v:version &gt;= 700</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo &quot;おめでとう&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:else</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo &quot;古いバージョンを使っています。更新してね!&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif</span><br>
<br>
&quot;v:version&quot; は Vim によって定義されている変数で、Vim のバージョンが入っていま<br>
す。バージョン 6.0 なら 600、バージョン 6.1 なら 601 です。これは複数のバー<br>
ジョンに対応するスクリプトを書くときに便利です。<a class="Identifier" href="eval.html#v:version">|v:version|</a><br>
<br>
論理演算子は数値でも文字列でも扱えます。文字列どうしを比較するときは数学的な差<br>
が比較されます。文字のバイト値を比較するので、一部の言語では正しい結果にならな<br>
いかもしれません。<br>
文字列と数値を比較するときは、文字列を数値に変換します。文字列が数字ではなかっ<br>
たときは 0 になるので注意してください。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if 0 == &quot;one&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo &quot;yes&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif</span><br>
<br>
これは &quot;yes&quot; と表示されます。&quot;one&quot; は数字ではないので 0 に変換されるのです。<br>
<br>
文字列にはさらに二つの論理演算子があります:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a =~ b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;パターンにマッチする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a !~ b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;パターンにマッチしない<br>
<br>
左辺の &quot;a&quot; は文字列として扱われます。右辺の &quot;b&quot; は検索パターンとして扱われま<br>
す。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if str =~ &quot; &quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo &quot;str にはスペースが含まれている&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if str !~ '\.$'</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo &quot;str の末尾はピリオドではない&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif</span><br>
<br>
パターンを指定するのにシングルクオート文字列を使うのがコツです。ダブルクオート<br>
文字列ではバックスラッシュを二重に書く必要があり、そして、検索パターンではバッ<br>
クスラッシュをよく使うので、バックスラッシュだらけになってしまいます。<br>
<br>
文字列を比較するときは&nbsp;<a class="Type" href="options.html#'ignorecase'">'ignorecase'</a>&nbsp;オプションが使われます。大文字小文字の区別<br>
を明示的に指定したい場合は比較演算子に &quot;#&quot; (区別する) または &quot;?&quot; (区別しない)<br>
をつけます。大文字小文字を区別せずに等しいかどうかを比較したい場合は &quot;==?&quot; を<br>
使います。&quot;!~#&quot; ならパターンにマッチしないことを、大文字と小文字を区別して確認<br>
できます。演算子の一覧は&nbsp;<a class="Identifier" href="eval.html#expr-==">|expr-==|</a>&nbsp;を参照してください。<br>
<br>
<br>
他のループコマンド<br>
<span class="PreProc">------------------</span><br>
<br>
&quot;:while&quot; コマンドは既に説明しました。&quot;:while&quot; ループの中では二つのステートメン<br>
トが使えます:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:continue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ループの先頭にジャンプしてループを継続する。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;:endwhile&quot; までジャンプしてループを脱ける。<br>
<br>
例：<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:while counter &lt; 40</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;call do_something()</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;if skip_flag</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;continue</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;if finished_flag</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;break</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;sleep 50m</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endwhile</span><br>
<br>
&quot;:sleep&quot; コマンドは Vim を一定時間停止します。&quot;50m&quot; は 50 ミリ秒です。<br>
&quot;:sleep 4&quot; なら 4 秒間スリープします。<br>
<br>
&quot;:for&quot; コマンドを使ってループすることもできます。<a class="Identifier" href="usr_41.html#41.8">|41.8|</a>を参照。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.5" name="41.5">*41.5*</a>&nbsp;&nbsp;式を実行する<br>
<br>
今まではコマンドを直接書いてきました。&quot;:execute&quot; コマンドを使うと、式の評価結<br>
果をコマンドとして実行できます。これによってコマンドを動的に生成することができ<br>
ます。<br>
例えば、変数に格納された文字列を使ってタグジャンプするには次のようにします:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:execute &quot;tag &quot; . tag_name</span><br>
<br>
文字列 &quot;tag &quot; と変数 &quot;tag_name&quot; の値を &quot;.&quot; で連結しています。仮に &quot;tag_name&quot;<br>
の値が &quot;get_cmd&quot; だった場合、次のコマンドが実行されることになります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:tag get_cmd</span><br>
<br>
&quot;:execute&quot; コマンドはコロンコマンドのみ実行できます。&quot;:normal&quot; コマンドでノー<br>
マルモードコマンドを実行できますが、このコマンドの引数は文字がそのまま使われ、<br>
式としては評価されません。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:normal gg=G</span><br>
<br>
このコマンドは一行目にジャンプしてから &quot;=&quot; オペレータですべての行を整形しま<br>
す。<br>
&quot;:normal&quot; コマンドで式の値を使いたい場合は &quot;:execute&quot; と組み合わせてください。<br>
例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:execute &quot;normal &quot; . normal_commands</span><br>
<br>
変数 &quot;normal_commands&quot; にはノーマルモードコマンドを入れておく必要があります。<br>
&quot;:normal&quot; には完結したコマンドを指定するようにしてください。引数が最後まで実行<br>
された段階でコマンドは中断されます。例えば、インサートモードを開始した場合はイ<br>
ンサートモードを終了しなくてはなりません。次のコマンドは正しく動作します:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:execute &quot;normal Inew text \&lt;Esc&gt;&quot;</span><br>
<br>
これは現在行に &quot;new text&quot; を挿入します。特殊キー &quot;\<span class="Special">&lt;ESC&gt;</span>&quot; を使っていることに注<br>
目してください。これによりスクリプトの中で本物の&nbsp;<span class="Special">&lt;Esc&gt;</span>&nbsp;文字を使わないですみま<br>
す。<br>
<br>
文字列を実行するのではなく、その式の値を得たい場合は、eval() 関数を使います:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let optname = &quot;path&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let optval = eval('&amp;' . optname)</span><br>
<br>
文字 &quot;&amp;&quot; と &quot;path&quot; を連結しているので eval() の引数は &quot;&amp;path&quot; になります。返り<br>
値は&nbsp;<a class="Type" href="options.html#'path'">'path'</a>&nbsp;オプションの値です。<br>
次のようにすることもできます:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:exe 'let optval = &amp;' . optname</span><br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.6" name="41.6">*41.6*</a>&nbsp;&nbsp;関数を使う<br>
<br>
たくさんの関数があらかじめ定義され、豊富な機能が提供されています。このセクショ<br>
ンの説明にもいくつか登場します。関数の一覧は&nbsp;<a class="Identifier" href="eval.html#functions">|functions|</a>&nbsp;を参照してください。<br>
<br>
関数は &quot;:call&quot; コマンドで呼び出します。引数はカッコで囲み、それぞれをカンマで<br>
区切ります。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:call search(&quot;Date: &quot;, &quot;W&quot;)</span><br>
<br>
これは &quot;Date: &quot; と &quot;W&quot; を引数にして search() 関数を呼び出しています。search()<br>
関数は一つ目の引数を検索パターンとして使い、二つ目の引数をフラグとして使いま<br>
す。&quot;W&quot; フラグを指定するとファイル末尾で検索が終了します (折り返さない)。<br>
<br>
関数は式の中で使うこともできます。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let line = getline(&quot;.&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let repl = substitute(line, '\a', &quot;*&quot;, &quot;g&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:call setline(&quot;.&quot;, repl)</span><br>
<br>
getline() 関数はカレントバッファから行を取得する関数です。引数には行番号を指定<br>
します。この例では &quot;.&quot; ですが、これはカーソルのある行を示します。<br>
substitute() 関数は &quot;:substitute&quot; コマンドとほぼ同じです。最初の引数は置換対象<br>
の文字列、二つ目の引数はパターン、三つ目は置き換え文字列、最後はフラグです。<br>
setline() 関数は行の内容を置き換えます。最初の引数は行番号、二つ目の引数は置き<br>
換える文字列です。この例では、substitute() の結果で現在行を置き換えています。<br>
上記の三行のコマンドは次のコマンドと同じことをしています:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:substitute/\a/*/g</span><br>
<br>
substitute() コマンドの前後にいろいろな処理を入れたりすると、もっと面白いこと<br>
ができるようになります。<br>
<br>
<br>
関数一覧&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#function-list" name="function-list">*function-list*</a><br>
<span class="PreProc">--------</span><br>
<br>
たくさんの関数があります。ここでは機能別に分類して紹介します。アルファベット順<br>
の一覧は&nbsp;<a class="Identifier" href="eval.html#functions">|functions|</a>&nbsp;を参照してください。関数の名前の上で&nbsp;<span class="Special">CTRL-]</span>&nbsp;を押すと、詳<br>
細な説明にジャンプできます。<br>
<br>
文字列繰作:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#string-functions" name="string-functions">*string-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nr2char()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASCII値から文字を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char2nr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文字のASCII値を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str2nr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字列を数値に変換する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str2float()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文字列を浮動小数点数に変換する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;書式付き文字列を整形する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;escape()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字列の特定の文字を '\' でエスケープ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shellescape()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; シェルコマンドで使えるように文字列をエスケープ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fnameescape()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vim コマンド用にファイル名をエスケープ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ある文字の集合から別の文字の集合へ置換する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strtrans()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字列を印刷可能な状態とする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tolower()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文字列を小文字にする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toupper()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文字列を大文字にする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文字列の中でパターンにマッチした位置<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchend()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字列の中でパターンにマッチした末尾の位置<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchstr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字列の中でパターンにマッチした文字列<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchlist()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matchstr()と同様だが、部分マッチも返す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stridx()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字列の中で部分文字列が見つかった最初の位置<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strridx()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文字列の中で部分文字列が見つかった最後の位置<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strlen()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字列の長さ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;substitute()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;パターンにマッチする文字列を置換<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;submatch()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;:s&quot; と substitute() の中で部分マッチを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strpart()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文字列の一部分を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expand()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特殊キーワードを展開する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iconv()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; テキストのエンコーディングを変換する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byteidx()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文字列中の文字のバイトインデックス<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字列を複数回繰り返す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eval()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字列を式として評価する<br>
<br>
リスト操作:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#list-functions" name="list-functions">*list-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要素を取得。存在しないインデックスでもエラーを<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;出さない<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; リスト中の要素の個数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; リストが空であるか判定する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insert()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リストの任意の位置に要素を挿入する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; リストに要素を追加する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extend()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リストにリストを連結する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リストから1個以上の要素を取り除く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リストの浅いコピーを作成する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deepcopy()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リストの完全なコピーを作成する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リストから選択された要素を取り除く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; リストの各要素を変換する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リストをソートする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverse()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; リストの並び順を反転させる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 文字列を分割し、リストにする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;join()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リストの要素を連結し、文字列にする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;range()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 数列リストを返す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リストの文字列表現<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リストを引数として関数を呼ぶ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; リスト中の要素のインデックス<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; リスト中の最大値<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; リスト中の最小値<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ある要素がリスト中に出現する回数を返す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;リストを複数回繰り返す<br>
<br>
辞書操作:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#dict-functions" name="dict-functions">*dict-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 辞書の要素を返す。存在しないキーでもエラーを出<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;さない<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 辞書の要素の個数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has_key()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; あるキーが辞書に含まれているか判定する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 辞書が空であるか判定する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辞書から要素を取り除く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extend()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ある辞書の要素をすべて別の辞書に追加する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辞書から選択された要素を取り除く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 辞書の各要素を変換する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辞書の全キーのリストを取得する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辞書の全値のリストを取得する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 辞書の全キー・値のペアを取得する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辞書の浅いコピーを作成する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deepcopy()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辞書の完全なコピーを作成する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辞書の文字列表現<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 辞書中の最大値<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 辞書中の最小値<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ある値が出現する回数を返す<br>
<br>
浮動小数点数の計算:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#float-functions" name="float-functions">*float-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float2nr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Float を Number に変換<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abs()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 絶対値 (Numberも処理可能)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;round()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 丸め<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ceil()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;切り上げ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;floor()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 切り下げ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trunc()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 少数切り捨て<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log10()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 を底とする対数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pow()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x の y 乗<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqrt()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平方根<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sin()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cos()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cosine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tan()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tangent<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asin()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arc sine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acos()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arc cosine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atan()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arc tangent<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atan2()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arc tangent<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sinh()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hyperbolic sine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cosh()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hyperbolic cosine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tanh()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hyperbolic tangent<br>
<br>
その他の計算:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#bitwise-function" name="bitwise-function">*bitwise-function*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bitwise AND<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invert()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bitwise invert<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bitwise OR<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xor()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bitwise XOR<br>
<br>
変数:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#var-functions" name="var-functions">*var-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;変数の型<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;islocked()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;変数がロックされているか判定する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;関数名からFuncrefを取得する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getbufvar()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定バッファの変数値を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setbufvar()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定バッファに変数を設定する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getwinvar()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定ウィンドウの変数値を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gettabvar()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定タブページから変数値を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gettabwinvar()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定ウィンドウ・タブページから変数値を取得する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setwinvar()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定ウィンドウに変数を設定する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;settabvar()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定タブページに変数を設定する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;settabwinvar()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定ウィンドウ・タブページに変数を設定する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;garbagecollect()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;開放可能なメモリを解放する<br>
<br>
カーソルとマークの位置:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#cursor-functions" name="cursor-functions">*cursor-functions*</a>&nbsp;<a class="Constant" href="usr_41.html#mark-functions" name="mark-functions">*mark-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;col()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; カーソルやマークの列番号を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtcol()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; カーソルやマークの画面上の列番号を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カーソルやマークの行番号を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wincol()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カーソルのウィンドウでの列番号<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;winline()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; カーソルのウィンドウでの行番号<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cursor()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カーソルを指定した位置に移動させる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getpos()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カーソルやマークなどの位置を取得する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setpos()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カーソルやマークなどの位置を設定する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte2line()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定のバイト位置の行番号を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line2byte()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定の行のバイト位置を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diff_filler()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ある行より上の詰め行の数を取得する<br>
<br>
カレントバッファで動作するもの:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#text-functions" name="text-functions">*text-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getline()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; バッファから行を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setline()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; バッファの行を置き換える<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;append()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行または行のリストをバッファに追加する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indent()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行のインデントを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cindent()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C 言語におけるインデントを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lispindent()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lisp 言語におけるインデントを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextnonblank()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;次の非空行を探す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prevnonblank()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前の非空行を探す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;パターンにマッチする場所を探す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchpos()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; パターンにマッチする場所を探す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchpair()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start/skip/end の対を探す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchpairpos()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start/skip/end の対を探す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;searchdecl()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;名前が宣言されている場所を探す<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#system-functions" name="system-functions">*system-functions*</a>&nbsp;<a class="Constant" href="usr_41.html#file-functions" name="file-functions">*file-functions*</a><br>
システム関数とファイル繰作:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;glob()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ワイルドカードを展開する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;globpath()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;複数のディレクトリを対象にワイルドカードを展開<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findfile()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;複数のディレクトリからファイルを探す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finddir()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 複数のディレクトリからディレクトリを探す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ショートカットのリンク先を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fnamemodify()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ファイル名を修飾する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathshorten()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; パス中のディレクトリ名を短くする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplify()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;パスの意味を変えずに簡略化する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executable()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;実行形式ファイルかどうかをチェックする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filereadable()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイルが読み込み可能かどうかをチェックする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filewritable()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイルが書き込み可能かどうかをチェックする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getfperm()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイルのパーミッションを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getftype()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイルの種類を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isdirectory()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ディレクトリの存在をチェックする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getfsize()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイルのサイズを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getcwd()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カレントディレクトリを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempname()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一時ファイルの名前を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mkdir()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ディレクトリを作成する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイルを削除する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rename()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイルの名前を変更する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;シェルコマンドを実行し、その結果を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hostname()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;システムの名称を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readfile()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイルを読み込み、行のリストを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writefile()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 行のリストをファイルに書き込む<br>
<br>
日付と時刻:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#date-functions" name="date-functions">*date-functions*</a>&nbsp;<a class="Constant" href="usr_41.html#time-functions" name="time-functions">*time-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getftime()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイルの最終更新日時を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localtime()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 現在時刻を秒単位で得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strftime()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;時刻を文字列に変換する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reltime()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 現在時刻または経過時間を正確に取得する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reltimestr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reltime()の結果を文字列に変換する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#buffer-functions" name="buffer-functions">*buffer-functions*</a>&nbsp;<a class="Constant" href="usr_41.html#window-functions" name="window-functions">*window-functions*</a>&nbsp;<a class="Constant" href="usr_41.html#arg-functions" name="arg-functions">*arg-functions*</a><br>
バッファ、ウィンドウ、引数リスト:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argc()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引数リストの大きさ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argidx()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引数リスト中の現在の位置<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argv()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引数リストの中身を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufexists()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; バッファの存在をチェックする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buflisted()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; バッファが存在し、リストされているかどうか<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufloaded()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; バッファが存在し、ロードされているかどうか<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufname()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; バッファの名前を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufnr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; バッファの番号を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tabpagebuflist()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;タブページ中のバッファのリストを返す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tabpagenr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; タブページの番号を取得する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tabpagewinnr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;タブページを対象にwinnr()と同様<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;winnr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; カレントウィンドウの番号を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufwinnr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;バッファのウィンドウ番号を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;winbufnr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ウィンドウのバッファ番号を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getbufline()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;バッファの行のリストを得る<br>
<br>
コマンドライン:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#command-line-functions" name="command-line-functions">*command-line-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getcmdline()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;現在のコマンドラインを取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getcmdpos()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; コマンドラインにおけるカーソル位置を取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setcmdpos()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; コマンドラインにおけるカーソル位置を設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getcmdtype()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;現在のコマンドラインの種類を返す<br>
<br>
Quickfixとロケーションリスト:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#quickfix-functions" name="quickfix-functions">*quickfix-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getqflist()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; quickfixエラーのリスト<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setqflist()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; quickfixを変更する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getloclist()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ロケーションリストの項目のリスト<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setloclist()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ロケーションリストを変更する<br>
<br>
インサートモード補完:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#completion-functions" name="completion-functions">*completion-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;補完候補を設定する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete_add()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;補完候補を追加する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;complete_check()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;補完処理を終えるべきかどうかをチェックする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pumvisible()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ポップアップメニューが表示されているかチェック<br>
<br>
折り畳み:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#folding-functions" name="folding-functions">*folding-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foldclosed()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行が折り畳まれているかどうかをチェックする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foldclosedend()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foldclosed()と同様。折り畳み末尾の行番号を返す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foldlevel()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 行の折り畳みレベルを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foldtext()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;閉じた折り畳みを代替表示するテキストを生成<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foldtextresult()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;閉じた折り畳みを代替表示するテキストを得る<br>
<br>
シンタックスハイライト:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#syntax-functions" name="syntax-functions">*syntax-functions*</a>&nbsp;<a class="Constant" href="usr_41.html#highlighting-functions" name="highlighting-functions">*highlighting-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearmatches()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="eval.html#matchadd()">|matchadd()|</a>と<a class="Identifier" href="pattern.html#:match">|:match|</a>コマンドで定義されたマッ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チをクリアする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getmatches()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="eval.html#matchadd()">|matchadd()|</a>と<a class="Identifier" href="pattern.html#:match">|:match|</a>コマンドで定義されたすべ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;てのマッチを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hlexists()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ハイライトグループの存在をチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hlID()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ハイライトグループのIDを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synID()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 指定位置のシンタックスIDを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synIDattr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; シンタックスIDから指定の属性を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synIDtrans()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;変換したシンタックスIDを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synstack()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定位置のシンタックスIDのリストを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synconcealed()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conceal の情報を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diff_hlID()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; diffモードの指定位置のシンタックスIDを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchadd()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;強調表示するパターンを定義する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matcharg()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="pattern.html#:match">|:match|</a>の引数の情報を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchdelete()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="eval.html#matchadd()">|matchadd()|</a>と<a class="Identifier" href="pattern.html#:match">|:match|</a>コマンドで定義されたマッ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チを削除する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setmatches()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="eval.html#getmatches()">|getmatches()|</a>で得たマッチを使って復元する<br>
<br>
スペリング:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#spell-functions" name="spell-functions">*spell-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spellbadword()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;カーソル位置以降のスペルミスを探す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spellsuggest()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;スペル訂正の候補を返す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soundfold()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 単語の同音等値(sound-a-like equivalent)を返す<br>
<br>
履歴:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#history-functions" name="history-functions">*history-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;histadd()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 履歴に項目を追加<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;histdel()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 履歴から項目を削除<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;histget()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 履歴の項目を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;histnr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;履歴リストの最大インデックスを得る<br>
<br>
対話インターフェース:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#interactive-functions" name="interactive-functions">*interactive-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;browse()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイル選択ダイアログを開く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;browsedir()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ディレクトリ選択ダイアログを開く<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;confirm()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ユーザーに選択をさせる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getchar()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ユーザーが入力した文字を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getcharmod()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最後に入力した文字の修飾子(modifier)を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;feedkeys()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先行入力キューに文字を入れる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ユーザーが入力した行を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputlist()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ユーザーにリストから項目を選択させる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputsecret()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ユーザーが入力した行を得る。ただし表示はしない<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputdialog()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ダイアログを使ってユーザーが入力した行を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputsave()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 先行入力キューを保存して空にする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputrestore()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputsave()で保存した状態に戻す<br>
<br>
GUI:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#gui-functions" name="gui-functions">*gui-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getfontname()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 現在使われているフォントの名前を取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getwinposx()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GUIのVimウィンドウのX座標<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getwinposy()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GUIのVimウィンドウのY座標<br>
<br>
Vimサーバ:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#server-functions" name="server-functions">*server-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverlist()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;サーバ名のリストを返す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remote_send()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vimサーバにコマンド文字を送る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remote_expr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vimサーバで式を評価する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server2client()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vimサーバのクライアントに応答を返す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remote_peek()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vimサーバから返信があったかどうかをチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remote_read()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vimサーバからの返信を読む<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreground()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vimのウィンドウを前面に持ってくる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remote_foreground()&nbsp;&nbsp;&nbsp;&nbsp; Vimサーバのウィンドウを前面に持ってくる<br>
<br>
ウィンドウサイズと位置:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#window-size-functions" name="window-size-functions">*window-size-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;winheight()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ウィンドウの高さを取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;winwidth()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ウィンドウの幅を取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;winrestcmd()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ウィンドウサイズを復元するコマンドを返す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;winsaveview()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; カレントウィンドウのビューを取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;winrestview()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; カレントウィンドウのビューを復元<br>
<br>
その他:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#various-functions" name="various-functions">*various-functions*</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;現在の編集モードを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visualmode()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最後に使われたビジュアルモードの種類<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasmapto()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マップの存在をチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapcheck()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マッチするマップの存在をチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maparg()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マップのrhs(展開結果)を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;変数、関数の存在をチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 機能がサポートされているかをチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;changenr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近の変更番号を返す<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cscope_connection()&nbsp;&nbsp;&nbsp;&nbsp; cscope接続をチェック<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;did_filetype()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileTypeオートコマンドが使用されたかどうか<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eventhandler()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;イベントハンドラによって起動されたかどうか<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getpid()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vim のプロセスIDを得る<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;libcall()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 外部ライブラリの関数を呼ぶ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;libcallnr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同上、数値を返す<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getreg()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;レジスタの値を得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getregtype()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;レジスタのタイプを得る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setreg()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;レジスタの値を設定する<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;taglist()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; マッチするタグのリストを取得<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tagfiles()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;タグファイルのリストを取得<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mzeval()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="if_mzsch.html#MzScheme">|MzScheme|</a>&nbsp;の式を評価する<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.7" name="41.7">*41.7*</a>&nbsp;&nbsp;関数を定義する<br>
<br>
自分で関数を定義することができます。基本的な関数定義は次のとおり:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function {name}({var1}, {var2}, ...)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;{body}</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunction</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;関数名は大文字で開始する必要があります。<br>
<br>
小さな関数を定義してみましょう。二つの数値のうち小さい方を返す関数を作ります。<br>
関数は次のような行で始まります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function Min(num1, num2)</span><br>
<br>
関数の名前が &quot;Min&quot; であり、二つの引数 (&quot;num1&quot;と&quot;num2&quot;) を取る、ということを表<br>
しています。<br>
最初にしなければならないのは、どちらの数値が小さいかをチェックすることです:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;if a:num1 &lt; a:num2</span><br>
<br>
&quot;a:&quot; は特殊なプレフィクスで、この変数が関数の引数であることを示します。小さい<br>
方の値を変数 &quot;smaller&quot; に代入しましょう:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;if a:num1 &lt; a:num2</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;let smaller = a:num1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;else</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;let smaller = a:num2</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;endif</span><br>
<br>
変数 &quot;smaller&quot; はローカル変数です。関数の中で使われた変数はローカル変数になり<br>
ます。ただし、&quot;g:&quot;、&quot;a:&quot;、&quot;s:&quot; などのプレフィクスを付けた場合は別です。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;関数の内からグローバル変数にアクセスするには &quot;g:&quot; を付ける必要がありま<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;す。つまり、関数内では &quot;g:today&quot; はグローバル変数 &quot;today&quot; を示し、<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;today&quot; ならそれとは別の変数、すなわちローカル変数になります。<br>
<br>
&quot;:return&quot; ステートメントを使って、小さい方の値を呼び出し元に返しましょう。そし<br>
て、関数を閉じます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;return smaller</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunction</span><br>
<br>
関数定義の全体は次のようになります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function Min(num1, num2)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;if a:num1 &lt; a:num2</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;let smaller = a:num1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;else</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;let smaller = a:num2</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;return smaller</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunction</span><br>
<br>
関数を短く書きたい場合は、次のようにもできます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function Min(num1, num2)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;if a:num1 &lt; a:num2</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;return a:num1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;return a:num2</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunction</span><br>
<br>
ユーザー定義関数は組み込み関数とまったく同じ方法で呼び出すことができます。違う<br>
のは名前だけです。Min 関数は次のように使用できます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo Min(5, 8)</span><br>
<br>
関数が実行され、関数の中身が Vim によって解釈されます。未定義の変数や関数を使<br>
うなどの間違いがあったときは、エラーメッセージが表示されます。関数定義の時点で<br>
はそれらのエラーは検出されません。<br>
<br>
関数が &quot;:endfunction&quot; まで実行されたとき、あるいは引数無しで &quot;:return&quot; を使っ<br>
たときは 0 が返ります。<br>
<br>
既存の関数を再定義したい場合は &quot;:function&quot; コマンドに &quot;!&quot; を付けてください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function!&nbsp;&nbsp;Min(num1, num2, num3)</span><br>
<br>
<br>
範囲指定を使う<br>
<span class="PreProc">--------------</span><br>
<br>
&quot;:call&quot; コマンドは行範囲を受け取ることができます。範囲指定の使用方法は二つあり<br>
ます。関数を定義するときに &quot;range&quot; キーワードを使った場合は、関数自身が範囲指<br>
定を処理します。<br>
関数には &quot;a:firstline&quot; と &quot;a:lastline&quot; という二つの変数が暗黙的に渡されます。<br>
この二つの変数には範囲指定された行番号が代入されています。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function Count_words() range</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let lnum = a:firstline</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let n = 0</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;while lnum &lt;= a:lastline</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;let n = n + len(split(getline(lnum)))</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;let lnum = lnum + 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;endwhile</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo &quot;found &quot; . n . &quot; words&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunction</span><br>
<br>
この関数は次のように呼び出すことができます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:10,30call Count_words()</span><br>
<br>
関数が一度だけ実行され、単語の数が表示されます。<br>
関数を定義するときに &quot;range&quot; キーワードを使わなかった場合は、指定された範囲の<br>
それぞれの行に対して関数が呼ばれます (カーソルはその行の上)。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function&nbsp;&nbsp;Number()</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo &quot;line &quot; . line(&quot;.&quot;) . &quot; contains: &quot; . getline(&quot;.&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunction</span><br>
<br>
次のように実行すると:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:10,15call Number()</span><br>
<br>
関数は 6 回実行されます。<br>
<br>
<br>
可変長引数<br>
<span class="PreProc">----------</span><br>
<br>
可変個の引数を取る関数を定義できます。例えば、次の関数は、必ず 1 つの引数<br>
(start) を取り、最大で 20 個までの引数を取ることができます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function Show(start, ...)</span><br>
<br>
変数 &quot;a:1&quot; に 1 つ目のオプション引数が代入されます。2 つ目が &quot;a:2&quot; で、3 つ目<br>
が &quot;a:3&quot; です。&quot;a:0&quot; にはオプション引数の数が入ります。<br>
例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function Show(start, ...)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echohl Title</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo &quot;start is &quot; . a:start</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echohl None</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let index = 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;while index &lt;= a:0</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;echon &quot;&nbsp;&nbsp;Arg &quot; . index . &quot; is &quot; . a:{index}</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;let index = index + 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;endwhile</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo &quot;&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunction</span><br>
<br>
この関数は &quot;:echohl&quot; を使って &quot;:echo&quot; の出力に色を付けています。&quot;:echohl None&quot;<br>
で色付けをやめます。&quot;:echon&quot; コマンドは &quot;:echo&quot; と同じ機能ですが、改行を出力し<br>
ません。<br>
<br>
変数 a:000 を使うこともできます。これは &quot;...&quot; 引数がすべて入ったリストです。<br>
<a class="Identifier" href="eval.html#a:000">|a:000|</a>を参照。<br>
<br>
<br>
関数の一覧<br>
<span class="PreProc">----------</span><br>
<br>
&quot;:function&quot; コマンドでユーザー定義関数の一覧を表示できます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">function Show(start, ...)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">function GetVimIndent()</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">function SetSyn(name)</span><br>
<br>
関数の中身を見たいときは関数名を指定してください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function SetSyn</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">1&nbsp;&nbsp;&nbsp;&nbsp; if &amp;syntax == ''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let &amp;syntax = a:name</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">3&nbsp;&nbsp;&nbsp;&nbsp; endif</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">endfunction</span><br>
<br>
<br>
デバッグ<br>
<span class="PreProc">--------</span><br>
<br>
エラーメッセージが表示されたとき、あるいはデバッグ中に、行番号が表示されると便<br>
利です。デバッグモードについては&nbsp;<a class="Identifier" href="repeat.html#debug-scripts">|debug-scripts|</a>&nbsp;を参照してください。<br>
<a class="Type" href="options.html#'verbose'">'verbose'</a>&nbsp;オプションに 12 以上の値を設定すると、すべての関数呼び出しが表示され<br>
ます。15 以上にすると、実行されたすべての行が表示されます。<br>
<br>
<br>
関数の削除<br>
<span class="PreProc">----------</span><br>
<br>
例えば Show() 関数を削除するのは次のようにします:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:delfunction Show</span><br>
<br>
関数が存在しない場合はエラーになります。<br>
<br>
<br>
関数への参照<br>
<span class="PreProc">------------</span><br>
<br>
変数に関数を代入できると便利なことがあります。それには function() 関数を使いま<br>
す。function() は関数の名前を受け取り、関数への参照を返します:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let result = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; or 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function! Right()</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;return 'Right!'</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunc</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function! Wrong()</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;return 'Wrong!'</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunc</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if result == 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let Afunc = function('Right')</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:else</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let Afunc = function('Wrong')</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo call(Afunc, [])</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">Wrong!</span><br>
<br>
<span class="Todo">Note</span>&nbsp;関数への参照を保持する変数の名前は大文字で始めなければなりません。そうで<br>
ないと組み込み関数の名前と紛らわしくなります。<br>
変数が参照している関数を呼び出すには call() 関数を使います。call() 関数の最初<br>
の引数は関数への参照で、2 番目の引数は引数のリストです。<br>
<br>
関数への参照は、次節で説明される辞書と組み合わせたときもっとも役に立ちます。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.8" name="41.8">*41.8*</a>&nbsp;&nbsp;リストと辞書<br>
<br>
ここまでは基本型(文字列と数値)を扱ってきました。Vim は二つの複合型、リストと辞<br>
書もサポートしています。<br>
<br>
リストとは、要素を順番に並べたものです。要素はどのような型でも構いません。数値<br>
のリスト、リストのリスト、あるいは複数の型が混在したリストでも作れます。例え<br>
ば、3 個の文字列からなるリストを作るには次のようにします:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let alist = ['aap', 'mies', 'noot']</span><br>
<br>
リストの要素は角括弧で囲み、コンマで区切ります。空のリストを作るには次のように<br>
します:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let alist = []</span><br>
<br>
関数add()を使うとリストに要素を追加することができます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let alist = []</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:call add(alist, 'foo')</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:call add(alist, 'bar')</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo alist</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">['foo', 'bar']</span><br>
<br>
リストの連結には + を使います:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo alist + ['foo', 'bar']</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">['foo', 'bar', 'foo', 'bar']</span><br>
<br>
直接リストを拡張するには次のようにします:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let alist = ['one']</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:call extend(alist, ['two', 'three'])</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo alist</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">['one', 'two', 'three']</span><br>
<br>
add()とは効果が異なることに注意してください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let alist = ['one']</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:call add(alist, ['two', 'three'])</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo alist</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">['one', ['two', 'three']]</span><br>
<br>
add()の第二引数は1つの要素として追加されます。<br>
<br>
<br>
FOR ループ<br>
<span class="PreProc">----------</span><br>
<br>
リストを使ってできる素晴らしいことの1つが、リストに対する繰り返しです:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let alist = ['one', 'two', 'three']</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:for n in alist</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo n</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfor</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">one</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">two</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">three</span><br>
<br>
上の例は、リスト&quot;alist&quot;の各要素に対して、その値を変数&quot;n&quot;に代入しながらループを<br>
行います。forループの書式は次の通りです:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:for {varname} in {listexpression}</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;{commands}</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfor</span><br>
<br>
ある回数だけループするには、その長さのリストを使います。関数range()を使うと、<br>
そのようなリストを作成できます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:for a in range(3)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo a</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfor</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">0</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">1</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">2</span><br>
<br>
range()が生成するリストの最初の要素は0であることに注意してください。そのため、<br>
最後の要素はリストの長さより1小さい値になります。<br>
最大値、ステップ幅を指定することもでき、逆方向に進むこともできます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:for a in range(8, 4, -2)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo a</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfor</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">8</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">6</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">4</span><br>
<br>
より有用な例として、バッファ中の行に対するループ:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:for line in getline(1, 20)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;if line =~ &quot;Date: &quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;echo matchstr(line, 'Date: \zs.*')</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfor</span><br>
<br>
1行目から20行目(両端を含む)を調べ、そこに含まれる日付を全て表示しています。<br>
<br>
<br>
辞書<br>
<span class="PreProc">-----</span><br>
<br>
辞書はキーと値のペアを保持します。キーを指定することで高速に値を検索できます。<br>
辞書は波括弧で作ります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}</span><br>
<br>
そして角括弧の中にキーを書くことで単語を検索します:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo uk2nl['two']</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">twee</span><br>
<br>
辞書の定義の書式は次の通りです:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&lt;key&gt; : &lt;value&gt;, ...}</span><br>
<br>
空の辞書とは、どんなキーも持たない辞書のことです:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{}</span><br>
<br>
辞書にはいろいろな使い道があります。辞書を扱う関数もたくさんあります。例えば、<br>
キーのリストを取得してそれに対してループするには次のようにします:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:for key in keys(uk2nl)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo key</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfor</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">three</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">one</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">two</span><br>
<br>
キーはソートされていません。特定の順序に並べるにはリストをソートします:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:for key in sort(keys(uk2nl))</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;echo key</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfor</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">one</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">three</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">two</span><br>
<br>
要素が定義された順序を得ることはできません。そのような目的にはリストを使ってく<br>
ださい。リストは順序を保って要素を保持します。<br>
<br>
<br>
辞書の関数<br>
<span class="PreProc">----------</span><br>
<br>
辞書の要素は角括弧でインデックスを指定して取得します:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo uk2nl['one']</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">een</span><br>
<br>
記号を使わない方法もあります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo uk2nl.one</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">een</span><br>
<br>
この方法はキーがアルファベット、数字、アンダースコアなどの ASCII 文字だけで構<br>
成されている場合に使えます。この方法で値を代入することもできます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let uk2nl.four = 'vier'</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo uk2nl</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'}</span><br>
<br>
関数の定義と辞書への代入を同時に記述することができます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function uk2nl.translate(line) dict</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;return join(map(split(a:line), 'get(self, v:val, &quot;???&quot;)'))</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunction</span><br>
<br>
これを実行してみましょう:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo uk2nl.translate('three two five one')</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">drie twee ??? een</span><br>
<br>
&quot;:function&quot; の行の末尾に &quot;dict&quot; と書かれています。これは、その関数が辞書から使<br>
われることを示します。ローカル変数 &quot;self&quot; がその辞書を指すようになります。<br>
次に、複雑なreturnコマンドを分解してみましょう:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split(a:line)</span><br>
<br>
関数split()は文字列を空白文字で区切り、リストにして返します。そのため、この例<br>
での戻り値は次のようになります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo split('three two five one')</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">['three', 'two', 'five', 'one']</span><br>
<br>
このリストがmap()関数の第一引数になります。map()はリストの各要素を &quot;v:val&quot; に<br>
代入した状態で第二引数を評価します。これによりforループより短いコードが書けま<br>
す。このコードは:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let alist = map(split(a:line), 'get(self, v:val, &quot;???&quot;)')</span><br>
<br>
次のコードと同じです:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let alist = split(a:line)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:for idx in range(len(alist))</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let alist[idx] = get(self, alist[idx], &quot;???&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfor</span><br>
<br>
関数get()はそのキーが辞書に入っているかをチェックします。入っていればその値を<br>
返します。入っていなければデフォルト値(この例では'???')を返します。キーが入っ<br>
ていなくてもエラーを起こしたくないような場合に便利です。<br>
<br>
関数join()はsplit()の逆の処理をします。つまり単語のリストをスペースでつなげま<br>
す。<br>
split()、map()、join() を組み合わせると、単語からなる行を簡潔に処理することが<br>
できます。<br>
<br>
<br>
オブジェクト指向プログラミング<br>
<span class="PreProc">------------------------------</span><br>
<br>
辞書には値と関数を入れることができるので、辞書をオブジェクトとして使うことがで<br>
きます。<br>
上述の例ではオランダ語から英語に翻訳するために辞書を使いました。同じことが他の<br>
言語でもできると面白いかもしれませんね。まず翻訳関数を持ったオブジェクト (つま<br>
り辞書) を作ります。翻訳する単語はまだ定義しません:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let transdict = {}</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function transdict.translate(line) dict</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;return join(map(split(a:line), 'get(self.words, v:val, &quot;???&quot;)'))</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunction</span><br>
<br>
単語を翻訳するのに 'self.words' を使う点が上述の例と少し違います。しかし、<br>
self.words はまだありません。よって、これは抽象クラスと呼ぶことができます。<br>
<br>
オランダ語を翻訳するオブジェクトをインスタンス化してみましょう:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let uk2nl = copy(transdict)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo uk2nl.translate('three one')</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">drie een</span><br>
<br>
さらにドイツ語の翻訳機を作ります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let uk2de = copy(transdict)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo uk2de.translate('three one')</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">drei ein</span><br>
<br>
copy() 関数を使って &quot;transdict&quot; 辞書をコピーし、そのコピーに対して単語を追加し<br>
ています。元の辞書はもちろん変更されません。<br>
<br>
さらに一歩進んで、適切な言語を選択できるようにしてみます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if $LANG =~ &quot;de&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let trans = uk2de</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:else</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let trans = uk2nl</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo trans.translate('one two three')</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">een twee drie</span><br>
<br>
&quot;trans&quot;は2つのオブジェクト(辞書)のうちどちらか1つを参照します。コピーは作られ<br>
ていません。リストと辞書の同一性についてのより詳しい情報は<a class="Identifier" href="eval.html#list-identity">|list-identity|</a>と<br>
<a class="Identifier" href="eval.html#dict-identity">|dict-identity|</a>にあります。<br>
<br>
未対応の言語を使う場合は、translate() 関数を上書きして何もしないようにするとい<br>
いかもしれません:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let uk2uk = copy(transdict)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:function! uk2uk.translate(line)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;return a:line</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endfunction</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo uk2uk.translate('three one wladiwostok')</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">three one wladiwostok</span><br>
<br>
! を使って既に存在している関数への参照を上書きしています。続いて、未対応の言語<br>
に対して &quot;uk2uk&quot; を使うように変更します:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if $LANG =~ &quot;de&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let trans = uk2de</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:elseif $LANG =~ &quot;nl&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let trans = uk2nl</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:else</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;let trans = uk2uk</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:echo trans.translate('one two three')</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">one two three</span><br>
<br>
さらなる情報については<a class="Identifier" href="eval.html#List">|List|</a>と<a class="Identifier" href="eval.html#Dictionaries">|Dictionaries|</a>を参照してください。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.9" name="41.9">*41.9*</a>&nbsp;&nbsp;例外<br>
<br>
まずは例題を見てください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:try</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; read ~/templates/pascal.tmpl</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:catch /E484:/</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; echo &quot;パスカル用のテンプレートファイルは見つかりませんでした。&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endtry</span><br>
<br>
&quot;:read&quot; コマンドはファイルがなければ失敗します。そのエラーをキャッチして、エ<br>
ラーメッセージの代わりにより親切なメッセージを表示しています。<br>
<br>
&quot;:try&quot; と &quot;:endtry&quot; の間で起きたエラーは例外に変わります。例外は文字列です。エ<br>
ラーが例外に変わったとき、文字列にはエラーメッセージが含まれます。また、全ての<br>
エラーメッセージは番号を持っています。例題では &quot;E484:&quot; を含んだエラーをキャッ<br>
チしています。この番号は変わらないことが保証されています (テキストは翻訳される<br>
などして変わるかもしれません)。<br>
<br>
&quot;:read&quot; コマンドが他のエラーを起こした場合、&quot;E484:&quot; というパターンはマッチしな<br>
いでしょう。したがって、その例外はキャッチされず、通常のエラーメッセージが表示<br>
されます。<br>
<br>
次のように書くこともできます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:try</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; read ~/templates/pascal.tmpl</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:catch</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; echo &quot;パスカル用のテンプレートファイルは見つかりませんでした。&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endtry</span><br>
<br>
全ての例外がキャッチされます。しかしこれでは &quot;E21: Cannot make changes,<br>
<a class="Type" href="options.html#'modifiable'">'modifiable'</a>&nbsp;is off&quot; のような有効なエラーに気づくことができません。<br>
<br>
&quot;:finally&quot; という便利なコマンドもあります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let tmp = tempname()</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:try</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; exe &quot;.,$write &quot; . tmp</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; exe &quot;!filter &quot; . tmp</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; .,$delete</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; exe &quot;$read &quot; . tmp</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:finally</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp; call delete(tmp)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endtry</span><br>
<br>
カーソル行からファイル末尾までを &quot;filter&quot; コマンド (ファイル名を引数に取るコマ<br>
ンド) でフィルタ処理しています。&quot;:try&quot; と &quot;:finally&quot; の間で問題が起きても、<br>
ユーザーが&nbsp;<span class="Special">CTRL-C</span>&nbsp;を押して操作をキャンセルしても、&quot;call delete(tmp)&quot; は必ず呼<br>
ばれます。一時ファイルが残ってしまう心配はありません。<br>
<br>
例外についてさらに詳しい情報はリファレンスマニュアルの<a class="Identifier" href="eval.html#exception-handling">|exception-handling|</a>を<br>
参照してください。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.10" name="41.10">*41.10*</a>&nbsp;注意事項<br>
<br>
Vim スクリプトにおいて注意すべきことの概要を簡単に説明します。他の場所にも同じ<br>
ような説明はありますが、手頃なチェックリストに使えるでしょう。<br>
<br>
改行記号はシステムによって異なります。Unix では&nbsp;<span class="Special">&lt;NL&gt;</span>&nbsp;文字が使われますが、<br>
MS-DOS 、Windows、OS/2 などでは&nbsp;<span class="Special">&lt;CR&gt;&lt;LF&gt;</span>&nbsp;が使われます。末尾が&nbsp;<span class="Special">&lt;CR&gt;</span>&nbsp;になってい<br>
るマップを使うときは注意してください。<a class="Identifier" href="repeat.html#:source_crnl">|:source_crnl|</a>&nbsp;参照。<br>
<br>
<br>
空白<br>
<span class="PreProc">-----</span><br>
<br>
空の行はあっても構いません。無視されます。<br>
<br>
行頭の空白 (スペースとTAB) は常に無視されます。引数と引数の間には空白がいくつ<br>
あっても構いません (例えば下記の&nbsp;<span class="MissingTag">'set'</span>&nbsp;と&nbsp;<a class="Type" href="options.html#'cpoptions'">'cpoptions'</a>&nbsp;の間) 。空白は一つのス<br>
ペースにまとめられ、セパレータの役目をします。最後の文字より後ろにある空白文字<br>
は状況によって無視されたりされなかったりします。下記参照。<br>
<br>
&quot;:set&quot; コマンドで &quot;=&quot; 記号を使うとき:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set cpoptions&nbsp;&nbsp;&nbsp;&nbsp;=aABceFst</span><br>
<br>
&quot;=&quot; の直前にある空白は無視されます。しかし、&quot;=&quot; の後ろに空白をはさむことはでき<br>
ません。<br>
<br>
オプション値に空白を含めるときは、バックスラッシュ (&quot;\&quot;) でエスケープする必要<br>
があります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set tags=my\ nice\ file</span><br>
<br>
次のように書くと:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set tags=my nice file</span><br>
<br>
これはエラーになります。このコマンドは次のように解釈されてしまいます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set tags=my</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set nice</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set file</span><br>
<br>
<br>
コメント<br>
<span class="PreProc">--------</span><br>
<br>
コメントは &quot; (ダブルクオート) 記号で開始します。行末までのすべての文字がコメン<br>
トとして解釈され、無視されます。ただし、コメントを書くことができないコマンドも<br>
あります (以下に例を示します)。コメントは行のどこからでも開始できます。<br>
<br>
コメントとして簡単な注釈を付けたとします。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:abbrev dev development&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; shorthand</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:map &lt;F3&gt; o#include&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; insert include</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:execute cmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; do it</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:!ls *.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; list C files</span><br>
<br>
短縮形&nbsp;<span class="MissingTag">'dev'</span>&nbsp;は 'development&nbsp;&nbsp;&nbsp;&nbsp; &quot; shorthand' に展開されます。<span class="Special">&lt;F3&gt;</span>&nbsp;には 'o#<br>
....' から '&quot; insert include' までの全部がマップされます。&quot;execute&quot; コマンドは<br>
エラーを起こします。&quot;!&quot; コマンドはすべての文字をシェルに渡すので、&quot; 記号が閉じ<br>
られていないことでエラーが起こります。<br>
&quot;:map&quot;、&quot;:abbreviate&quot;、&quot;:execute&quot;、&quot;!&quot; などのコマンドはその後ろにコメントを書<br>
くことができません (そのようなコマンドは他にもあります)。ただし、無理やりコメ<br>
ントを書く方法もあります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:abbrev dev development|&quot; shorthand</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:map &lt;F3&gt; o#include|&quot; insert include</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:execute cmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&quot; do it</span><br>
<br>
'|' 文字でコマンドを区切り、次のコマンドを書くことができます。この例では二つ目<br>
のコマンドはコメントのみです。&quot;!&quot; の場合は&nbsp;<a class="Identifier" href="eval.html#:execute">|:execute|</a>&nbsp;と '|' を使わなければな<br>
りません:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:exe '!ls *.c'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&quot; list C files</span><br>
<br>
&quot;:map&quot; と &quot;:abbreviate&quot; の場合は '|' の前に空白を置かないように注意してくださ<br>
い。これらのコマンドは行末か '|' までのすべての文字を使います。そのため、意図<br>
せずに末尾に空白を入れてしまうかもしれません:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:map &lt;F4&gt; o#include&nbsp;&nbsp;</span><br>
<br>
vimrc を編集するときに&nbsp;<a class="Type" href="options.html#'list'">'list'</a>&nbsp;オプションをオンに設定しておくと、この問題が発見<br>
しやすくなります。<br>
<br>
Unix では特別なコメント書式を使って Vim スクリプトを実行形式にすることができま<br>
す:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#!/usr/bin/env vim -S</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo &quot;this is a Vim script&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quit</span><br>
<br>
&quot;#&quot; コマンドは行を行番号付きで表示しますが、'!' をつけると何もしなくなります。<br>
よってファイルを実行するためのシェルコマンドを記述することができます。<br>
<a class="Identifier" href="various.html#:#!">|:#!|</a>&nbsp;<a class="Identifier" href="starting.html#-S">|-S|</a><br>
<br>
<br>
落とし穴<br>
<span class="PreProc">--------</span><br>
<br>
次の例には大きな問題があります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:map ,ab o#include</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unmap ,ab&nbsp;</span><br>
<br>
この unmap コマンドはうまく動きません。なぜなら &quot;,ab &quot; を unmap しようとしてい<br>
るからです。そのようなマップは存在しません。エラーが表示されますが、スペースは<br>
目に見えないので、エラーの原因を見つけるのは困難です。<br>
<br>
&quot;:unmap&quot; コマンドの後にコメントを書いた場合も同様です:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unmap ,ab&nbsp;&nbsp;&nbsp;&nbsp; &quot; comment</span><br>
<br>
コメントは無視されますが、Vim は ',ab&nbsp;&nbsp;&nbsp;&nbsp; ' を unmap しようとします。次のよう<br>
に書いてください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:unmap ,ab|&nbsp;&nbsp;&nbsp;&nbsp;&quot; comment</span><br>
<br>
<br>
ビューの復元<br>
<span class="PreProc">------------</span><br>
<br>
何らかの変更を加えてから、カーソルのあった場所に戻りたい時があります。そのとき<br>
に、画面に表示されていた行範囲も復元されるとすてきです。<br>
次の例は、現在行をヤンクしてファイルの先頭にプットし、ビューを復元します:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map ,p ma&quot;aYHmbgg&quot;aP`bzt`a</span><br>
<br>
これは次のことをしています:<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ma&quot;aYHmbgg&quot;aP`bzt`a</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;現在のカーソル位置にマーク a を設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;aY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 現在行をレジスタ a にヤンク<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hmb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ウィンドウの一行目に移動してマーク b を設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ファイルの一行目に移動<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;aP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ヤンクした行をその上にプット<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ウィンドウの一行目に戻る<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ウィンドウの表示範囲を以前と同じにする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `a&nbsp;&nbsp;&nbsp;&nbsp; 保存しておいたカーソル位置に移動<br>
<br>
<br>
パッケージング<br>
<span class="PreProc">--------------</span><br>
<br>
関数の名前が他の人の関数とかぶらないように、次の方法を使ってください:<br>
- ユニークな文字列を名前の前に付ける。私はよく略語を使います。例えば、オプショ<br>
&nbsp;&nbsp;ンウィンドウ (option window) のための関数なら &quot;OW_&quot; などです。<br>
- 関数を一つのファイルにまとめて、関数がロードされているかどうかを示すグローバ<br>
&nbsp;&nbsp;ル変数を設定する。ファイルが二回目に読み込まれたとき、最初にそれらの関数をア<br>
&nbsp;&nbsp;ンロードする。<br>
例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; This is the XXX package</span><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if exists(&quot;XXX_loaded&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delfun XXX_one</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delfun XXX_two</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</span><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function XXX_one(a)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... body of function ...</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfun</span><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function XXX_two(b)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... body of function ...</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfun</span><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let XXX_loaded = 1</span><br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.11" name="41.11">*41.11*</a>&nbsp;プラグインを書く&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#write-plugin" name="write-plugin">*write-plugin*</a><br>
<br>
Vim スクリプトを書いて、それを多くの人に使ってもらうことができます。そのような<br>
スクリプトはプラグインと呼ばれます。Vim ユーザーはあなたのスクリプトをプラグイ<br>
ンディレクトリにコピーするだけで、すぐにその機能を使うことができます。<br>
<a class="Identifier" href="usr_05.html#add-plugin">|add-plugin|</a>&nbsp;参照。<br>
<br>
プラグインには二種類あります:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;グローバルプラグイン : すべてのファイルで共通<br>
&nbsp;&nbsp;ファイルタイププラグイン : ファイルの種類別<br>
<br>
この節ではグローバルプラグインについて説明します。ほとんどの説明はファイルタイ<br>
ププラグインに対してもあてはまります。ファイルタイププラグイン特有の説明は次節<br>
にあります&nbsp;<a class="Identifier" href="usr_41.html#write-filetype-plugin">|write-filetype-plugin|</a>。<br>
<br>
<br>
名前<br>
<span class="PreProc">-----</span><br>
<br>
最初にプラグインの名前を決めなければなりません。プラグインが提供する機能が名前<br>
から分かるようにしてください。また、他の人が作ったプラグインと名前がかぶらない<br>
ようにしてください。古い Windows システムでの問題を避けるため、名前は 8 文字以<br>
内にしてください。<br>
<br>
例えばタイプミス (type mistake) を修正 (correct) するためのスクリプトなら<br>
&quot;typecorr.vim&quot; という名前を付けたりします。ここではこれを例題として使います。<br>
<br>
プラグインが誰でも使えるようにするため、いくつかのガイドラインに従ってくださ<br>
い。ガイドラインは段階的に説明していきます。例題プラグインの完全なソースは最後<br>
に示します。<br>
<br>
<br>
ボディ<br>
<span class="PreProc">------</span><br>
<br>
まずはプラグインの本体部分を見てみましょう。行番号は実際の番号です:<br>
<br>
<span class="Comment">&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp; iabbrev teh the</span><br>
<span class="Comment">&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp; iabbrev otehr other</span><br>
<span class="Comment">&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp; iabbrev wnat want</span><br>
<span class="Comment">&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp; iabbrev synchronisation</span><br>
<span class="Comment">&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ synchronization</span><br>
<span class="Comment">&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp; let s:count = 4</span><br>
<br>
もちろん、実際のスクリプトはもっと巨大です。<br>
<br>
行番号は説明のために追加したものです。プラグインを書くときは行番号を付けないで<br>
ください。<br>
<br>
<br>
へッダ<br>
<span class="PreProc">------</span><br>
<br>
新しい単語を追加していくと、プラグインには複数のバージョンが存在することになり<br>
ます。ファイルを配布したとき、それを使った人は、誰がこの素晴らしいプラグインを<br>
書いたのかを知りたいと思うでしょうし、感想を伝えたいと思うかもしれません。<br>
というわけで、次のようなヘッダをプラグインに書いてください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; &quot; Vim global plugin for correcting typing mistakes</span><br>
<span class="Comment">&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp; &quot; Last Change:&nbsp;&nbsp;2000 Oct 15</span><br>
<span class="Comment">&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; &quot; Maintainer:&nbsp;&nbsp; Bram Moolenaar &lt;Bram@vim.org&gt;</span><br>
<br>
著作権とライセンスについて: プラグインがとても便利で、そして再配布を制限するほ<br>
どのものでない場合は、パブリックドメインか Vim ライセンス (<a class="Identifier" href="uganda.html#license">|license|</a>) の適用を<br>
検討してみてください。次の短い宣言をプラグインの先頭付近に書いておくだけで十分<br>
です:<br>
<br>
<span class="Comment">&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; &quot; License:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This file is placed in the public domain.</span><br>
<br>
<br>
行連結、副作用の回避&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#use-cpo-save" name="use-cpo-save">*use-cpo-save*</a><br>
<span class="PreProc">--------------------</span><br>
<br>
上の例の 18 行目では行連結 (<a class="Identifier" href="repeat.html#line-continuation">|line-continuation|</a>) が使われています。ユーザーの<br>
環境で&nbsp;<a class="Type" href="options.html#'compatible'">'compatible'</a>&nbsp;オプションがオンに設定されていると、この行でエラーが発生し<br>
ます。<a class="Type" href="options.html#'compatible'">'compatible'</a>&nbsp;オプションの設定には副作用があるので、勝手に設定をオフにす<br>
ることはできません。問題を避けるには、一時的に&nbsp;<a class="Type" href="options.html#'cpoptions'">'cpoptions'</a>&nbsp;の値を Vim の初期値<br>
に設定し、後で元に戻します。そうすれば、行連結を使うことができ、スクリプトはほ<br>
とんどの環境で動作するようになります。設定の変更は次のようにします:<br>
<br>
<span class="Comment">&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp; let s:save_cpo = &amp;cpo</span><br>
<span class="Comment">&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp; set cpo&amp;vim</span><br>
<span class="Comment">&nbsp;..</span><br>
<span class="Comment">&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp; let &amp;cpo = s:save_cpo</span><br>
<br>
最初に&nbsp;<a class="Type" href="options.html#'cpoptions'">'cpoptions'</a>&nbsp;の値を s:save_cpo 変数に保存します。プラグインの最後でオプ<br>
ションの値を元に戻します。<br>
<br>
スクリプトローカル変数 (<a class="Identifier" href="eval.html#s:var">|s:var|</a>) を使っていることに注目してください。グローバ<br>
ル変数は他の場所で使われている可能性があります。スクリプトの中だけで使う場合は<br>
スクリプトローカル変数を使ってください。<br>
<br>
<br>
ロードしない<br>
<span class="PreProc">------------</span><br>
<br>
ユーザーが常にプラグインをロードしたいと思うとは限りません。また、システム管理<br>
者がシステムのプラグインディレクトリにプラグインを入れたが、ユーザーは自分で入<br>
れたプラグインを使いたいということもあります。したがって、指定したプラグインだ<br>
けを無効にできる必要があります。次のようにします:<br>
<br>
<span class="Comment">&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp; if exists(&quot;g:loaded_typecorr&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finish</span><br>
<span class="Comment">&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp; endif</span><br>
<span class="Comment">&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp; let g:loaded_typecorr = 1</span><br>
<br>
これはスクリプトの二重ロードを避ける効果もあります。スクリプトを二重にロードす<br>
ると、関数の再定義エラーが発生したり、自動コマンドが二重に追加されることでトラ<br>
ブルが起きたりします。<br>
<br>
変数の名前は &quot;loaded_&quot; で始めてプラグインのファイル名をそのまま付けるようにし<br>
てください。&quot;g:&quot; を付けることで関数の中で変数を使用したときに発生するミスを防<br>
いでいます (関数の中では &quot;g:&quot; を付けない変数はローカル変数になります)。<br>
<br>
&quot;finish&quot; を使ってファイルの残りの部分の読み込みを停止しています。この方法は<br>
ファイル全体を if-endif で囲むよりも速いです。<br>
<br>
<br>
マップ<br>
<span class="PreProc">------</span><br>
<br>
さて、プラグインをもっと魅力あるものに仕上げましょう。マップを追加して、カーソ<br>
ルの下の単語に対する修正を追加できるようにします。単純にキーを選んでマップを設<br>
定することもできますが、そのキーは既にユーザーが使っているかもしれません。マッ<br>
プに使用するキーをユーザーが選択できるようにするには、<span class="Special">&lt;Leader&gt;</span>&nbsp;を使います:<br>
<br>
<span class="Comment">&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; map &lt;unique&gt; &lt;Leader&gt;a&nbsp;&nbsp;&lt;Plug&gt;TypecorrAdd</span><br>
<br>
&quot;<span class="Special">&lt;Plug&gt;</span>TypecorrAdd&quot; は目的の動作をします。詳しくは後で説明します。<br>
<br>
使用したいキーを &quot;mapleader&quot; 変数に設定することで、マップの最初のキーを設定で<br>
きます。例えば、次のように設定すると:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let mapleader = &quot;_&quot;</span><br>
<br>
マップは &quot;_a&quot; と定義されます。変数が設定されていない場合は初期設定 (バックス<br>
ラッシュ) が使われます。つまり &quot;\a&quot; というマップが定義されます。<br>
<br>
<span class="Todo">Note</span>: 上記のコマンドでは&nbsp;<span class="Special">&lt;unique&gt;</span>&nbsp;が使われています。これは、同じマップが既に定<br>
義されていた場合にエラーを表示します。<a class="Identifier" href="map.html#:map-<unique>">|:map-&lt;unique&gt;|</a><br>
<br>
マップするキーをユーザーが自分で定義できるようにするには、次のようにします:<br>
<br>
<span class="Comment">&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp; if !hasmapto('&lt;Plug&gt;TypecorrAdd')</span><br>
<span class="Comment">&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; map &lt;unique&gt; &lt;Leader&gt;a&nbsp;&nbsp;&lt;Plug&gt;TypecorrAdd</span><br>
<span class="Comment">&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp; endif</span><br>
<br>
&quot;<span class="Special">&lt;Plug&gt;</span>TypecorrAdd&quot; に対するマップが既にあるかどうかを調べ、無い場合のみ<br>
&quot;<span class="Special">&lt;Leader&gt;</span>a&quot; にマップを定義します。ユーザーは自分の vimrc ファイルの中でマップ<br>
を定義することができます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map ,c&nbsp;&nbsp;&lt;Plug&gt;TypecorrAdd</span><br>
<br>
すると、マップのキーとして &quot;,c&quot; が使われます。&quot;_a&quot; や &quot;\a&quot; は使われません。<br>
<br>
<br>
ピース<br>
<span class="PreProc">------</span><br>
<br>
スクリプトが大きくなると、それを部品ごとに分けたくなります。それには関数やマッ<br>
プを使います。しかし、そうすると関数やマップが他のスクリプトのものと衝突する可<br>
能性があります。例えば、Add() という関数を追加したとき、他のスクリプトでも同じ<br>
名前の関数が定義されているかもしれません。そのような場合は、名前の前に &quot;s:&quot; を<br>
付けて、スクリプトの中だけで使える関数を定義します。<br>
<br>
新しい修正を追加するための関数を定義します:<br>
<br>
<span class="Comment">&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp; function s:Add(from, correct)</span><br>
<span class="Comment">&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let to = input(&quot;type the correction for &quot; . a:from . &quot;: &quot;)</span><br>
<span class="Comment">&nbsp;32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exe &quot;:iabbrev &quot; . a:from . &quot; &quot; . to</span><br>
<span class="Comment">&nbsp;..</span><br>
<span class="Comment">&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp; endfunction</span><br>
<br>
s:Add() 関数は同じスクリプトの中から呼び出すことができます。他のスクリプトが<br>
s:Add() を定義していた場合、それはそのスクリプトにローカルであり、関数が定義さ<br>
れたスクリプトの中からのみ呼び出すことができます。さらにグローバルの Add() 関<br>
数 (&quot;s:&quot;無し) を定義することもでき、それはまた別の関数になります。<br>
<br>
マップ定義では&nbsp;<span class="Special">&lt;SID&gt;</span>&nbsp;が使えます。これは、現在のスクリプトを識別するためのスク<br>
リプト ID を生成します。私たちの入力修正プラグインでは&nbsp;<span class="Special">&lt;SID&gt;</span>&nbsp;を次のように使い<br>
ます:<br>
<br>
<span class="Comment">&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp; noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd&nbsp;&nbsp;&lt;SID&gt;Add</span><br>
<span class="Comment">&nbsp;..</span><br>
<span class="Comment">&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp; noremap &lt;SID&gt;Add&nbsp;&nbsp;:call &lt;SID&gt;Add(expand(&quot;&lt;cword&gt;&quot;), 1)&lt;CR&gt;</span><br>
<br>
ユーザーが &quot;\a&quot; と入力すると、次の手順でキー入力が呼び出されます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\a&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&lt;Plug&gt;TypecorrAdd&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&lt;SID&gt;Add&nbsp;&nbsp;-&gt;&nbsp;&nbsp;:call &lt;SID&gt;Add()</span><br>
<br>
他のスクリプトで&nbsp;<span class="Special">&lt;SID&gt;</span>Add をマップすると、別のスクリプト ID が使われ、別のマッ<br>
プが生成されます。<br>
<br>
<span class="Todo">Note</span>: s:Add() ではなく&nbsp;<span class="Special">&lt;SID&gt;</span>Add() と書いていることに注意してください。マップは<br>
スクリプトの外側でユーザーが入力するものだからです。<span class="Special">&lt;SID&gt;</span>&nbsp;はスクリプト ID に変<br>
換され、どのスクリプトの Add() 関数を呼べばいいのかわかるようになっています。<br>
<br>
これは少し複雑ですが、複数のプラグインを同時に使用するためには必要なことです。<br>
基本的なルールとしては、マップの中では&nbsp;<span class="Special">&lt;SID&gt;</span>Add() を使い、他の場所 (スクリプト<br>
の中、自動コマンド、ユーザー定義コマンド) では s:Add() を使います。<br>
<br>
マップと同じ方法で、メニューを追加することもできます:<br>
<br>
<span class="Comment">&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp; noremenu &lt;script&gt; Plugin.Add\ Correction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SID&gt;Add</span><br>
<br>
プラグインのメニューを追加する場合は &quot;Plugin&quot; メニューの下に登録することが推奨<br>
されています。この例ではメニューが一つだけですが、複数のメニューを追加する場合<br>
は、サブメニューの使用が推奨されています。例えば、&quot;Plugin.CVS&quot; 以下に<br>
&quot;Plugin.CVS.checkin&quot; や &quot;Plugin.CVS.checkout&quot; などの CVS の操作を登録します。<br>
<br>
<span class="Todo">Note</span>: 28 行目では &quot;:noremap&quot; を使って、他のマップでトラブルが起きないようにし<br>
ています。例えば、誰かが &quot;:call&quot; をマップしているかもしれないからです。24 行目<br>
でも &quot;:noremap&quot; を使っていますが、ここでは &quot;<span class="Special">&lt;SID&gt;</span>Add&quot; を再マップして欲しいの<br>
で、&quot;<span class="Special">&lt;script&gt;</span>&quot; を使っています。これを使うとスクリプトローカルなマップだけが再<br>
マップされます&nbsp;<a class="Identifier" href="map.html#:map-<script>">|:map-&lt;script&gt;|</a>。26 行目でも &quot;:noremenu&quot; で同様のことをしていま<br>
す&nbsp;<a class="Identifier" href="gui.html#:menu-<script>">|:menu-&lt;script&gt;|</a>。<br>
<br>
<br>
<span class="Special">&lt;SID&gt;</span>&nbsp;と&nbsp;<span class="Special">&lt;Plug&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#using-<Plug>" name="using-&lt;Plug&gt;">*using-&lt;Plug&gt;*</a><br>
<span class="PreProc">---------------</span><br>
<br>
<span class="Special">&lt;SID&gt;</span>&nbsp;と&nbsp;<span class="Special">&lt;Plug&gt;</span>&nbsp;は、入力したキーに対するマップと、他のマップの中だけで使われる<br>
マップが干渉しないようにするために使われます。<span class="Special">&lt;SID&gt;</span>&nbsp;と&nbsp;<span class="Special">&lt;Plug&gt;</span>&nbsp;の違いに注意して<br>
ください:<br>
<br>
<span class="Special">&lt;Plug&gt;</span>&nbsp;&nbsp;これはスクリプトの外側からも見えます。ユーザーが自分でプラグインの機能<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;をマップできるようにするような場合に使います。<span class="Special">&lt;Plug&gt;</span>&nbsp;は特殊なコード<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;で、キーボードから入力されることはありません。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;キー列が他のプラグインとかぶらないように、<span class="Special">&lt;Plug&gt;</span>&nbsp;スクリプト名 マップ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;名、という形式で使ってください。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我々の例では、スクリプト名が &quot;Typecorr&quot;、マップ名が &quot;Add&quot; なので、<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span class="Special">&lt;Plug&gt;</span>TypecorrAdd&quot; というキー列になります。スクリプト名とマップ名の最<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初の文字だけを大文字にして、どこがマップ名なのかわかるようにします。<br>
<br>
<span class="Special">&lt;SID&gt;</span>&nbsp;&nbsp; これはスクリプト ID (スクリプト固有の識別子) です。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vim は内部で&nbsp;<span class="Special">&lt;SID&gt;</span>&nbsp;を &quot;<span class="Special">&lt;SNR&gt;</span>123_&quot; に変換します (&quot;123&quot;の部分はいろいろ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;な数字が入ります)。つまり、関数 &quot;<span class="Special">&lt;SID&gt;</span>Add()&quot; は、あるスクリプトでは<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<span class="Special">&lt;SNR&gt;</span>11_Add()&quot; という名前になり、別のスクリプトでは &quot;<span class="Special">&lt;SNR&gt;</span>22_Add()&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;になります。これは &quot;:function&quot; コマンドで関数一覧を表示すると確認する<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ことができます。<span class="Special">&lt;SID&gt;</span>&nbsp;の変換はマップの中でも同様におこなわれるので、<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マップの中からスクリプトローカル関数を呼び出すことができます。<br>
<br>
<br>
ユーザ定義コマンド<br>
<span class="PreProc">------------------</span><br>
<br>
修正を追加するためのユーザー定義コマンドを追加します:<br>
<br>
<span class="Comment">&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp; if !exists(&quot;:Correct&quot;)</span><br>
<span class="Comment">&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command -nargs=1&nbsp;&nbsp;Correct&nbsp;&nbsp;:call s:Add(&lt;q-args&gt;, 0)</span><br>
<span class="Comment">&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp; endif</span><br>
<br>
ユーザー定義コマンドは、同じ名前のコマンドがまだない場合のみ定義できます。既に<br>
定義されている場合はエラーになります。&quot;:command!&quot; を使ってユーザー定義関数を上<br>
書きするのは良いアイデアとは言えません。ユーザーは、自分が定義したコマンドがな<br>
ぜ動かないのか不思議に思うでしょう。<a class="Identifier" href="map.html#:command">|:command|</a><br>
<br>
<br>
スクリプト変数<br>
<span class="PreProc">--------------</span><br>
<br>
先頭に &quot;s:&quot; が付いた変数はスクリプト変数です。これはスクリプトの中だけで使えま<br>
す。スクリプトの外からは見えません。同じ名前の変数を複数のスクリプトで使ってし<br>
まうようなトラブルを避けることができます。Vim が実行されている間、変数は保持さ<br>
れます。そして、同じスクリプトが再読み込みされると、再び同じ変数が使われます。<br>
<a class="Identifier" href="eval.html#s:var">|s:var|</a><br>
<br>
スクリプト変数は、同じスクリプトの中で定義された関数、自動コマンド、ユーザー定<br>
義コマンドでも使えます。我々の例に、修正の数を数えるための数行のコードを追加し<br>
ます:<br>
<br>
<span class="Comment">&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp; let s:count = 4</span><br>
<span class="Comment">&nbsp;..</span><br>
<span class="Comment">&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp; function s:Add(from, correct)</span><br>
<span class="Comment">&nbsp;..</span><br>
<span class="Comment">&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let s:count = s:count + 1</span><br>
<span class="Comment">&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo s:count . &quot; corrections now&quot;</span><br>
<span class="Comment">&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp; endfunction</span><br>
<br>
最初に s:count はスクリプトの中で 4 で初期化されます。その後、s:Add() 関数が呼<br>
び出されると、s:count が増加します。関数がどこから呼ばれたかに関わらず、関数が<br>
定義されたスクリプトのローカル変数が使われます。<br>
<br>
<br>
まとめ<br>
<span class="PreProc">------</span><br>
<br>
例題の完成形は以下のようになります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; &quot; Vim global plugin for correcting typing mistakes</span><br>
<span class="Comment">&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp; &quot; Last Change:&nbsp;&nbsp;2000 Oct 15</span><br>
<span class="Comment">&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; &quot; Maintainer:&nbsp;&nbsp; Bram Moolenaar &lt;Bram@vim.org&gt;</span><br>
<span class="Comment">&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; &quot; License:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This file is placed in the public domain.</span><br>
<span class="Comment">&nbsp;&nbsp;5</span><br>
<span class="Comment">&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp; if exists(&quot;g:loaded_typecorr&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finish</span><br>
<span class="Comment">&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp; endif</span><br>
<span class="Comment">&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp; let g:loaded_typecorr = 1</span><br>
<span class="Comment">&nbsp;10</span><br>
<span class="Comment">&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp; let s:save_cpo = &amp;cpo</span><br>
<span class="Comment">&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp; set cpo&amp;vim</span><br>
<span class="Comment">&nbsp;13</span><br>
<span class="Comment">&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp; iabbrev teh the</span><br>
<span class="Comment">&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp; iabbrev otehr other</span><br>
<span class="Comment">&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp; iabbrev wnat want</span><br>
<span class="Comment">&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp; iabbrev synchronisation</span><br>
<span class="Comment">&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ synchronization</span><br>
<span class="Comment">&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp; let s:count = 4</span><br>
<span class="Comment">&nbsp;20</span><br>
<span class="Comment">&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp; if !hasmapto('&lt;Plug&gt;TypecorrAdd')</span><br>
<span class="Comment">&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; map &lt;unique&gt; &lt;Leader&gt;a&nbsp;&nbsp;&lt;Plug&gt;TypecorrAdd</span><br>
<span class="Comment">&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp; endif</span><br>
<span class="Comment">&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp; noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd&nbsp;&nbsp;&lt;SID&gt;Add</span><br>
<span class="Comment">&nbsp;25</span><br>
<span class="Comment">&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp; noremenu &lt;script&gt; Plugin.Add\ Correction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;SID&gt;Add</span><br>
<span class="Comment">&nbsp;27</span><br>
<span class="Comment">&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp; noremap &lt;SID&gt;Add&nbsp;&nbsp;:call &lt;SID&gt;Add(expand(&quot;&lt;cword&gt;&quot;), 1)&lt;CR&gt;</span><br>
<span class="Comment">&nbsp;29</span><br>
<span class="Comment">&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp; function s:Add(from, correct)</span><br>
<span class="Comment">&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let to = input(&quot;type the correction for &quot; . a:from . &quot;: &quot;)</span><br>
<span class="Comment">&nbsp;32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exe &quot;:iabbrev &quot; . a:from . &quot; &quot; . to</span><br>
<span class="Comment">&nbsp;33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if a:correct | exe &quot;normal viws\&lt;C-R&gt;\&quot; \b\e&quot; | endif</span><br>
<span class="Comment">&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let s:count = s:count + 1</span><br>
<span class="Comment">&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo s:count . &quot; corrections now&quot;</span><br>
<span class="Comment">&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp; endfunction</span><br>
<span class="Comment">&nbsp;37</span><br>
<span class="Comment">&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp; if !exists(&quot;:Correct&quot;)</span><br>
<span class="Comment">&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command -nargs=1&nbsp;&nbsp;Correct&nbsp;&nbsp;:call s:Add(&lt;q-args&gt;, 0)</span><br>
<span class="Comment">&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp; endif</span><br>
<span class="Comment">&nbsp;41</span><br>
<span class="Comment">&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp; let &amp;cpo = s:save_cpo</span><br>
<br>
33 行目は説明がまだでした。これは、新しい修正をカーソルの下の単語に適用しま<br>
す。<a class="Identifier" href="various.html#:normal">|:normal|</a>&nbsp;コマンドを使って新しい略語を適用しています。<span class="Todo">Note</span>: マップと略語は<br>
その場で展開されます。&quot;:noremap&quot; で定義されたマップから関数が呼び出されたとし<br>
ても動作は同じです。<br>
<br>
<a class="Type" href="options.html#'fileformat'">'fileformat'</a>&nbsp;オプションを &quot;unix&quot; に設定することが推奨されています。そうすれ<br>
ば、Vim スクリプトはどこでも動作します。<a class="Type" href="options.html#'fileformat'">'fileformat'</a>&nbsp;が &quot;dos&quot; に設定されたスク<br>
リプトは Unix では動作しません。<a class="Identifier" href="repeat.html#:source_crnl">|:source_crnl|</a>&nbsp;も参照。設定が正しいことを確実<br>
にするため、ファイルを保存する前に次のコマンドを実行してください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set fileformat=unix</span><br>
<br>
<br>
ドキュメント&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#write-local-help" name="write-local-help">*write-local-help*</a><br>
<span class="PreProc">------------</span><br>
<br>
プラグインのドキュメントを書くのは良いアイデアです。ユーザーが動作を変更できる<br>
ような場合には特に重要です。<a class="Identifier" href="usr_05.html#add-local-help">|add-local-help|</a>&nbsp;ではどのようにしてドキュメントが<br>
インストールされるか説明されています。<br>
<br>
プラグインヘルプファイルの例を示します (&quot;typecorr.txt&quot;):<br>
<br>
<span class="Comment">&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp; *typecorr.txt*&nbsp;&nbsp;Plugin for correcting typing mistakes</span><br>
<span class="Comment">&nbsp;&nbsp;2</span><br>
<span class="Comment">&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp; If you make typing mistakes, this plugin will have them corrected</span><br>
<span class="Comment">&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; automatically.</span><br>
<span class="Comment">&nbsp;&nbsp;5</span><br>
<span class="Comment">&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp; There are currently only a few corrections.&nbsp;&nbsp;Add your own if you like.</span><br>
<span class="Comment">&nbsp;&nbsp;7</span><br>
<span class="Comment">&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp; Mappings:</span><br>
<span class="Comment">&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp; &lt;Leader&gt;a&nbsp;&nbsp; or&nbsp;&nbsp; &lt;Plug&gt;TypecorrAdd</span><br>
<span class="Comment">&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add a correction for the word under the cursor.</span><br>
<span class="Comment">&nbsp;11</span><br>
<span class="Comment">&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp; Commands:</span><br>
<span class="Comment">&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp; :Correct {word}</span><br>
<span class="Comment">&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add a correction for {word}.</span><br>
<span class="Comment">&nbsp;15</span><br>
<span class="Comment">&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *typecorr-settings*</span><br>
<span class="Comment">&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp; This plugin doesn't have any settings.</span><br>
<br>
書式に気をつけなければならないのは一行目だけです。一行目はコピーされ、help.txt<br>
の &quot;LOCAL ADDITIONS:&quot; の項に埋め込まれます&nbsp;<a class="Identifier" href="index.html#local-additions">|local-additions|</a>。最初の &quot;*&quot; は一<br>
行目の一桁目に書いてください。ヘルプを追加したら &quot;:help&quot; を実行して項目が追加<br>
されたことを確認してください。<br>
<br>
ヘルプの中で ** で文字を囲むとタグを追加することができます。ただし、既存のヘル<br>
プタグと同じものを使わないでください。&quot;typecorr-settings&quot; のように、プラグイン<br>
の名前を使ってタグを作るといいかもしれません。<br>
<br>
ヘルプの他の部分を参照するときは || で囲みます。そうすれば、ユーザーは簡単にヘ<br>
ルプの関連した部分を参照することができます。<br>
<br>
<br>
ファイルタイプの認識&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#plugin-filetype" name="plugin-filetype">*plugin-filetype*</a><br>
<span class="PreProc">--------------------</span><br>
<br>
ファイルタイプが Vim によって認識されない場合は、別ファイルにファイルタイプを<br>
認識するためにコードを作成する必要があります。通常は、自動コマンドを使って、<br>
ファイル名がパターンにマッチしたときにファイルタイプを設定します。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;au BufNewFile,BufRead *.foo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set filetype=foofoo</span><br>
<br>
この一行を　<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>&nbsp;の最初のディレクトリの &quot;ftdetect/foofoo.vim&quot; に書き<br>
込みます。例えば、Unix なら &quot;~/.vim/ftdetect/foofoo.vim&quot; などです。ファイルタ<br>
イプとスクリプトファイルの名前を同じにする決まりになっています。<br>
<br>
必要ならより複雑な処理をすることもできます。例えば、ファイルの中身を見て言語を<br>
判定したりできます。<a class="Identifier" href="filetype.html#new-filetype">|new-filetype|</a>&nbsp;も参照。<br>
<br>
<br>
要約&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#plugin-special" name="plugin-special">*plugin-special*</a><br>
<span class="PreProc">-----</span><br>
<br>
プラグインで使用する特有事項の要約を示します:<br>
<br>
s:name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;スクリプトローカル変数。<br>
<br>
<span class="Special">&lt;SID&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; スクリプトID。マップや関数をスクリプトローカルにする<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;のに使う。<br>
<br>
hasmapto()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;スクリプトが提供している機能に対して、ユーザーが既に<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;マップを定義したかどうかをチェックする関数。<br>
<br>
<span class="Special">&lt;Leader&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mapleader&quot; の値。ユーザーがその変数にキーを設定するこ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;とで、プラグインのマップの開始キーを指定できる。<br>
<br>
:map&nbsp;<span class="Special">&lt;unique&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; マップが既に定義されているなら警告を発する。<br>
<br>
:noremap&nbsp;<span class="Special">&lt;script&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; スクリプトローカルマップだけを使う。グローバルマップは<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使わない。<br>
<br>
exists(&quot;:Cmd&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ユーザー定義コマンドが既にあるかどうかをチェックする。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.12" name="41.12">*41.12*</a>&nbsp;ファイルタイププラグインを書く&nbsp;&nbsp;<a class="Constant" href="usr_41.html#write-filetype-plugin" name="write-filetype-plugin">*write-filetype-plugin*</a>&nbsp;<a class="Constant" href="usr_41.html#ftplugin" name="ftplugin">*ftplugin*</a><br>
<br>
ファイルタイププラグインはグローバルプラグインと似ていますが、カレントバッファ<br>
のマップやオプションだけを設定します。ファイルタイププラグインの使用方法につい<br>
ては&nbsp;<a class="Identifier" href="usr_05.html#add-filetype-plugin">|add-filetype-plugin|</a>&nbsp;を参照してください。<br>
<br>
先に&nbsp;<a class="Identifier" href="usr_41.html#41.10">|41.10|</a>&nbsp;節のグローバルプラグインの項を読んでください。そこで説明されてい<br>
ることはすべてファイルタイププラグインにもあてはまります。この節ではファイルタ<br>
イププラグイン特有の事項だけを説明します。ファイルタイププラグインはカレント<br>
バッファに対してのみ機能するということが最も大切です。<br>
<br>
<br>
無効化<br>
<span class="PreProc">------</span><br>
<br>
ファイルタイププラグインを書いて多くの人に使ってもらおうとするなら、プラグイン<br>
を無効化できるようにしておく必要があります。プラグインの先頭に次のような記述を<br>
追加してください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; このバッファに対してまだ実行されていない場合のみ処理を実行する</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if exists(&quot;b:did_ftplugin&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let b:did_ftplugin = 1</span><br>
<br>
これは同じプラグインが同じバッファで二重にロードされるのを防ぐためにも必要です<br>
(&quot;:edit&quot;コマンドを引数なしで実行したときに発生します)。<br>
<br>
ユーザーは、次の一行だけを書いたファイルタイププラグインを作成することで、標準<br>
プラグインのロードを無効化できます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let b:did_ftplugin = 1</span><br>
<br>
ただし、そのファイルを保存したファイルタイププラグインディレクトリが、<br>
<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>&nbsp;の中で $VIMRUNTIME よりも前にある必要があります。<br>
<br>
標準プラグインを使いつつ、その設定を一つだけ変更したいという場合は、スクリプト<br>
の中で設定を変更することができます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setlocal textwidth=70</span><br>
<br>
このファイルを &quot;after&quot; ディレクトリに保存すると、(例えば filetype=vim なら) 標<br>
準配布の &quot;vim.vim&quot; が読み込まれた後に、保存したファイルが読み込まれるようにな<br>
ります&nbsp;<a class="Identifier" href="options.html#after-directory">|after-directory|</a>。Unix ならファイルのパスは<br>
&quot;~/.vim/after/ftplugin/vim.vim&quot; です。<span class="Todo">Note</span>: 標準プラグインは &quot;b:did_ftplugin&quot;<br>
を設定しますが、ここではそれを無視しています。<br>
<br>
<br>
オプション<br>
<span class="PreProc">----------</span><br>
<br>
ファイルタイププラグインでは、カレントバッファの設定だけを変更するため、次のコ<br>
マンドを使ってオプションを設定してください:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:setlocal</span><br>
<br>
そして、バッファローカルなオプションだけを設定してください (どのオプションがそ<br>
うなのかはヘルプで確認してください)。<a class="Identifier" href="options.html#:setlocal">|:setlocal|</a>&nbsp;コマンドでグローバルオプショ<br>
ンやウィンドウローカルオプションを設定すると、たくさんのバッファの設定が変更さ<br>
れます。ファイルタイププラグインはそのような動作をすべきではありません。<br>
<br>
オプションの値がフラグや設定項目のリストなら、&quot;+=&quot; や &quot;-=&quot; を使うことで既存の<br>
設定を維持することができます。ユーザーがそのオプションの設定を変更している可能<br>
性もあるので注意してください。最初に初期設定に戻してから設定を変更するといいか<br>
もしれません。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:setlocal formatoptions&amp; formatoptions+=ro</span><br>
<br>
<br>
マップ<br>
<span class="PreProc">------</span><br>
<br>
カレントバッファの中だけで機能するマップを作るには次のコマンドを使います:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:map &lt;buffer&gt;</span><br>
<br>
上述したように、マップは二段階に分けて作る必要があります。ファイルタイププラグ<br>
インで機能を定義する例を示します:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !hasmapto('&lt;Plug&gt;JavaImport')</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport &quot;&quot;&lt;Left&gt;&lt;Esc&gt;</span><br>
<br>
<a class="Identifier" href="eval.html#hasmapto()">|hasmapto()|</a>&nbsp;を使って、ユーザーが既に&nbsp;<span class="Special">&lt;Plug&gt;</span>JavaImport に対してマップを定義し<br>
ているかどうかを調べます。未定義ならファイルタイププラグインの標準のマップを定<br>
義します。マップは&nbsp;<span class="Special">&lt;LocalLeader&gt;</span>&nbsp;で開始します。そうすることで、ファイルタイプ<br>
プラグインのマップを開始するキーをユーザーが選択できます。初期設定はバックス<br>
ラッシュです。<br>
&quot;<span class="Special">&lt;unique&gt;</span>&quot; を使って、マップが既に存在したとき、あるいは既存のマップと重複した<br>
ときにエラーメッセージが表示されるようにします。<br>
<a class="Identifier" href="map.html#:noremap">|:noremap|</a>&nbsp;を使って、ユーザーが定義した他のマップの影響を受けないようにしま<br>
す。&quot;:noremap&nbsp;<span class="Special">&lt;script&gt;</span>&quot; を使うと、スクリプトの中で定義した&nbsp;<span class="Special">&lt;SID&gt;</span>&nbsp;で始まるマッ<br>
プだけが再マップされます。<br>
<br>
ユーザーがファイルタイププラグインのマップを無効化できる仕組みを提供しなければ<br>
なりません。例えば、&quot;mail&quot; ファイルタイプのプラグインなら次のようにします:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; マップを追加する。ユーザーが望まない場合は追加しない。</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !exists(&quot;no_plugin_maps&quot;) &amp;&amp; !exists(&quot;no_mail_maps&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; &quot;&gt; &quot; を挿入して引用する</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !hasmapto('&lt;Plug&gt;MailQuote')</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</span><br>
<br>
ここでは二つのグローバル変数が使われています:<br>
&nbsp;&nbsp;no_plugin_maps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;すべてのファイルタイププラグインのマップを無効化<br>
&nbsp;&nbsp;no_mail_maps&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特定のファイルタイププラグインのマップを無効化<br>
<br>
<br>
ユーザー定義コマンド<br>
<span class="PreProc">--------------------</span><br>
<br>
ファイルタイプ用のユーザー定義コマンドを追加して、それを一つのバッファの中だけ<br>
で使えるようにするには、<a class="Identifier" href="map.html#:command">|:command|</a>&nbsp;の引数に &quot;-buffer&quot; を指定します。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:command -buffer&nbsp;&nbsp;Make&nbsp;&nbsp;make %:r.s</span><br>
<br>
<br>
変数<br>
<span class="PreProc">-----</span><br>
<br>
ファイルタイププラグインは対応するすべてのバッファに対して実行されます。スクリ<br>
プトローカル変数&nbsp;<a class="Identifier" href="eval.html#s:var">|s:var|</a>&nbsp;はすべての実行で共有されます。バッファごとの変数を使<br>
いたい場合はバッファローカル変数&nbsp;<a class="Identifier" href="eval.html#b:var">|b:var|</a>&nbsp;を使ってください。<br>
<br>
<br>
関数<br>
<span class="PreProc">-----</span><br>
<br>
関数は一度だけ定義すれば十分です。しかし、ファイルタイププラグインは対応する<br>
ファイルが開かれるたびに読み込まれます。次のようにすると関数が一度だけ定義され<br>
るようになります:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if !exists(&quot;*s:Func&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;function s:Func(arg)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;...</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;endfunction</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif</span><br>
<br>
<br>
アンドゥ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#undo_ftplugin" name="undo_ftplugin">*undo_ftplugin*</a><br>
<span class="PreProc">--------</span><br>
<br>
ユーザーが &quot;:setfiletype xyz&quot; としたとき、それ以前のファイルタイプの効果は無効<br>
になるべきです。b:undo_ftplugin 変数にコマンドを設定し、ファイルタイププラグイ<br>
ンの設定をアンドゥするようにしてください。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let b:undo_ftplugin = &quot;setlocal fo&lt; com&lt; tw&lt; commentstring&lt;&quot;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ . &quot;| unlet b:match_ignorecase b:match_words b:match_skip&quot;</span><br>
<br>
&quot;:setlocal&quot; でオプション名の後に &quot;&lt;&quot; を付けると、そのオプションをグローバルな<br>
値でリセットします。オプションをリセットするにはこの方法が一番です。<br>
<br>
このように行継続を使うには&nbsp;<a class="Type" href="options.html#'cpoptions'">'cpoptions'</a>&nbsp;から &quot;C&quot; フラグを取り除く必要がありま<br>
す。上述の&nbsp;<a class="Identifier" href="usr_41.html#use-cpo-save">|use-cpo-save|</a>&nbsp;を参照してください。<br>
<br>
<br>
ファイル名<br>
<span class="PreProc">----------</span><br>
<br>
ファイルタイププラグインのファイル名にはファイルタイプ名が含まれていなければな<br>
りません&nbsp;<a class="Identifier" href="usr_05.html#ftplugin-name">|ftplugin-name|</a>。次の三つのうちのどれかにしてください:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.../ftplugin/stuff.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.../ftplugin/stuff_foo.vim<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.../ftplugin/stuff/bar.vim<br>
<br>
&quot;stuff&quot; はファイルタイプ名、&quot;foo&quot; と &quot;bar&quot; は任意の名前です。<br>
<br>
<br>
要約&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#ftplugin-special" name="ftplugin-special">*ftplugin-special*</a><br>
<span class="PreProc">-----</span><br>
<br>
ファイルタイププラグインの特有事項を要約します:<br>
<br>
<span class="Special">&lt;LocalLeader&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;maplocalleader&quot; の値。ユーザーがその変数にキーを設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;することで、ファイルタイププラグインのマップの開始キー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;を指定できる。<br>
<br>
:map&nbsp;<span class="Special">&lt;buffer&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; バッファローカルなマップを定義する。<br>
<br>
:noremap&nbsp;<span class="Special">&lt;script&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同スクリプトで定義している&nbsp;<span class="Special">&lt;SID&gt;</span>&nbsp;で始まるマップだけを<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再マップする。<br>
<br>
:setlocal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; カレントバッファのオプションのみ設定する。<br>
<br>
:command -buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;バッファローカルなユーザー定義コマンドを定義する。<br>
<br>
exists(&quot;*s:Func&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 関数が定義済かどうかをチェックする。<br>
<br>
プラグイン全般に関する事項は&nbsp;<a class="Identifier" href="usr_41.html#plugin-special">|plugin-special|</a>&nbsp;を参照してください。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.13" name="41.13">*41.13*</a>&nbsp;コンパイラプラグインを書く&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#write-compiler-plugin" name="write-compiler-plugin">*write-compiler-plugin*</a><br>
<br>
コンパイラプラグインは特定のコンパイラを使うためのオプションを設定します。ユー<br>
ザーは&nbsp;<a class="Identifier" href="quickfix.html#:compiler">|:compiler|</a>&nbsp;コマンドでその設定を読み込むことができます。設定されるオプ<br>
ションは主に&nbsp;<a class="Type" href="options.html#'errorformat'">'errorformat'</a>&nbsp;と&nbsp;<a class="Type" href="options.html#'makeprg'">'makeprg'</a>&nbsp;です。<br>
<br>
百聞は一見に如かず。次のコマンドですべての標準コンパイラプラグインを開くことが<br>
できます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:next $VIMRUNTIME/compiler/*.vim</span><br>
<br>
<a class="Identifier" href="editing.html#:next">|:next|</a>&nbsp;を使って次のプラグインファイルに移動してください。<br>
<br>
これらのファイルには二つの特有事項があります。一つは、標準ファイルに対して設定<br>
を追加したり上書きしたりできる仕組みです。標準ファイルの先頭は次のようになって<br>
います:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:if exists(&quot;current_compiler&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;finish</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let current_compiler = &quot;mine&quot;</span><br>
<br>
コンパイラファイルを書いて、それを個人用のランタイムディレクトリ (例えば Unix<br>
なら ~/.vim/compiler) に置いたとき、&quot;current_compiler&quot; 変数を設定することで標<br>
準ファイルの設定をスキップすることができます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#:CompilerSet" name=":CompilerSet">*:CompilerSet*</a><br>
二つ目は、&quot;:compiler!&quot; が使われたときは &quot;:set&quot; を使い、&quot;:compiler&quot; が使われた<br>
ときは &quot;:setlocal&quot; を使う仕組みです。Vim はそのために &quot;:CompilerSet&quot; という<br>
ユーザーコマンドを定義します。古い Vim はそれを定義しないので、プラグインの中<br>
で定義してください。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;if exists(&quot;:CompilerSet&quot;) != 2</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;command -nargs=* CompilerSet setlocal &lt;args&gt;</span><br>
<span class="Comment">&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp;CompilerSet errorformat&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; use the dfault 'errorformat'</span><br>
<span class="Comment">&nbsp;&nbsp;CompilerSet makeprg=nmake</span><br>
<br>
コンパイラプラグインを書いて、それを Vim の配布物に含めたり、システムのランタ<br>
イムディレクトリに入れたりする場合は、上記の方法を使ってください。<br>
&quot;current_compiler&quot; がユーザープラグインで設定された場合は何も実行しないように<br>
します。<br>
<br>
コンパイラプラグインを書いて標準プラグインの設定を上書きする場合は<br>
&quot;current_compiler&quot; をチェックしないようにします。そのプラグインは最後に読み込<br>
まれないといけないので、<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>&nbsp;の最後にあるディレクトリに置きます。例え<br>
ば、Unix なら ~/.vim/after/compiler などです。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.14" name="41.14">*41.14*</a>&nbsp;プラグインを書く (高速ロード版)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#write-plugin-quickload" name="write-plugin-quickload">*write-plugin-quickload*</a><br>
<br>
プラグインが成長し、とても大きくなることがあります。すると、起動速度は遅くなっ<br>
てきます。例えそのプラグインをたまにしか使わないとしても遅くなります。そういう<br>
ときはクイックロードプラグインの出番です。<br>
<br>
基本的なアイデアはプラグインを二回に分けて読み込むということです。一回目はユー<br>
ザー定義コマンドやマップを定義して機能を提供します。二回目は機能を実装する関数<br>
を定義します。<br>
<br>
スクリプトを二回読み込むことがクイックロードだというと驚かれるかもしれません。<br>
この手法の意味は、一回目は高速に読み込み、スクリプトの重い部分は二回目に後回し<br>
にするということです。二回目の読み込みは、ユーザが実際にその機能を使用したとき<br>
に発生します。あなたがその機能を常に使うなら、これは逆に遅くなってしまいます。<br>
<br>
<span class="Todo">Note</span>&nbsp;Vim 7 以降では代わりの方法があります。<a class="Identifier" href="usr_41.html#41.15">|41.15|</a>&nbsp;で説明されている&nbsp;<a class="Identifier" href="eval.html#autoload">|autoload|</a><br>
機能を使う方法です。<br>
<br>
次に例を示します:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; クイックロードのデモ用のグローバルプラグイン</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; Last Change:&nbsp;&nbsp;2005 Feb 25</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; Maintainer:&nbsp;&nbsp; Bram Moolenaar &lt;Bram@vim.org&gt;</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; License:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This file is placed in the public domain.</span><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !exists(&quot;s:did_load&quot;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command -nargs=* BNRead&nbsp;&nbsp;call BufNetRead(&lt;f-args&gt;)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map &lt;F19&gt; :call BufNetWrite('something')&lt;CR&gt;</span><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let s:did_load = 1</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exe 'au FuncUndefined BufNet* source ' . expand('&lt;sfile&gt;')</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</span><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function BufNetRead(...)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 'BufNetRead(' . string(a:000) . ')'</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; read 機能をここに書く</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunction</span><br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function BufNetWrite(...)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 'BufNetWrite(' . string(a:000) . ')'</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; write 機能をここに書く</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunction</span><br>
<br>
このスクリプトが最初に読み込まれたとき、&quot;s:did_load&quot;　は設定されていません。<br>
&quot;if&quot; と &quot;endif&quot; の間のコマンドが実行されます。<a class="Identifier" href="repeat.html#:finish">|:finish|</a>&nbsp;コマンドによって終了<br>
し、スクリプトの残りの部分は実行されません。<br>
<br>
二回目に読み込まれたときは &quot;s:did_load&quot; が存在するので、&quot;endif&quot; 以降のコマンド<br>
が実行されます。この部分では (長くなる可能性のある) BufNetRead() 関数と<br>
BufNetWrite() 関数を定義します。<br>
<br>
このスクリプトをプラグインディレクトリに置くと、Vim の起動時に実行されます。処<br>
理の流れは次のようになります:<br>
<br>
1. 起動時にスクリプトが読み込まれる。&quot;BNRead&quot; コマンドが定義され、<span class="Special">&lt;F19&gt;</span>&nbsp;キーに<br>
&nbsp;&nbsp; マップが設定される。自動コマンドの&nbsp;<a class="Identifier" href="autocmd.html#FuncUndefined">|FuncUndefined|</a>&nbsp;が定義される。&quot;:finish&quot;<br>
&nbsp;&nbsp; コマンドによってスクリプトが終了する。<br>
<br>
2. ユーザーが BNRead コマンド実行する、または&nbsp;<span class="Special">&lt;F19&gt;</span>&nbsp;キーを押す。BufNetRead()<br>
&nbsp;&nbsp; 関数か BufNetWrite() 関数が呼び出される。<br>
<br>
3. Vim はその関数を見つけることができず、自動コマンドの&nbsp;<a class="Identifier" href="autocmd.html#FuncUndefined">|FuncUndefined|</a>&nbsp;イベン<br>
&nbsp;&nbsp; トを発行する。関数名が &quot;BufNet*&quot; というパターンにマッチするので、&quot;source<br>
&nbsp;&nbsp; fname&quot; コマンドが実行される。&quot;fname&quot; はスクリプトの名前になります。スクリプ<br>
&nbsp;&nbsp; トがどこに保存されていても、&quot;<span class="Special">&lt;sfile&gt;</span>&quot; が展開されてファイル名になります<br>
&nbsp;&nbsp; (<a class="Identifier" href="eval.html#expand()">|expand()|</a>参照)。<br>
<br>
4. スクリプトが再び読み込まれる。&quot;s:did_load&quot; 変数が存在するので関数が定義され<br>
&nbsp;&nbsp; る。<br>
<br>
遅延ロードされる関数の名前が&nbsp;<a class="Identifier" href="autocmd.html#FuncUndefined">|FuncUndefined|</a>&nbsp;自動コマンドのパターンにマッチし<br>
ていることに注意してください。他のプラグインがこのパターンにマッチする関数を定<br>
義しているとうまく動きません。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.15" name="41.15">*41.15*</a>&nbsp;ライブラリスクリプトを書く&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#write-library-script" name="write-library-script">*write-library-script*</a><br>
<br>
いろいろな場所で同じ機能が必要になることがあります。コードが二、三行以上になる<br>
場合は、それを一つのスクリプトに入れて、他のスクリプトから使えるようにしたくな<br>
ると思います。そのようなスクリプトをライブラリスクリプトと呼びます。<br>
<br>
自分でライブラリスクリプトを読み込むことは可能ですが、同じスクリプトを二重に読<br>
み込まないようにする必要があります。それには&nbsp;<a class="Identifier" href="eval.html#exists()">|exists()|</a>&nbsp;関数を使います。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !exists('*MyLibFunction')</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runtime library/mylibscript.vim</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call MyLibFunction(arg)</span><br>
<br>
<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>&nbsp;に設定されたディレクトリの中の &quot;library/mylibscript.vim&quot; の中で<br>
MyLibFunction() が定義されている必要があります。<br>
<br>
これをより簡単にするために、Vim には autoload という仕組みがあります。同じこと<br>
を次のように書くことができます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call mylib#myfunction(arg)</span><br>
<br>
この方がずっと簡単でしょう？ Vim は関数の名前を見て、それが未定義なら、<br>
<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>&nbsp;の中から &quot;autoload/mylib.vim&quot; を探します。そのスクリプトは関数<br>
&quot;mylib#myfunction()&quot; を定義していなければなりません。<br>
<br>
mylib.vim には他の関数も入れられます。ライブラリスクリプトの中では自由に関数を<br>
作ることができます。ただし、関数名の '#' より前の部分はスクリプトの名前と同じ<br>
にする必要があります。そうしないと Vim はどのスクリプトを読み込めばいいのかわ<br>
かりません。<br>
<br>
ライブラリスクリプトをたくさん書く場合は、サブディレクトリを使うといいかもしれ<br>
ません。例:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call netlib#ftp#read('somefile')</span><br>
<br>
Unix では、このライブラリスクリプトは次のような場所に置かれます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~/.vim/autoload/netlib/ftp.vim</span><br>
<br>
関数は次のように定義します:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function netlib#ftp#read(fname)</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;ftp を使ってファイルを読み込む</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunction</span><br>
<br>
関数定義と関数呼び出しではまったく同じ名前が使われます。最後の '#' より前の部<br>
分がサブディレクトリとスクリプトの名前に対応しています。<br>
<br>
同じ方法で変数を扱うこともできます:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let weekdays = dutch#weekdays</span><br>
<br>
これによって &quot;autoload/dutch.vim&quot; が読み込まれます。そのスクリプトには例えば次<br>
のようなコードが書かれています:<br>
<br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',</span><br>
<span class="Comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ 'donderdag', 'vrijdag', 'zaterdag']</span><br>
<br>
より詳しくは&nbsp;<a class="Identifier" href="eval.html#autoload">|autoload|</a>&nbsp;を参照してください。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<a class="Constant" href="usr_41.html#41.16" name="41.16">*41.16*</a>&nbsp;Vim スクリプトを配布する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="usr_41.html#distribute-script" name="distribute-script">*distribute-script*</a><br>
<br>
Vim ユーザーは Vim のウェブサイト&nbsp;<span class="Constant"><a href="http://www.vim.org">http://www.vim.org</a></span>&nbsp;でスクリプトを探します。<br>
便利なスクリプトを作ったら、ぜひ共有しましょう！<br>
<br>
Vim スクリプトはどのシステムでも使えます。tar や gzip コマンドは存在しないこと<br>
があります。ファイルをまとめたり圧縮したりするには &quot;zip&quot; ユーティリティが推奨<br>
されています。<br>
<br>
可搬性を最大限に高めるには、Vim 自身を使ってスクリプトをパッケージ化します。そ<br>
れには Vimball ユーティリティを使います。<a class="Identifier" href="pi_vimball.html#vimball">|vimball|</a>&nbsp;を参照。<br>
<br>
自動更新するための行を書いておくと便利です。<a class="Identifier" href="pi_getscript.html#glvs-plugins">|glvs-plugins|</a>&nbsp;を参照。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
次章:&nbsp;<a class="Identifier" href="usr_42.html">|usr_42.txt|</a>&nbsp;&nbsp;新しいメニューを追加する<br>
<br>
Copyright: see&nbsp;<a class="Identifier" href="usr_01.html#manual-copyright">|manual-copyright|</a>&nbsp;&nbsp;vim&#0058;tw=78:ts=8:ft=help:norl:<br>
